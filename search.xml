<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>股票-均线</title>
      <link href="/posts/1de64287.html"/>
      <url>/posts/1de64287.html</url>
      
        <content type="html"><![CDATA[<h1>均线</h1><p><img src="../image/post/image-20241020171527113.png" alt="image-20241020171527113"></p><p><img src="../image/post/image-20241020172258283.png" alt="image-20241020172258283"></p><p><img src="../image/post/image-20241020172307798.png" alt="image-20241020172307798"></p><hr><h1>缺口</h1><p><img src="../image/post/image-20241020174757070.png" alt="image-20241020174757070"></p><p><img src="../image/post/image-20241020174930138.png" alt="image-20241020174930138"></p><h1>RSI（短线参考）</h1><p><img src="../image/post/image-20241020180057285.png" alt="image-20241020180057285"></p><p><img src="../image/post/image-20241020180540378.png" alt="image-20241020180540378"></p><h1>MACD（中长期参考）</h1><p><img src="../image/post/image-20241020183024605.png" alt="image-20241020183024605"></p><p><img src="../image/post/image-20241020182801641.png" alt="image-20241020182801641"></p><h1>KDJ（随机震荡；短期参考；参考难度大）</h1><p><img src="../image/post/image-20241020183404831.png" alt="image-20241020183404831"></p><p><img src="../image/post/image-20241020183602450.png" alt="image-20241020183602450"></p><p><img src="../image/post/image-20241020183831350.png" alt="image-20241020183831350"></p><ul><li>以50为分界线</li></ul><h1>筹码（缺点多，参考）</h1><p><img src="../image/post/image-20241020184036651.png" alt="image-20241020184036651"></p><p><img src="../image/post/image-20241020184717591.png" alt="image-20241020184717591"></p><p><img src="../image/post/image-20241020184901585.png" alt="image-20241020184901585"></p><p><img src="../image/post/image-20241020185012649.png" alt="image-20241020185012649"></p>]]></content>
      
      
      <categories>
          
          <category> 股票inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 股票 </tag>
            
            <tag> 均线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票-K线图</title>
      <link href="/posts/f137d402.html"/>
      <url>/posts/f137d402.html</url>
      
        <content type="html"><![CDATA[<h1>K线图</h1><hr><ul><li>第二天实体包住第一天全部</li></ul><p><img src="../image/post/image-20241020152346634.png" alt="image-20241020152346634"></p><p><img src="../image/post/image-20241020153050199.png" alt="image-20241020153050199"></p><hr><ul><li>第一天实体包住第二天全部</li></ul><p><img src="../image/post/image-20241020153926999.png" alt="image-20241020153926999"></p><p><img src="../image/post/image-20241020154338927.png" alt="image-20241020154338927"></p><p><img src="../image/post/image-20241020154614954.png" alt="image-20241020154614954"></p><p><img src="../image/post/image-20241020154722075.png" alt="image-20241020154722075"></p><p><img src="../image/post/image-20241020154941090.png" alt="image-20241020154941090"></p><hr><p><img src="../image/post/image-20241020170415559.png" alt="image-20241020170415559"></p><p><img src="../image/post/image-20241020170951221.png" alt="image-20241020170951221"></p>]]></content>
      
      
      <categories>
          
          <category> 股票inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 股票 </tag>
            
            <tag> K线图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-要点-项目管理</title>
      <link href="/posts/52a5e4b2.html"/>
      <url>/posts/52a5e4b2.html</url>
      
        <content type="html"><![CDATA[<h1>项目管理</h1><h2 id="进度管理">进度管理</h2><p><strong>进度管理包括哪些过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 活动定义：确定完成项目的各个可交付成果所必须进行的各项具体活动</span><br><span class="line">2. 活动排序</span><br><span class="line">3. 活动资源估计</span><br><span class="line">4. 活动历时估算</span><br><span class="line">5. 制定进度计划</span><br><span class="line">6. 进度控制</span><br></pre></td></tr></table></figure><h2 id="盈亏分析">盈亏分析</h2><p><strong>正常情况、盈亏平衡时的公式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正常情况：销售额 = 固定成本 + 可变成本 + 税费 + 利润</span><br><span class="line">盈亏平衡：销售额 = 固定成本 + 可变成本 + 税费 + 0</span><br></pre></td></tr></table></figure><h2 id="软件配置管理">软件配置管理</h2><p><strong>产品配置有哪些配置项</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基线配置项（可交付成果）：需求文档、设计文档、源代码、测试用例、运行所需数据等</span><br><span class="line">非基线配置项：各类计划、各类报告</span><br><span class="line"></span><br><span class="line">产品配置就是一个产品在其生命周期各个阶段所产生的各种形式和各种版本的集合。</span><br></pre></td></tr></table></figure><p><strong>软件配置管理(SCM)的核心内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">版本控制和变更控制</span><br></pre></td></tr></table></figure><h2 id="软件质量管理">软件质量管理</h2><p><strong>软件质量保证的主要内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">软件质量保证（SQA）：</span><br><span class="line">1. SQA审计和评审</span><br><span class="line">2. SQA报告</span><br><span class="line">3. 处理不符合问题</span><br></pre></td></tr></table></figure><p><strong>软件能力成熟度模型集成CMMI等级</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">成熟度由低到高</span><br><span class="line">1. 初始级：随意且混乱、组织成功依赖于个人能力</span><br><span class="line">2. 已管理级：项目级可重复【建立了项目级的控制过程】</span><br><span class="line">3. 已定义级：组织级，文档化、标准化</span><br><span class="line">4. 定量管理级：量化式管理【过程性能可预测】</span><br><span class="line">5. 优化级：持续优化</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 思维导图知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-要点-软件工程</title>
      <link href="/posts/15e280ad.html"/>
      <url>/posts/15e280ad.html</url>
      
        <content type="html"><![CDATA[<h1>软件工程</h1><h2 id="开发模型">开发模型</h2><p><strong>软件工程有哪些开发模型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 瀑布模型【*】</span><br><span class="line">- 严格区分阶段，每个阶段因果关系紧密相连</span><br><span class="line">- 只适合需求明确的项目</span><br><span class="line">2. 原型模型【*】</span><br><span class="line">- 原型模型两个阶段：原型开发阶段和目标软件开发阶段</span><br><span class="line">- 适合需求不明确的项目</span><br><span class="line">- 分为抛弃型原型（快速原型）和演化性原型</span><br><span class="line">3. V模型</span><br><span class="line">- 测试贯穿于始终</span><br><span class="line">- 需求分析对应验收测试与系统测试；概要设计对应集成测试，详细设计对应单元测试。</span><br><span class="line">4. 迭代与增量</span><br><span class="line">5. 螺旋模型【*】</span><br><span class="line">- 以快速原型为基础 + 瀑布模型</span><br><span class="line">- 考虑了风险问题</span><br><span class="line">6. 基于构件的开发模型（CBSD）</span><br><span class="line">- 易拓展、易重用、降低成本、安排任务更灵活</span><br><span class="line">- 要求架构师能力高</span><br><span class="line">7. 基于构件的软件工程（CBSE）</span><br><span class="line">- 体现了购买而不是重新构造的哲学</span><br><span class="line">8. 快速应用开发（RAD）</span><br><span class="line">- SDLC(瀑布) + CBSD(基于构件)</span><br><span class="line">9. 软件统一过程（UP/RUP）【*】</span><br><span class="line">10. 敏捷模型【*】</span><br></pre></td></tr></table></figure><p><strong>软件工程有哪些过程模型</strong>（新版）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 瀑布模型</span><br><span class="line">2. 原型模型</span><br><span class="line">3. 软件统一过程（UP/RUP）</span><br><span class="line">4. 敏捷模型</span><br></pre></td></tr></table></figure><p><strong>CBSE构件所应该具备的特征</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 可组装性：所有外部交互必须通过公开定义的接口进行</span><br><span class="line">2. 可部署性：构件总是二进制形式的，能作为一个独立的实体在平台上运行</span><br><span class="line">3. 文档化：用户根据文档来判断构件是否满足需求</span><br><span class="line">4. 独立性：可以在无其他特殊构件的情况下进行组装和部署</span><br><span class="line">5. 标准化：符合某种标准化的构件模型</span><br></pre></td></tr></table></figure><p><strong>CBSE构件的组装顺序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 顺序组装：按顺序调用已存在的构件，可以用两个已经存在的构件来创造一个新的构件</span><br><span class="line">2. 层次组装：被调用构件“提供”的接口必须和调用构件的“请求”接口兼容</span><br><span class="line">3. 叠加组装：多个构件合并形成新的构件，新构件整合原构件的功能，对外提供新的接口</span><br></pre></td></tr></table></figure><p><strong>RUP模型的几个阶段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始-&gt;细化-&gt;构造-&gt;移交</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20241008201333612.png" alt="image-20241008201333612"></p><p><strong>RUP的4+1视图模型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">逻辑、实现、用例、进程、部署</span><br><span class="line">P50</span><br></pre></td></tr></table></figure><p><strong>净室软件工程（CSE）的技术手段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 统计过程控制下的增量式开发：控制迭代</span><br><span class="line">2. 基于函数的规范和设计：盒子结构</span><br><span class="line">3. 正确性验证：净室软件工程的核心</span><br><span class="line">4. 统计测试和软件认证：使用统计学原理，总体太大时采用抽样</span><br></pre></td></tr></table></figure><p><strong>净室软件工程（CSE）的缺点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 太过理论化，正确性验证的步骤困难且耗时</span><br><span class="line">2. 不进行传统的模块测试</span><br><span class="line">3. 带有传统软件工程的弊端</span><br></pre></td></tr></table></figure><h2 id="需求工程">需求工程</h2><p><strong>需求工程有几个阶段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 需求获取</span><br><span class="line">2. 需求分析</span><br><span class="line">3. 形成需求规格（需求文档化）【SRS】</span><br><span class="line">4. 需求的确认与验证【形成需求基线】</span><br><span class="line">5. 需求管理【变更控制、版本控制、需求跟踪、需求状态跟踪】</span><br><span class="line"></span><br><span class="line">注：1-4 也叫需求开发。5需求管理是对需求基线进行管理</span><br></pre></td></tr></table></figure><p><strong>需求的分类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分层维度：</span><br><span class="line">1. 业务需求</span><br><span class="line">2. 用户需求</span><br><span class="line">3. 功能需求</span><br><span class="line">QFD（项目管理维度）：</span><br><span class="line">1. 基本需求</span><br><span class="line">2. 期望需求</span><br><span class="line">3. 兴奋需求</span><br></pre></td></tr></table></figure><p><strong>需求获取方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户面谈：成本高，有领域知识</span><br><span class="line">联合需求计划（JRP）：交互好，各方参与</span><br><span class="line">问卷调查：用户多，成本低</span><br><span class="line">现场观察：针对复杂流程</span><br><span class="line">原型化方法：解决早期需求不明确</span><br><span class="line">头脑风暴：新业务，发散思维</span><br></pre></td></tr></table></figure><p><strong>需求分析（系统分析/设计）的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 结构化方法</span><br><span class="line">2. 面向对象方法</span><br><span class="line">3. 其他方法（软件重用）</span><br><span class="line">4. 逆向工程</span><br></pre></td></tr></table></figure><p><strong>结构化分析方法使用的手段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据流图DFD</span><br><span class="line">状态转换图</span><br><span class="line">ER图</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20241008203421467.png" alt="image-20241008203421467"></p><p><img src="../image/post/image-20241008203428644.png" alt="image-20241008203428644"></p><p><img src="../image/post/image-20241008203438039.png" alt="image-20241008203438039"></p><p><strong>面向对象方法使用的手段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UML</span><br></pre></td></tr></table></figure><p><strong>UML的4+1视图</strong></p><p><img src="../image/post/image-20241008203907964.png" alt="image-20241008203907964"></p><p><strong>需求定义（需求文档化所用到的方法）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 严格定义法</span><br><span class="line">- 所有需求都能被预先定义</span><br><span class="line">- 开发人员和用户之间能够准确而清晰地交流</span><br><span class="line">- 采用文字/图形充分体现最终系统</span><br><span class="line">2. 原型法</span><br><span class="line">- 开发前需求不明确</span><br><span class="line">- 交流困难</span><br><span class="line">- 需要实际的、可供用户参与的系统模型</span><br><span class="line">- 有合适的系统开发环境</span><br></pre></td></tr></table></figure><h2 id="软件设计">软件设计</h2><p><strong>软件设计分为哪几类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 软件系统建模</span><br><span class="line">2. 结构化设计</span><br><span class="line">3. 面向对象设计</span><br><span class="line">4. 界面设计</span><br></pre></td></tr></table></figure><p><strong>有哪几种软件系统建模方法</strong></p><p><img src="../image/post/image-20241008204917703.png" alt="image-20241008204917703"></p><p><strong>结构化设计的分类和原则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分类：</span><br><span class="line">1. 概要设计【外部设计】：功能需求分配给软件模块，确定每个模块的功能和调用关系，形成模块结构图</span><br><span class="line">2. 详细设计【内部设计】：为每个具体任务选择适当的技术手段和处理方法</span><br><span class="line"></span><br><span class="line">原则：</span><br><span class="line">1. 模块独立性原则（高内聚，低耦合）</span><br><span class="line">2. 保持模块大小适中</span><br><span class="line">3. 多扇入，少扇出</span><br><span class="line">4. 深度和宽度均不宜过高</span><br></pre></td></tr></table></figure><p><strong>结构化设计中模块的四个要素</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 输入和输出</span><br><span class="line">2. 处理功能</span><br><span class="line">3. 内部数据</span><br><span class="line">4. 程序代码</span><br></pre></td></tr></table></figure><p><strong>结构化设计中内聚、耦合的类型</strong></p><p><img src="../image/post/image-20241008205344398.png" alt="image-20241008205344398"></p><p><img src="../image/post/image-20241008205351767.png" alt="image-20241008205351767"></p><p><strong>面向对象设计的基本过程</strong></p><p><img src="../image/post/image-20241008205448865.png" alt="image-20241008205448865"></p><p><strong>面向对象设计中类的分类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 边界类：API接口；用户界面；显示屏；二维码；购物车；</span><br><span class="line">2. 控制类：排除法</span><br><span class="line">3. 实体类：学员；课程</span><br></pre></td></tr></table></figure><p><strong>界面设计的法则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 置于用户控制之下</span><br><span class="line">2. 减少用户的记忆负担</span><br><span class="line">3. 保持界面的一致性</span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><p><strong>测试的分类（类型）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">动态测试【计算机运行】</span><br><span class="line">- 白盒</span><br><span class="line">- 黑盒</span><br><span class="line">- 灰盒</span><br><span class="line">静态测试【人工监测和计算机辅助分析】</span><br><span class="line">- 桌前检查</span><br><span class="line">- 代码审查</span><br><span class="line">- 代码走查</span><br></pre></td></tr></table></figure><p><strong>测试的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">白盒测试【结构测试】：主要用于单元测试</span><br><span class="line">- 控制流测试（语句覆盖最弱，路径测试覆盖最强）</span><br><span class="line">- 数据流测试</span><br><span class="line">- 程序变异测试</span><br><span class="line">黑盒测试【功能测试】：主要用于集成、确认、系统测试</span><br><span class="line">- 等价类划分</span><br><span class="line">- 边界值分析</span><br><span class="line">- 错误推测</span><br><span class="line">- 判定表</span><br><span class="line">- 因果图</span><br></pre></td></tr></table></figure><p><strong>测试有哪些阶段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V模型</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20241008210305238.png" alt="image-20241008210305238"></p><h2 id="维护">维护</h2><p><strong>遗留系统演化策略是什么</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">高水平低价值【信息孤岛】：集成</span><br><span class="line">- 遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，但对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛，对这种遗留系统的演化策略为集成。</span><br><span class="line"></span><br><span class="line">高水平高价值：改造（包括系统功能增强和数据模型改造）</span><br><span class="line">- 遗留系统具有较高的业务价值，基本上能够满足企业业务运作和决策支持的需要。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变；数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型的转化。</span><br><span class="line"></span><br><span class="line">低水平低价值：淘汰</span><br><span class="line">- 遗留系统的技术含量较低，且具有较低的业务价值。对遗留系统的完全淘汰是企业资源的根本浪费，系统分析师应该善于“变废为宝”，通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。</span><br><span class="line"></span><br><span class="line">低水平高价值：继承</span><br><span class="line">- 遗留系统的技术含量较低，已经满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业的业务尚紧密依赖该系统。对这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。</span><br><span class="line"></span><br><span class="line">开发新系统时，需要完全兼容遗留系统的功能模型和数据模型</span><br></pre></td></tr></table></figure><p><strong>软件维护有哪些类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 正确性维护【修BUG】：识别和纠正软件的错误/缺陷</span><br><span class="line">2. 适应性维护【应变】：应用软件适应环境变化而进行的修改</span><br><span class="line">3. 完善性维护【新需求】：扩充功能和改善性能而进行的修改</span><br><span class="line">4. 预防性维护【针对未来】：为了适应未来的软硬件环境的变化</span><br></pre></td></tr></table></figure><p><strong>影响可维护性的因素有哪些</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 可理解性</span><br><span class="line">2. 可修改性</span><br><span class="line">3. 可测试性</span><br><span class="line">4. 可靠性</span><br><span class="line">5. 可移植性</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 思维导图知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-要点-系统工程和信息系统基础</title>
      <link href="/posts/55148790.html"/>
      <url>/posts/55148790.html</url>
      
        <content type="html"><![CDATA[<h1>系统工程与信息系统基础</h1><h2 id="系统工程">系统工程</h2><p><strong>系统工程的概念和特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 系统工程利用计算机作为工具，对系统的结构、元素、信息和反馈等进行分析，以达到最优规划、最优设计、最优管理和最优控制的目的</span><br><span class="line">2. 从整体出发、从系统观念出发，以求整体最优</span><br></pre></td></tr></table></figure><p><strong>系统工程有哪些方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 霍尔三维结构</span><br><span class="line">2. 切克兰德方法</span><br><span class="line">3. 并行工程方法</span><br><span class="line">4. 综合集成方法</span><br><span class="line">5. WSR系统方法</span><br></pre></td></tr></table></figure><p><strong>霍尔三维结构是哪三维？各维度特点？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 逻辑维</span><br><span class="line">2. 时间维</span><br><span class="line">3. 知识维</span><br><span class="line"></span><br><span class="line">逻辑维：会定义和分析系统的要素、子系统、过程、功能以及相互之间如何协作</span><br><span class="line">- 明确问题</span><br><span class="line">- 确定目标（建立价值体系或评价体系）</span><br><span class="line">- 系统综合</span><br><span class="line">- 系统分析</span><br><span class="line">- 优化（解决方案的优化选择）</span><br><span class="line">- 系统决策</span><br><span class="line">- 实施计划</span><br><span class="line"></span><br><span class="line">时间维：这个维度强调过程、阶段、状态、趋势和系统的生命周期。会使用时序图、甘特图或者PERT图等工具来规划和监控项目进度。</span><br><span class="line">- 规划阶段（调研，谋求活动的规划与战略）</span><br><span class="line">- 拟定方案（提出具体的计划方案）</span><br><span class="line">- 研制阶段（完成研制方案及生产计划）</span><br><span class="line">- 生产阶段（生产零部件及提出安装计划）</span><br><span class="line">- 安装阶段（安装完毕，完成系统的运行计划）</span><br><span class="line">- 运行阶段（系统按照预期的用途开展服务）</span><br><span class="line">- 更新阶段（改进原有系统、或消亡原有系统）</span><br><span class="line"></span><br><span class="line">知识维：知识维关注于“我们如何了解和控制系统”，即所需的技术、原则、理论、数据和经验。</span><br></pre></td></tr></table></figure><p><strong>切克兰德方法的过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1. 认识问题</span><br><span class="line">实地考察公园、与公园管理员、游客、维护人员等进行交流，收集他们对现状的看 法，如公园保洁不足、娱乐设施老化等问题。</span><br><span class="line">2. 根底定义</span><br><span class="line">对于每个关键问题制定根底定义，比如，“公园维护系统”可能有这样的根底定 义：“一个旨在提供清洁、安全、愉悦环境的服务系统。”</span><br><span class="line">3. 建立概念模型</span><br><span class="line">依据“公园维护系统”的根底定义，构建一个包括垃圾回收、设施检查、游客反馈处理等活动的概念模型。</span><br><span class="line">4. 比较与探寻</span><br><span class="line">把概念模型与实际的公园运营情况相比较，识别出哪些是按照概念模型运作得好的地方，哪些是存在差异的地方，并探讨为什么会有这种差异。</span><br><span class="line">5. 选择</span><br><span class="line">决定一系列改变，例如增加保洁人员、更新娱乐设施、创建游客反馈系统等，这些都是在现实条件下可行且期望达到的改变。</span><br><span class="line">6. 设计与实施</span><br><span class="line">制定具体行动计划来实施这些改变，比如招聘更多的保洁人员、购置新的设施或开发一个在线反馈平台。</span><br><span class="line">7. 评估与反馈</span><br><span class="line">在实施后，持续对改变效果进行监测和评估，收集游客、员工的反馈，并根据反馈结果调整行动计划。</span><br></pre></td></tr></table></figure><p><strong>并行工程的特点</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 产品设计开发期间，最快速度按质完成</span><br><span class="line">2. 各项工作期间问题协调解决</span><br><span class="line">3. 适当的信息系统工具</span><br></pre></td></tr></table></figure><p><strong>综合集成方法的原则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 整体论原则</span><br><span class="line">2. 相互联系原则</span><br><span class="line">3. 有序性原则</span><br><span class="line">4. 动态原则</span><br></pre></td></tr></table></figure><p><strong>WSR系统方法的三个关键维度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">技术层面（物理）</span><br><span class="line">管理层面（事理）</span><br><span class="line">人文层面（人理）</span><br></pre></td></tr></table></figure><p><strong>系统工程生命周期阶段及方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">探索性研究</span><br><span class="line">概念阶段</span><br><span class="line">开发阶段</span><br><span class="line">生产阶段</span><br><span class="line">使用阶段</span><br><span class="line">保障阶段</span><br><span class="line">退役阶段</span><br></pre></td></tr></table></figure><h2 id="信息系统基础">信息系统基础</h2><p><strong>信息系统的生命周期是什么</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 产生</span><br><span class="line">2. 开发</span><br><span class="line">    - 总体规划</span><br><span class="line">    - 系统分析</span><br><span class="line">    - 系统设计</span><br><span class="line">    - 系统实施</span><br><span class="line">    - 系统验收</span><br><span class="line">3. 运行</span><br><span class="line">4. 消亡</span><br></pre></td></tr></table></figure><p><strong>信息系统的建设原则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 高层管理人员介入</span><br><span class="line">2. 用户参与开发</span><br><span class="line">3. 自顶向下</span><br><span class="line">4. 工程化</span><br></pre></td></tr></table></figure><p><strong>信息系统开发方法</strong>(BOOK)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 以书本为主，一下内容参考 //</span><br><span class="line"></span><br><span class="line">1. 结构化方法</span><br><span class="line">特点：</span><br><span class="line">- 自顶向下，逐步分解求精</span><br><span class="line">- 开发目标清晰化</span><br><span class="line">- 工作阶段程式化</span><br><span class="line">- 开发文档规范化</span><br><span class="line">- 设计方法结构化</span><br><span class="line">- 应变能力差</span><br><span class="line">2. 面向对象方法</span><br><span class="line">特点：</span><br><span class="line">- 自底向上</span><br><span class="line">- 阶段界线不明</span><br><span class="line">- 更好的应变、更好的复用</span><br><span class="line">- 符合人们的思维习惯</span><br><span class="line">3. 面向服务方法</span><br><span class="line">特点：</span><br><span class="line">- 粗粒度、松耦合</span><br><span class="line">- 标准化和构件化</span><br><span class="line">- 抽象级别：操作-&gt;服务-&gt;业务流程</span><br><span class="line">4. 形式化方法</span><br><span class="line">- 应用数学和逻辑的严格技术，以确保软件或系统设计的正确性和一致性。</span><br><span class="line">5. 统一过程方法(RUP)</span><br><span class="line">特点：</span><br><span class="line">- 是一个迭代和增量的软件开发框架，旨在通过结构化的阶段和多个迭代来逐步细化和完善软件产品。</span><br><span class="line">- 以架构为中心，用例驱动，迭代与增量</span><br><span class="line">- 四个阶段：初始、细化、构造、交付</span><br><span class="line">6. 敏捷方法</span><br><span class="line">- 一组灵活、迭代的软件开发实践，旨在快速响应需求变化并促进跨职能团队之间的密切协作。</span><br><span class="line">7. 基于架构的开发方法(ABSD)</span><br><span class="line">- 以软件系统的结构设计为核心，围绕创建、维护和演化系统架构来组织开发活动的方法。</span><br></pre></td></tr></table></figure><p><strong>信息系统的分类</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 业务处理系统【TPS】</span><br><span class="line">- 又称为电子数据处理系统</span><br><span class="line">- 在服务于组织管理层次中最底层，最基础的信息系统</span><br><span class="line">- 包含五个活动：数据输入、业务处理、文件和数据库处理、文件和报告产生、查询处理活动</span><br><span class="line">2. 信息管理系统【MIS】</span><br><span class="line">3. 决策支持系统【DSS】</span><br><span class="line">4. 专家系统【ES】</span><br><span class="line">5. 办公自动化系统【OA】</span><br><span class="line">6. 企业资源计划【ERP】</span><br></pre></td></tr></table></figure><h2 id="企业信息化">企业信息化</h2><p><strong>企业信息化（组织信息化）的目的、需求是什么</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目的：提高企业的竞争力</span><br><span class="line">需求：</span><br><span class="line">1. 战略需求：提升组织的竞争能力</span><br><span class="line">2. 运作需求：实现信息化战略目标、运作策略、人才培养的需要</span><br><span class="line">3. 技术需求：信息技术层面上对系统的完善、升级、集成</span><br></pre></td></tr></table></figure><p><strong>企业信息化有哪些方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 业务流程重构方法：彻底的、根本性的重新设计流程</span><br><span class="line">2. 核心业务应用方法：围绕核心业务推动信息化</span><br><span class="line">3. 信息系统建设方法：建设信息系统作为企业信息化的重点和关键</span><br><span class="line">4. 主题数据库方法：建立面向企业核心业务的数据库，消除信息孤岛</span><br><span class="line">5. 资源管理方法：切入点是为了企业资源管理提供强大的工具</span><br><span class="line">6. 人力资本投资方法：把一部分企业的优秀员工看作是一种资本</span><br></pre></td></tr></table></figure><p><strong>企业信息化体系全览图</strong></p><p><img src="../image/post/image-20241007111459421.png" alt="image-20241007111459421"></p><p><strong>企业信息化模型有哪些</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 企业资源计划ERP</span><br><span class="line">- 进化流程：物料需求管理-&gt;制造资源计划（核心是物流）-&gt;企业资源计划（重心转移到财务上）</span><br><span class="line">- 主要功能模块：财会管理；物流管理；生产控制管理；人力资源管理</span><br><span class="line">2. 客户关系管理CRM</span><br><span class="line">- 目的：提高收入；核心思想：以客户为中心</span><br><span class="line">3. 供应链管理SCM</span><br><span class="line">- 强强联合，打通企业间的”信息孤岛“</span><br><span class="line">- 信息化的“三流”。信息流、资金流、物流</span><br><span class="line">4. 商业智能BI</span><br><span class="line">5. 数据湖</span><br><span class="line">6. 业务流程重组BPR和业务流程管理BPM</span><br><span class="line">- 前者是颠覆原有流程、后者循环改进</span><br></pre></td></tr></table></figure><p><strong>商业智能BI和数据湖是什么，二者有什么区别</strong>(BOOK)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 以书本为主，一下内容参考 //</span><br><span class="line"></span><br><span class="line">1. 商业智能：用于决策分析，使用OLAP在线分析处理</span><br><span class="line">- 应用：数据仓库和数据挖掘</span><br><span class="line"></span><br><span class="line">2. 数据湖：存储企业的各种各样原始数据的大型仓库，其中的数据可供存取、处理、分析和传输。</span><br><span class="line">- 数据分类：结构化数据（表格数据）、非结构化数据（图片、视频、音频、文档）</span><br><span class="line"></span><br><span class="line">二者区别：</span><br><span class="line">数据仓库：仅支持数据分析处理。</span><br><span class="line">数据湖：即支持数据分析处理，也支持事务处理。</span><br><span class="line">具体见下图：</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20241007164314099.png" alt="image-20241007164314099"></p><h2 id="信息系统战略规划">信息系统战略规划</h2><p><strong>信息系统战略规划和企业信息化规划的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">企业信息化规划：涉及多个领域的融合，它是企业战略、管理规划、业务流程重组等内容的综合规划活动。其中，企业战略规划是评价环境和企业现状，进而选择和确定企业的总体和长远目标，制定和抉择实现目标的行动方案。</span><br><span class="line"></span><br><span class="line">信息系统战略规划：关注如何通过信息系统来支撑业务流程的运作，进而实现企业的关键业务目标。</span><br></pre></td></tr></table></figure><p><strong>信息系统战略规划的三个阶段</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一阶段：以数据处理为核心围绕职能部门需求</span><br><span class="line">第二阶段：以企业内部MIS为核心围绕企业整体需求</span><br><span class="line">第三阶段：综合考虑企业内外环境以集成为核心，围绕企业的战略需求</span><br></pre></td></tr></table></figure><p><strong>信息系统战略规划每个阶段的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一阶段：</span><br><span class="line">- 关键成功因素法CSF</span><br><span class="line">- 战略集合转化法SST</span><br><span class="line">- 企业系统规划法BSP</span><br><span class="line">第二阶段：</span><br><span class="line">- 战略数据规划法SDP：主题数据库</span><br><span class="line">- 信息工程法IE</span><br><span class="line">- 战略栅格法SG</span><br><span class="line">第三阶段：</span><br><span class="line">- 价值链分析VCA</span><br><span class="line">- 战略一致性模型</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="企业应用集成EAI">企业应用集成EAI</h2><p><strong>什么是企业应用集成，以及作用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">企业各系统互联互通，就是企业应用集成。</span><br><span class="line">作用：传统企业系统未互联互通，存在信息孤岛，这种架构也被称为烟囱架构。企业应用集成就是用于消除信息孤岛。</span><br></pre></td></tr></table></figure><p><strong>有哪些企业集成方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">业界没有一个统一的标准</span><br><span class="line">普遍：</span><br><span class="line">1. 表示集成（界面集成）</span><br><span class="line">2. 数据集成</span><br><span class="line">3. 控制集成（应用集成，API集成）</span><br><span class="line">4. 业务流程集成（过程集成，B2B）</span><br><span class="line">5. 门户集成</span><br></pre></td></tr></table></figure><p><strong>各集成方式对比</strong></p><p><img src="../image/post/image-20241007165425096.png" alt="image-20241007165425096"></p><p><strong>门户集成的分类</strong></p><p><img src="../image/post/image-20241007165531356.png" alt="image-20241007165531356"></p><h2 id="信息系统新技术">信息系统新技术</h2><p><strong>有哪些信息系统的新技术</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数字化</span><br><span class="line">2. 智能制造</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 思维导图知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W-函数参数的直接传递和匿名传递</title>
      <link href="/posts/be585466.html"/>
      <url>/posts/be585466.html</url>
      
        <content type="html"><![CDATA[<h1>函数参数的直接传递和匿名传递</h1><p>notifier()：前端消息处理器，用来统一处理WebSocket消息。</p><p>notifier#attachMessageEvent：添加消息事件，参数为事件event</p><p>事件event：由各个控制器定义，不同controller内自己定义、实现。比如新建newProjectController、刷新updateController</p><p><strong>添加方式：假设事件实现为notifierMessage，如果notifierMessage内代码有this（使用了controller中的对对象），则只能使用箭头函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// updateController类中</span></span><br><span class="line"><span class="comment">// 1. 箭头函数（匿名函数）</span></span><br><span class="line"><span class="title function_">notifier</span>().<span class="title function_">attachMessageEvent</span>(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">notifierMessage</span>(message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 有引用的箭头函数（匿名函数）</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_messageFunction</span> = <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notifierMessage</span>(message);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">notifier</span>().<span class="title function_">attachMessageEvent</span>(<span class="variable language_">this</span>.<span class="property">_messageFunction</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 直接传递</span></span><br><span class="line"><span class="title function_">notifier</span>().<span class="title function_">attachMessageEvent</span>(<span class="variable language_">this</span>.<span class="property">notifierMessage</span>);</span><br><span class="line"></span><br><span class="line">前两种：</span><br><span class="line">  <span class="variable language_">this</span> 关键字指的是箭头函数外部的 <span class="variable language_">this</span> 上下文，也就是定义 notifierMessage 方法的对象的上下文。</span><br><span class="line">  箭头函数继承了其外部作用域的 <span class="variable language_">this</span> 值，因此 <span class="variable language_">this</span>.<span class="property">notifierMessage</span> 将引用正确的 </span><br><span class="line">  notifierMessage 方法。</span><br><span class="line">【第二种有个好处是可以获取到匿名函数，因为匿名函数有了一个引用<span class="variable language_">this</span>.<span class="property">_messageFunction</span>， </span><br><span class="line">  通过<span class="variable language_">this</span>.<span class="property">_messageFunction</span> 即可获取这个匿名函数。比如需要notifier取消绑定该事件消息时，</span><br><span class="line">  需要根据引用，只能使用第二种方式】</span><br><span class="line"></span><br><span class="line">最后一种：<span class="variable language_">this</span> 关键字同样指的是定义 notifierMessage 方法的对象的上下文。</span><br><span class="line">  但是，需要注意的是，在非严格模式下，当一个函数作为普通函数调用</span><br><span class="line">  时（而不是作为对象的方法），<span class="variable language_">this</span> 的值通常会被设置为</span><br><span class="line">  全局对象（在浏览器中是 <span class="variable language_">window</span>）。因此，如果没有明确绑定 </span><br><span class="line">  <span class="variable language_">this</span>，notifierMessage 可能不会按照预期工作。</span><br><span class="line">【因为是将event传递给notifier，后续由notifier调用，所以作为普通函数调用。】</span><br></pre></td></tr></table></figure><p><strong>区别总结</strong></p><ul><li><p><strong>代码片段一</strong>：</p></li><li><ul><li>使用了一个箭头函数来包裹对 <code>this.notifierMessage</code> 的调用。<ul><li>保证了 <code>this</code> 的正确上下文，即使 <code>notifierMessage</code> 方法内部依赖于 <code>this</code> 的值。</li></ul></li></ul></li><li><p><strong>代码片段二</strong>：</p></li><li><ul><li>直接传递 <code>this.notifierMessage</code> 方法给 <code>attachMessageEvent</code>。<ul><li>如果 <code>notifierMessage</code> 内部依赖于 <code>this</code> 的值，并且该方法不是作为对象的方法被调用，可能会导致 <code>this</code> 的值不符合预期。</li></ul></li></ul></li></ul><blockquote><p><strong>注意：</strong></p><p>notifier 添加的事件是 controller中的函数，所以当controller对象被回收时（没有controller对象引用时）这个事件也就失效了。即**对象被垃圾回收以后，其他 引用该对象方法的 方法，也会失效。**比如，controller 被回收以后，notifier中注册的该 controller 的 this.notifierMessage 方法也失效了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工作inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS函数参数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWeb-Spring高级知识学习</title>
      <link href="/posts/20fd9c70.html"/>
      <url>/posts/20fd9c70.html</url>
      
        <content type="html"><![CDATA[<h1>Spring高级知识点</h1><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1P44y1N7QG/?p=8&amp;spm_id_from=pageDriver&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1P44y1N7QG/?p=8&amp;spm_id_from=pageDriver&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><p>参考文章：<a href="https://mofan212.github.io/posts/Spring-Forty-Nine-Lectures-Container-And-Bean/">https://mofan212.github.io/posts/Spring-Forty-Nine-Lectures-Container-And-Bean/</a></p></blockquote><h2 id="Spring容器">Spring容器</h2><p>以 SpringBoot 的启动类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A01Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(A01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>run()</code>方法存在返回值，返回 ConfigurableApplicationContext 容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(Application.class, args);</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20240824102311015.png" alt="image-20240824102311015"></p><p>ConfigurableApplicationContext 接口继承了 ApplicationContext 接口，而 ApplicationContext 接口又间接地继承了 BeanFactory 接口，除此之外还继承了其他很多接口，相当于对 BeanFactory 进行了拓展。</p><h3 id="BeanFactory">BeanFactory</h3><ul><li>是 ApplicationContext 的父接口</li><li>是 Spring 的核心容器，主要的 ApplicationContext 实现 组合 了它的功能，也就是说，BeanFactory 是 ApplicationContext 中的一个成员变量。</li></ul><p>常用的 context.getBean(“xxx”) 方法，其实是调用了 BeanFactory 的 getBean() 方法。</p><p>其他方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">preInstantiateSingletons()：预先初始化单例对象</span><br><span class="line">addEmbeddedValueResolver()：给beanFactory加入解析器</span><br><span class="line">    常见参数：</span><br><span class="line">    - <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>()::resolvePlaceholders ： $&#123;&#125; 解析器</span><br></pre></td></tr></table></figure><p>基于它的子接口：</p><ul><li>ListableBeanFactory：提供获取 Bean 集合的能力，比如一个接口可能有多个实现，通过该接口下的方法就能获取某种类型的所有 Bean；</li><li>HierarchicalBeanFactory：Hierarchical 意为“层次化”，通常表示一种具有层级结构的概念或组织方式，这种层次化结构可以通过父子关系来表示对象之间的关联，比如树、图、文件系统、组织架构等。根据该接口下的方法可知，能够获取到父容器，说明 BeanFactory 有父子容器概念；</li><li>AutowireCapableBeanFactory：提供了创建 Bean、自动装配 Bean、属性填充、Bean 初始化、依赖注入等能力，比如 @Autowired 注解的底层实现就依赖于该接口的 resolveDependency() 方法；</li><li>ConfigurableBeanFactory：该接口并未直接继承至 BeanFactory，而是继承了 HierarchicalBeanFactory。</li></ul><blockquote><p><strong>BeanFactory不会</strong>：</p><ul><li>主动调用 BeanFactory 后置处理器；</li><li>主动添加 Bean 后置处理器；</li><li>主动初始化单例对象；</li><li>解析 ${} 和 #{}</li></ul></blockquote><h4 id="DefaultListableBeanFactory">DefaultListableBeanFactory</h4><p><img src="../image/post/image-20240824102509577.png" alt="image-20240824102509577"></p><ul><li>DefaultListableBeanFactory 实现了 BeanFactory 接口，它能管理 Spring 中所有的 Bean，当然也包含 Spring 容器中的那些单例对象。</li><li>DefaultListableBeanFactory 还继承了 DefaultSingletonBeanRegistry 类，这个类就是用来管理 Spring 容器中的单例对象。</li><li>通过 DefaultListableBeanFactory#registerBeanDefinition 可以注册bean到容器中</li></ul><h4 id="BeanFactoryPostProcessor">BeanFactoryPostProcessor</h4><p>BeanFactory后置处理器，典型的有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br></pre></td></tr></table></figure><p>比如：internalConfigurationAnnotationProcessor就是用来处理 @Configuration 和 @Bean 注解的，将配置类中定义的 Bean 信息补充到 BeanFactory 中。</p><h4 id="BeanPostProcessor">BeanPostProcessor</h4><p>Bean后置处理器，典型的有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br></pre></td></tr></table></figure><p>前者用于解析 @Autowired 注解，后者用于解析 @Resource 注解，它们都有一个共同的类型 BeanPostProcessor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurationClassPostProcessor.class</span><br></pre></td></tr></table></figure><p>用于解析 @ComponentScan @Bean @Import @ImportResource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapperScannerConfigurer.class</span><br></pre></td></tr></table></figure><p>用于解析 @MapperScan</p><h4 id="DefaultSingletonBeanRegistry">DefaultSingletonBeanRegistry</h4><p>用来管理 Spring 容器中的单例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>Map 的 key 就是 Bean 的名字，而 value 是对应的 Bean，即单例对象。</p><h3 id="BeanDefinition">BeanDefinition</h3><p>BeanDefinition 也是一个接口，它封装了 Bean 的定义，Spring 根据 Bean 的定义，就能创建出符合要求的 Bean。</p><p>读取 BeanDefinition 可以通过下列两种类完成：</p><ul><li>BeanDefinitionReader</li><li>ClassPathBeanDefinitionScanner</li></ul><h4 id="BeanDefinitionReader">BeanDefinitionReader</h4><p>该接口中对 loadBeanDefinitions() 方法进行了多种重载，支持传入一个或多个 Resource 对象、资源位置来加载 BeanDefinition。</p><p>它有一系列相关实现，比如：</p><ul><li>XmlBeanDefinitionReader：通过读取 XML 文件来加载；</li><li>PropertiesBeanDefinitionReader：通过读取 properties 文件来加载，此类已经被 @Deprecated 注解标记；</li></ul><p>除此之外，还有一个 AnnotatedBeanDefinitionReader，尽管它并不是 BeanDefinition 的子类，但它们俩长得很像，根据其类注释可知：它能够通过编程的方式对 Bean 进行注册，是 ClassPathBeanDefinitionScanner 的替代方案，能读取通过注解定义的 Bean。</p><h4 id="ClassPathBeanDefinitionScanner">ClassPathBeanDefinitionScanner</h4><p>通过扫描指定包路径下的 @Component 及其派生注解来注册 Bean，是 @ComponentScan 注解的底层实现。</p><p>比如 MyBatis 通过继承 ClassPathBeanDefinitionScanner 实现通过 @MapperScan 注解来扫描指定包下的 Mapper 接口。</p><h4 id="BeanDefinitionRegistry">BeanDefinitionRegistry</h4><p>AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner 中都有一个 BeanDefinitionRegistry 类型的成员变量，它是一个接口，提供了 BeanDefinition 的增加、删除和查找功能。</p><h3 id="ApplicationContext">ApplicationContext</h3><p>ApplicationContext 除了继承 BeanFactory 外，还继承了：</p><ul><li>MessageSource：使其具备处理国际化资源的能力</li><li>ResourcePatternResolver：使其具备使用通配符进行资源匹配的能力</li><li>EnvironmentCapable：使其具备读取 Spring 环境信息、配置文件信息的能力</li><li>ApplicationEventPublisher：使其具备发布事件的能力</li><li>ListableBeanFactory：提供了获取某种类型的 Bean 集合的能力</li><li>HierarchicalBeanFactory：提供了获取父容器的能力</li></ul><blockquote><p>虽然 ApplicationContext 继承了很多接口，但这些能力的实现是通过一种委派（Delegate）的方式实现的，这种方式也被叫做委派模式。</p><p>委派模式：实现获取资源的方式并不是由实现类自身完成，而是交给其内部的一个成员变量完成，这样的方式就是委派（这和对象适配器模式很相似）。在日常编码遇到这样的实现逻辑时，类名可以以 Delegate 结尾。</p></blockquote><h4 id="ApplicationContext的相关实现"><strong>ApplicationContext的相关实现</strong></h4><ul><li>ClassPathXmlApplicationContext：基于 classpath 下的 xml 格式的配置文件来创建Bean</li><li>FileSystemXmlApplicationContext：基于磁盘路径下 xml 格式的配置文件来创建Bean</li></ul><blockquote><p>本质都是利用 XmlBeanDefinitionReader#loadBeanDefinitions 加载Bean</p></blockquote><ul><li>AnnotationConfigApplicationContext：基于 Java 配置类来创建</li><li>AnnotationConfigServletWebServerApplicationContext：基于 Java 配置类来创建，用于 web 环境</li></ul><h4 id="ConfigurableApplicationContext">ConfigurableApplicationContext</h4><p>ApplicationContext 有一个子接口 ConfigurableApplicationContext，从类名就可以看出，它提供了对 ApplicationContext 进行配置的能力，浏览其内部方法可知，提供了诸如设置父容器、设置 Environment 等能力。</p><h4 id="AbstractApplicationContext">AbstractApplicationContext</h4><p>ApplicationContext 有一个非常重要的抽象实现 AbstractApplicationContext，其他具体实现都会继承这个抽象实现，在其内部通过委派的方式实现了一些接口的能力，除此之外还有一个与 Spring Bean 的生命周期息息相关的方法：refresh()。</p><h3 id="Bean">Bean</h3><h4 id="生命周期">生命周期</h4><p>初始化和销毁 Bean 的实现有三种：</p><ol><li>依赖于后置处理器提供的拓展功能</li><li>相关接口的功能</li><li>使用 @Bean 注解中的属性进行指定</li></ol><p>当同时存在以上三种方式时，它们的执行顺序也将按照上述顺序进行执行。</p><p>通过实现以下 BeanPostProcessor 接口，可以增强 Bean</p><ul><li>InstantiationAwareBeanPostProcessor</li><li>DestructionAwareBeanPostProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span>, DestructionAwareBeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeforeDestruction</span><span class="params">(Object o, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 销毁执行之前，如 @PreDestroy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行，这里返回的对象会替换掉原本的 bean&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行，如果返回 false 会跳过依赖注入节点&quot;</span>);</span><br><span class="line">            <span class="comment">// return false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行，如 @Autowired、@Value、@Resource&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化执行之前，这里返回的对象会替换掉原本的 bean，如 @PostConstruct、@ConfigurationProperties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行，这里返回的对象会替换掉原本的 bean，如代理增强&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line">输出：</span><br><span class="line">    </span><br><span class="line">indi.mofan.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行，这里返回的对象会替换掉原本的 bean</span><br><span class="line">indi.mofan.bean.a03.LifeCycleBean        : 构造</span><br><span class="line">indi.mofan.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行，如果返回 <span class="literal">false</span> 会跳过依赖注入节点</span><br><span class="line">indi.mofan.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行，如 <span class="meta">@Autowired</span>、<span class="meta">@Value</span>、<span class="meta">@Resource</span></span><br><span class="line">indi.mofan.bean.a03.LifeCycleBean        : 依赖注入: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.mofan.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化执行之前，这里返回的对象会替换掉原本的 bean，如 <span class="meta">@PostConstruct</span>、<span class="meta">@ConfigurationProperties</span></span><br><span class="line">indi.mofan.bean.a03.LifeCycleBean        : 初始化</span><br><span class="line">indi.mofan.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行，这里返回的对象会替换掉原本的 bean，如代理增强</span><br><span class="line">indi.mofan.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 销毁执行之前，如 <span class="meta">@PreDestroy</span></span><br><span class="line">indi.mofan.bean.a03.LifeCycleBean        : 销毁</span><br></pre></td></tr></table></figure><h4 id="设计模式">设计模式</h4><p>为什么实现了 BeanPostProcessor 接口后就能够在 Bean 生命周期的各个阶段进行拓展呢？</p><p>因为使用了模板方法设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">            processor.inject(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProcessor</span><span class="params">(BeanPostProcessor processor)</span> &#123;</span><br><span class="line">        processors.add(processor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后如果需要拓展，调用 MyBeanFactory 实例的 addProcessor() 方法添加拓展逻辑即可：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">    beanFactory.addProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Autowired&quot;</span>));</span><br><span class="line">    beanFactory.addProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Resource&quot;</span>));</span><br><span class="line">    beanFactory.getBean();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20240824172029016.png" alt="image-20240824172029016"></p><h4 id="ConfigurationProperties-注解">@ConfigurationProperties 注解</h4><p>使用 @ConfigurationProperties 可以指定配置信息的前缀，使得配置信息的读取更加简单。</p><h4 id="AutowiredAnnotationBeanPostProcessor">AutowiredAnnotationBeanPostProcessor</h4><p>用于解析 @Autowired 和 @Value 注解</p><p><strong>AutowiredAnnotationBeanPostProcessor#postProcessProperties()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 findAutowiringMetadata() 用于查找指定的 bean 对象中哪些地方使用了 @Autowired、@Value 等与注入相关的注解，并将这些信息封装在 InjectionMetadata 对象中，之后调用其 inject() 方法利用反射完成注入。</p><blockquote><p>InjectionMetadata 对象中有一个名为 injectedElements 的集合类型成员变量，根据上图所示，injectedElements 存储了被相关注解标记的成员变量、方法的信息，因为 Bean1 中的 bean3 成员变量、setBean2() 和 setHome() 方法恰好被 @Autowired 注解标记。</p></blockquote><h4 id="Scope">Scope</h4><p>Scope 用于指定 Bean 的作用范围，有如下五个取值：</p><ol><li>singleton：单例（默认值）。容器启动时创建（未设置延迟），容器关闭时销毁</li><li>prototype：多例。每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory#destroyBean() 进行销毁</li><li>request：作用于 Web 应用的请求范围。每次请求用到此 Bean 时创建，请求结束时销毁</li><li>session：作用于 Web 应用的会话范围。每个会话用到此 Bean 时创建，会话结束时销毁</li><li>application：作用于 Web 应用的 ServletContext。Web 容器用到此 Bean 时创建，容器关闭时销毁</li></ol><blockquote><p>application 的作用范围是 ServletContext，要想 application scope 发生变化可以重启程序。</p></blockquote><h3 id="Aware-接口">Aware 接口</h3><p>Aware 接口用于注入一些与容器相关的信息，比如：</p><ul><li>BeanNameAware 注入 Bean 的名字</li><li>BeanFactoryAware 注入 BeanFactory 容器</li><li>ApplicationContextAware 注入 ApplicationContext 容器</li><li>EmbeddedValueResolverAware 解析 ${}</li></ul><blockquote><ol><li>Aware 接口提供了一种 内置 的注入手段，可以注入 BeanFactory、ApplicationContext；</li><li>InitializingBean 接口提供了一种 内置 的初始化手段；</li><li>内置的注入和初始化不受拓展功能的影响，总会被执行，因此 Spring 框架内部的类总是使用这些接口。</li></ol></blockquote><h4 id="Aware-相关接口">Aware 相关接口</h4><p><strong>BeanNameAware, ApplicationContextAware</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mofan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/8 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;名字叫: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;容器是: &quot;</span> + applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>InitializingBean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; 初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当同时实现 Aware 接口和 InitializingBean 接口时，会先执行 Aware 接口。</p><p>BeanFactoryAware 、ApplicationContextAware 和 EmbeddedValueResolverAware 三个接口的功能可以使用 @Autowired 注解实现，InitializingBean 接口的功能也可以使用 @PostConstruct 注解实现，为什么还要使用接口呢？</p><h4 id="为何有这些接口">为何有这些接口</h4><p>@Autowired 和 @PostConstruct 注解的解析需要使用 Bean 后置处理器，属于拓展功能，而这些接口属于内置功能，不加任何拓展 Spring 就能识别。在某些情况下，拓展功能会失效，而内容功能不会失效。</p><p>对于 context.refresh(); 方法来说，它主要按照以下顺序干了三件事：</p><ol><li>执行 BeanFactory 后置处理器；</li><li>添加 Bean 后置处理器；</li><li>创建和初始化单例对象。</li></ol><p><strong>失效场景</strong></p><p>当 Java 配置类中定义了BeanFactoryPostProcessor 时，如果要创建配置类中的 BeanFactoryPostProcessor 就必须 提前 创建和初始化 Java 配置类。</p><p>在创建和初始化 Java 配置类时，由于 BeanPostProcessor 还未准备好，无法解析配置类中的 @Autowired 等注解，导致 @Autowired 等注解失效：</p><blockquote><p>具体场景参考博客。</p></blockquote><p><strong>如果一个单例对象的成员变量是多例，怎么办才能在getBean的时候，获取的成员变量是多例的</strong></p><p>eg：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class1</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class2</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> F1 f1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.mofan.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 输出的F1为同一个</span></span><br></pre></td></tr></table></figure><p>原因：对于单例对象来说，依赖注入仅发生了一次，后续不会再注入其他的 f1，因此 e 始终使用的是第一次注入的 f1</p><p>解决：</p><ol><li>可以<strong>使用 @Lazy 注解，因为 @Lazy 生成的是代理对象</strong>，虽然代理对象依旧是同一个，但每次使用代理对象中的方法时，会由代理对象创建新的目标对象</li><li>其他推荐方式（Object工程、Context容器）参考博客</li></ol><h2 id="AOP">AOP</h2><h3 id="前置基础">前置基础</h3><ol><li>aop的实现方式（除jdk、cglib外的实现方式）</li><li>aop源码、原理</li></ol><blockquote><p>以上参考博客（9-13）：</p><p><a href="https://mofan212.github.io/posts/Spring-Forty-Nine-Lectures-AOP/">https://mofan212.github.io/posts/Spring-Forty-Nine-Lectures-AOP/</a></p></blockquote><h3 id="Pointcut（切点）">Pointcut（切点）</h3><p>在 Spring 中，切点通过接口 org.springframework.aop.Pointcut 来表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据类型过滤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据方法匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Canonical Pointcut instance that always matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">TRUE</span> <span class="operator">=</span> TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pointcut 接口有很多实现类，比如：</p><ul><li>AnnotationMatchingPointcut：通过注解进行匹配</li><li>AspectJExpressionPointcut：通过 AspectJ 表达式进行匹配（本节的选择）</li><li>StaticMethodMatcherPointcut：通过注解进行匹配（视频中匹配 @Transactional 时使用）</li></ul><p>无论是 AspectJExpressionPointcut 还是 StaticMethodMatcherPointcut，它们都实现了 MethodMatcher 接口，用来执行方法的匹配。</p><h4 id="AspectJExpressionPointcut">AspectJExpressionPointcut</h4><p>判断编写的 AspectJ 表达式是否与某一方法匹配可以使用其 matches() 方法。</p><h4 id="StaticMethodMatcherPointcut">StaticMethodMatcherPointcut</h4><blockquote><p>@Transactional 是 Spring 中使用频率非常高的注解，那它底层是通过 AspectJExpressionPointcut 与 @annotation() 切点表达式相结合对目标方法进行匹配的吗？</p></blockquote><p>答案是否定的。@Transactional 注解除了可以作用在方法上，还可以作用在类（或接口）上。</p><p>在底层 @Transactional 注解的匹配使用到了 StaticMethodMatcherPointcut</p><h3 id="Advice（通知）">Advice（通知）</h3><p>MethodInterceptor：这个接口实现的通知属于环绕通知。</p><h3 id="Aspect（切面）">Aspect（切面）</h3><p>DefaultPointcutAdvisor：创建这种切面时，传递一个节点和通知。</p><blockquote><p>/*</p><ul><li><p>多个切面：</p></li><li><p>aspect =</p></li><li><p>通知 1 （advice） + 切点 1（pointcut）</p></li><li><p>通知 2 （advice） + 切点 2（pointcut）</p></li><li><p>通知 3 （advice） + 切点 3（pointcut）</p></li><li><p>…</p></li><li><p>advisor = 更细粒度的切面，包含一个通知和切点</p></li><li><p>*/</p></li></ul></blockquote><h3 id="ProxyFactory">ProxyFactory</h3><blockquote><p>Spring 是根据什么信息来选择不同的动态代理实现呢？</p></blockquote><p>ProxyFactory 的父类 ProxyConfig 中有个名为 proxyTargetClass 的布尔类型成员变量：</p><ul><li>当 proxyTargetClass == false，并且目标对象所在类实现了接口时，将选择 JDK 动态代理；</li><li>当 proxyTargetClass == false，但目标对象所在类未实现接口时，将选择 CGLib 动态代理；</li><li>当 proxyTargetClass == true，总是选择 CGLib 动态代理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置实现的接口</span></span><br><span class="line">factory.setInterfaces(target.getClass().getInterfaces());</span><br><span class="line"><span class="comment">// 设置proxyTargetClass </span></span><br><span class="line">factory.setProxyTargetClass(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><hr><p>ProxyFactory 是用来创建代理的核心实现，使用 AopProxyFactory 选择具体的代理实现：</p><ul><li>JdkDynamicAopProxy</li><li>ObjenesisCglibAopProxy</li></ul><p>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现，AopProxy 通过 getProxy() 方法创建代理对象。</p><p>上述类图中的类与接口都实现了 Advised 接口，能够获得关联的切面集合与目标（实际上是从 ProxyFactory 中获取的）。</p><p>调用代理方法时，会借助 ProxyFactory 统一将通知转换为环绕通知 MethodInterceptor。。</p><h3 id="AnnotationAwareAspectJAutoProxyCreator">AnnotationAwareAspectJAutoProxyCreator</h3><p>Bean 后置处理器。尽管它的名称中没有 BeanPostProcessor 的字样，但它确实是实现了 BeanPostProcessor 接口的。</p><p>AnnotationAwareAspectJAutoProxyCreator 有两个主要作用：</p><ol><li>找到容器中所有的切面，针对高级切面，将其转换为低级切面；</li><li>根据切面信息，利用 ProxyFactory 创建代理对象。</li></ol><p>AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor，可以在 Bean 生命周期中的一些阶段对 Bean 进行拓展。AnnotationAwareAspectJAutoProxyCreator 可以在 Bean 进行 <strong>依赖注入之前、Bean 初始化之后</strong> 对 Bean 进行拓展。</p><p><strong>重点介绍 AnnotationAwareAspectJAutoProxyCreator 中的两个方法：</strong></p><ul><li>findEligibleAdvisors</li><li>wrapIfNecessary</li></ul><h4 id="findEligibleAdvisors">findEligibleAdvisors</h4><p>位于父类 AbstractAdvisorAutoProxyCreator 中，用于找到符合条件的切面类。低级切面直接添加，高级切面转换为低级切面再添加。</p><p>findEligibleAdvisors() 方法接收两个参数：</p><ul><li>beanClass：配合切面使用的目标类 Class 信息</li><li>beanName：当前被代理的 Bean 的名称</li></ul><h4 id="wrapIfNecessary">wrapIfNecessary</h4><p>wrapIfNecessary() 方法内部调用了 findEligibleAdvisors() 方法，若 findEligibleAdvisors() 方法返回的集合不为空，则表示需要创建代理对象。</p><p>如果需要创建对象，wrapIfNecessary() 方法返回的是代理对象，否则仍然是原对象。</p><p>wrapIfNecessary() 方法接收三个参数：</p><ul><li>bean：原始 Bean 实例</li><li>beanName：Bean 的名称</li><li>cacheKey：用于元数据访问的缓存 key</li></ul><h3 id="Order">@Order</h3><p>根据上述打印的信息可知，低级切面相比于高级切面先一步被执行，这个执行顺序是可以被控制的。</p><p>针对高级切面来说，可以在类上使用 <code>@Order</code> 注解</p><p>在高级切面中，@Order 只有放在类上才生效，放在方法上不会生效。比如高级切面中有多个前置通知，这些前置通知对应的方法上使用 @Order 注解是无法生效的。</p><p>针对低级切面，需要设置 advisor 的 order 值，而不是向高级切面那样使用 @Order 注解，使用 @Order 注解设置在 advisor3() 方法上是无用的。</p><h3 id="代理对象创建时机">代理对象创建时机</h3><p>使用 AnnotationAwareAspectJAutoProxyCreator Bean 后置处理器创建代理对象的时机有以下两个选择：</p><ul><li>Bean 的依赖注入之前</li><li>Bean 初始化完成之后</li></ul><p>代理对象的创建时机：</p><ul><li>无循环依赖时，在 Bean 初始化阶段之后创建；</li><li>有循环依赖时，在 Bean 实例化后、依赖注入之前创建，并将代理对象暂存于二级缓存。</li></ul><p>Bean 的依赖注入阶段和初始化阶段不应该被增强，仍应被施加于原始对象。</p><h3 id="高级切面转低级切面">高级切面转低级切面</h3><p>调用 AnnotationAwareAspectJAutoProxyCreator 对象的 findEligibleAdvisors() 方法时，获取能配合目标 Class 使用的切面，最终返回 Advisor 列表。在搜索过程中，如果遇到高级切面，则会将其转换成低级切面。</p><p>以解析 @Before 注解为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 切面对象实例工厂，用于后续反射调用切面中的方法</span></span><br><span class="line">    <span class="type">AspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">Aspect</span>());</span><br><span class="line">    <span class="comment">// 高级切面转低级切面类</span></span><br><span class="line">    List&lt;Advisor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Before.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类。前置通知对应的通知类是 AspectJMethodBeforeAdvice</span></span><br><span class="line">            <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面（advice转换成advisor）</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : list) &#123;</span><br><span class="line">        System.out.println(advisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Before 标记的前置通知会被转换成原始的 AspectJMethodBeforeAdvice 形式，该对象包含了以下信息：</p><ul><li>通知对应的方法信息</li><li>切点信息</li><li>通知对象如何创建，本例公用一个 Aspect 对象</li></ul><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">对应的原始通知类</th></tr></thead><tbody><tr><td style="text-align:center">@Before</td><td style="text-align:center">AspectJMethodBeforeAdvice</td></tr><tr><td style="text-align:center">@AfterReturning</td><td style="text-align:center">AspectJAfterReturningAdvice</td></tr><tr><td style="text-align:center">@AfterThrowing</td><td style="text-align:center">AspectJAfterThrowingAdvice</td></tr><tr><td style="text-align:center">@After</td><td style="text-align:center">AspectJAfterAdvice</td></tr><tr><td style="text-align:center">@Around</td><td style="text-align:center">AspectJAroundAdvice</td></tr></tbody></table><h3 id="静态通知调用">静态通知调用</h3><p>详情见参考博客</p><h3 id="动态通知调用">动态通知调用</h3><p>详情见参考博客</p><h2 id="MVC">MVC</h2><h3 id="RequestMappingHandlerMapping">RequestMappingHandlerMapping</h3><p>HandlerMapping，即处理器映射器，用于建立请求路径与控制器方法的映射关系。</p><p>RequestMappingHandlerMapping 是 HandlerMapping 的一种实现，根据类名可知，它是通过 @RequestMapping 注解来实现路径映射。</p><p>当 Spring 容器中没有 HandlerMapping 的实现时，尽管 DispatcherServlet 在初始化时会添加一些默认的实现，但这些实现不会交由 Spring 管理，而是作为 DispatcherServlet 的成员变量。</p><h3 id="RequestMappingHandlerAdapter">RequestMappingHandlerAdapter</h3><p>RequestMappingHandlerAdapter 实现了 HandlerAdapter 接口，HandlerAdapter 用于执行控制器方法，而 RequestMapping 表明 RequestMappingHandlerAdapter 用于执行被 @RequestMapping 注解标记的控制器方法。</p><blockquote><p>实现控制器方法的调用很简单，但如何将请求参数与方法参数相绑定的呢？</p></blockquote><p>显然是需要解析 @RequestParam 注解。</p><p>Spring 支持许多种类的控制器方法参数，不同种类的参数使用不同的解析器，使用 RequestMappingHandlerAdapter 的 getArgumentResolvers() 方法获取所有参数解析器。</p><p>Spring 也支持许多种类的控制器方法返回值类型，使用 RequestMappingHandlerAdapter 的 getReturnValueHandlers() 方法获取所有返回值处理器。</p><h3 id="参数解析器">参数解析器</h3><h4 id="RequestParam">@RequestParam</h4><p>@RequestParam 注解的解析需要使用到 RequestParamMethodArgumentResolver 参数解析器。构造时需要两个参数：</p><ul><li>beanFactory：Bean 工厂对象。需要解析 ${} 时，就需要指定 Bean 工厂对象</li><li>useDefaultResolution：布尔类型参数。为 false 表示只解析添加了 @RequestParam 注解的参数，为 true 针对未添加 @RequestParam 注解的参数也使用该参数解析器进行解析。</li></ul><p>RequestParamMethodArgumentResolver 利用 resolveArgument() 方法完成参数的解析，该方法需要传递四个参数：</p><ul><li>parameter：参数对象</li><li>mavContainer：ModelAndView 容器，用来存储中间的 Model 结果</li><li>webRequest：由 ServletWebRequest 封装后的请求对象</li><li>binderFactory：数据绑定工厂，用于完成对象绑定和类型转换，比如将字符串类型的 18 转换成整型</li></ul><h4 id="PathVariable">@PathVariable</h4><p>@PathVariable 注解的解析需要使用到 PathVariableMethodArgumentResolver 参数解析器。构造时无需传入任何参数。</p><p>使用该解析器需要一个 Map 集合，该 Map 集合是 @RequestMapping 注解上指定的路径和实际 URL 路径进行匹配后，得到的路径上的参数与实际路径上的值的关系（获取这个 Map 并将其设置给 request 作用域由 HandlerMapping 完成）。</p><h4 id="RequestHeader">@RequestHeader</h4><p>@RequestHeader 注解的解析需要使用到 RequestHeaderMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><h4 id="CookieValue">@CookieValue</h4><p>@CookieValue 注解的解析需要使用到 ServletCookieValueMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><h4 id="Value">@Value</h4><p>@Value 注解的解析需要使用到 ExpressionValueMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><h4 id="HttpServletRequest">HttpServletRequest</h4><p>HttpServletRequest 类型的参数的解析需要使用到 ServletRequestMethodArgumentResolver 参数解析器。构造时无需传入任何参数。</p><p>ServletRequestMethodArgumentResolver 参数解析器不仅可以解析 HttpServletRequest 类型的参数，还支持许多其他类型的参数，其支持的参数类型可在 supportsParameter() 方法中看到：</p><h4 id="ModelAttribute">@ModelAttribute</h4><p>@ModelAttribute 注解的解析需要使用到 ServletModelAttributeMethodProcessor 参数解析器。构造时需要传入一个布尔类型的值。为 false 时，表示 @ModelAttribute 不是不必须的，即是必须的。</p><p>针对 @ModelAttribute(“abc”) User user1 和 User user2 两种参数来说，尽管后者没有使用 @ModelAttribute 注解，但它们使用的是同一种解析器。</p><p>添加两个 ServletModelAttributeMethodProcessor 参数解析器，先解析带 @ModelAttribute 注解的参数，再解析不带 @ModelAttribute 注解的参数。</p><p>通过 ServletModelAttributeMethodProcessor 解析得到的数据还会被存入 ModelAndViewContainer 中。存储的数据结构是一个 Map，其 key 为 @ModelAttribute 注解指定的 value 值，在未显式指定的情况下，默认为对象类型的首字母小写对应的字符串。</p><p>@RequestBody User user3 参数也被 ServletModelAttributeMethodProcessor 解析了，如果想使其数据通过 JSON 数据转换而来，则需要使用另一个参数解析器。</p><h4 id="RequestBody">@RequestBody</h4><p>@RequestBody 注解的解析需要使用到 RequestResponseBodyMethodProcessor 参数解析器。构造时需要传入一个消息转换器列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先添加解析 <span class="meta">@ModelAttribute</span> 注解的解析器，再添加解析 <span class="meta">@RequestBody</span> 注解的解析器，最后添加解析省略了 <span class="meta">@ModelAttribute</span> 注解的解析器。如果更换最后两个解析器的顺序，那么 <span class="meta">@RequestBody</span> User user3 将会被 ServletModelAttributeMethodProcessor 解析，而不是 RequestResponseBodyMethodProcessor。</span><br></pre></td></tr></table></figure><h3 id="获取参数名">获取参数名</h3><h4 id="DefaultParameterNameDiscoverer">DefaultParameterNameDiscoverer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultParameterNameDiscoverer</span> <span class="keyword">extends</span> <span class="title class_">PrioritizedParameterNameDiscoverer</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DefaultParameterNameDiscoverer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (KotlinDetector.isKotlinReflectPresent() &amp;&amp; !NativeDetector.inNativeImage()) &#123;</span><br><span class="line">         addDiscoverer(<span class="keyword">new</span> <span class="title class_">KotlinReflectionParameterNameDiscoverer</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      addDiscoverer(<span class="keyword">new</span> <span class="title class_">StandardReflectionParameterNameDiscoverer</span>());</span><br><span class="line">      addDiscoverer(<span class="keyword">new</span> <span class="title class_">LocalVariableTableParameterNameDiscoverer</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要获取参数名称的原因：（java编译的时候，如果不加-par-parameters 即不是【javac -parameters .\Bean2.java】编译的，则不会保留参数名称）</strong></p><p>在项目的 src 目录外创建一个 Bean2.java 文件，使其不会被 IDEA 自动编译</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.mofan.a22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将命令行切换到 Bean2.java 文件所在目录的位置，执行 javac .\Bean2.java 命令手动编译 Bean2.java。查看 Bean2.class 文件的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.mofan.a22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String var1, <span class="type">int</span> var2)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译生成的 class 文件中的 foo() 方法的参数名称不再是 name 和 age，也就是说直接使用 javac 命令进行编译得到的字节码文件不会保存方法的参数名称。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVAWebing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVAWeb </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书-Effective Java系列（五）</title>
      <link href="/posts/5b5ad457.html"/>
      <url>/posts/5b5ad457.html</url>
      
        <content type="html"><![CDATA[<h1>五</h1>]]></content>
      
      
      <categories>
          
          <category> 读书inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书inG </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书-Effective Java系列（三、四）</title>
      <link href="/posts/61549102.html"/>
      <url>/posts/61549102.html</url>
      
        <content type="html"><![CDATA[<h1>三、四</h1><h2 id="10-覆盖quals时请遵守通用规定">10. 覆盖quals时请遵守通用规定</h2><blockquote><p>尽管Object是一个具体类，但设计它主要是为了扩展。它所有的非final方法（equals、hashCode、toString、clone和finalize）都有明确的通用约定（general contract），因为它们设计成是要被覆盖（override）的。任何任何一个类，它在覆盖这些方法的时候，都有责任遵守这些通用约定；如果不能做到这一点，其他依赖于这些约定的类（例如HashMap和HashSet）就无法结合该类一起正常运作。</p><p>本章将讲述何时以及如何覆盖这些非final的Object方法。本章不再讨论finalize方法，因为第8条已经讨论过这个方法了。而Comparable.compareTo虽然不是Object方法，但是本章也将对其进行讨论，因为它具有类似的特点。</p></blockquote><p>覆盖 equals 方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重。最容易避免这类问题的办法就是不覆盖 equals 方法，在这种情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，就可以不覆盖 equals 方法：</p><ul><li>类的每个实例本质上都是唯一的。对于代表活动实体而不是值（value）的类来说确实如此，例如 Thread。Object 提供的 equals 实现对于这些类来说正是正确的行为。</li><li>类没有必要提供“逻辑相等”的测试功能。例如，java.util.regex.Pattern 可以覆盖 equals，以检查两个 Pattern 实例是否代表同一个正则表达式，但是设计者并不认为客户需要或者期望这样的功能。在这类情况之下，从 Object 继承得到的 equals 实现已经足够了。</li></ul><p>超类已经覆盖了 equals，超类的行为对于这个类也是合适的。例如，大多数的 Set 实现从 AbstractSet 继承 equals 实现，List 实现从 AbstractList 继承 equals 实现，Map 实现从 AbstractMap 继承 equals 实现。</p><p>类是私有的，或者是包级私有的，可以确定它的 equals 方法永远不会被调用。如果你非常想规避风险，可以覆盖 equals 方法，确保它不会被意外调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(); <span class="comment">// Method is never called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>那么什么时候应该覆盖 equals 方法呢？</strong></p><p>如果类具有自己特有的“逻辑相等”概念（不同于对象等同的概念），而且超类还没有覆盖 equals。这通常属于“值类”(value class)的情形。值类仅仅是一个表示值的类，例如 Integer 或者 String。程序员在利用 equals 方法来比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是了解它们是否指向同一个对象。为了满足程序员的要求，不仅必须覆盖 equals 方法，而且这样做也使得这个类的实例可以用作映射表(map)的键(key)，或者集合(set)的元素，使映射或者集合表现出预期的行为。</p><p><strong>在覆盖 equals 方法的时候，必须要遵守它的通用约定。下面是约定的内容，来自 Object 的规范。</strong></p><p>equals 方法实现了等价关系，其属性如下：</p><ul><li>自反性(reflexive)：对于任何非 null 的引用值 x，x.equals(x) 必须返回 true。</li><li>对称性(symmetric)：对于任何非 null 的引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 必须返回 true。</li><li>传递性(transitive)：对于任何非 null 的引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 也返回 true，那么 x.equals(z) 也必须返回 true。</li><li>一致性(consistent)：对于任何非 null 的引用值 x 和 y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 x.equals(y) 就会一致地返回 true，或者一致地返回 false。</li><li>对于任何非 null 的引用值 x，x.equals(null) 必须返回 false。</li></ul><p><strong>实现高质量 equals 方法的诀窍：</strong></p><ol><li>使用 == 操作符检查“参数是否为这个对象的引用”。 如果是，则返回 true。 这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</li><li>使用 instanceof 操作符检查“参数是否为正确的类型”。 如果不是，则返回 false 一般说来，所谓“正确的类型”是指equals 方法所在的那个类。 某些情况下，是指该类所实现的某个接口。 如果类实现的接口改进了 equals 约定，允许在实现了该接口的类之间进行比较，那么就使用接口。 集合接口如Set、List、Map和Map.E口try具有这样的特性。</li><li>把参数转换成正确的类型。 因为转换之前进行过且stanceof测试，所以确保会成功。</li><li>对于该类中的每个“关键”（ significant ）域，检查参数中的域是否与该对象中对应的域相匹配。 如果这些测试全部成功，则返回 true；否则返回 false。 如果第2步中的类型是个接口，就必须通过接口方法访问参数中的域；如果该类型是个类，也许就能够直接访问参数中的域，这要取决于它们的可访问性。</li><li>在编写完 equals 方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？ 并且不要只是自问，还要编写单元测试来检验这些特性</li></ol><p><strong>下面是最后的一些告诫：</strong></p><ul><li><p>覆盖equals 时总要覆盖hashCode</p></li><li><p>不要企图让equals 方法过于智能。 如果只是简单地测试域中的值是否相等，则不难做到遵守 equals 约定。 如果想过度地去寻求各种等价关系，则很容易陷入麻烦之中。把任何一种别名形式考虑到等价的范围内，往往不会是个好主意。 例如，File类不应该试图把指向同一个文件的符号链接（symbolic link）当作相等的对象来看待。 所幸File 类没有这样做</p></li><li><p>不要将equals 声明中的 Object 对象替换为其他的类型。 比如：</p><blockquote><p>// Broken - parameter type must be Object!<br>public boolean equals(MyClass o) {<br>…<br>}</p><p>问题在于，这个方法并没有覆盖 Object. equals，因为它的参数应该 是Object 类型，相反，它重载了 Object.equals。 在正常 equals 方法的基础上，再提供一个“强类型”的 equals 方法。</p><p>增加@Override注解可以在编译前发现问题</p><p>// Still broken, but won’t compile<br>@Override<br>public boolean equals(MyClass o) {<br>…<br>}</p></blockquote></li><li><p>编写和测试 equals（及hashCode）方法都是十分繁琐的，得到的代码也很琐碎。 代替手工编写和测试这些方法的最佳途径，是使用Google开源的<code>AutoValue框架</code>，它会自动替你生成这些方法，通过类中的单个注解就能触发。 在大多数情况下，AutoValue生成的方法本质上与你亲自编写的方法是一样的。</p></li></ul><p><strong>总之，除非必须，否则不要覆盖 equals 方法：在许多情况下，从 Object 继承而来的实现正是你想要的。如果你确实覆盖了 equals，那么一定要比较类的所有重要字段，并以保留 equals 约定的所有 5 项规定的方式进行比较。</strong></p><h2 id="11-覆盖equals时总要覆盖hashCode">11. 覆盖equals时总要覆盖hashCode</h2><p><strong>在每一个覆盖了equals方法的类中，总要覆盖hashCode方法</strong>。如果不这样做的话，就会违反hashCode的通用约定，</p><blockquote><p>Object规范：</p><ul><li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，hashCode方法都必须始终返回同一个值。在一个应用程序与另一个程序的执行过程中，执行hashCode方法所返回的值可以不一致。</li><li>如果两个对象根据equals(Object）方法比较是相等的，那么调用这两个对象中的hashCode方法都必须产生同样的整数结果。</li><li>如果两个对象根据equals(Object）方法比较是不相等的，那么调用这两个对象中的hashCode方法，则不一定要求hashCode方法必须产生不同的结果。 但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表（hashtable）的性能。</li></ul></blockquote><p>因没有覆盖hashCode 而违反的关键约定是第二条：相等的对象必须具有相等的散到码（ hashcode ）。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;PhoneNumber, String&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">m.put(<span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="number">707</span>, <span class="number">867</span>, <span class="number">5309</span>), <span class="string">&quot;Jenny&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时，你可能期望 <code>m.get(new PhoneNumber(707, 867,5309))</code> 返回「Jenny」，但是它返回 null。</p><blockquote><p>注意，这里涉及两个PhoneNumber实例：第一个被插入HashMap中，第二个实例与第一个相等，用于从Map中根据PhoneNumber去获取用户名字。</p><p>**由于PhoneNumber类没有覆盖hashCode方法，从而导致两个相等的实例具有不相等的散列码，违反了hashCode的约定。**因此，put方法把电话号码对象存放在一个散列桶（hash bucket）中，get方法却在另一个散列桶中查找这个电话号码。即使这两个实例正好被放到同一个散列桶中，get方法也必定会返回null，因为HashMap有一项优化，可以将与每个项相关的散列码缓存起来，如果散列码不匹配，也就不再去检验对象的等同性。</p></blockquote><p>修正这个问题十分简单，只需要给PhoneNumber类提供一个适当的hashCode方法即可。</p><p><strong>不要试图从散列码计算中排除掉一个对象的关键域来提高性能。</strong> 虽然这样得到的散列函数运行起来可能更快，但是它的效果不见得会好，可能会导致散列表慢到根本无法使用。特别是在实践中，散列函数可能面临大量的实例，在你选择忽略的区域之中，这些实例仍然区别非常大。 如果是这样，散列函数就会把所有这些实例映射到极少数的散列码上，原本应 该以线性级时间运行的程序，将会以平方级的时间运行。</p><p>**不要对hashCode方法的返回值做出具体的规定，因此客户端无法理所当然地依赖它；**这样可以为修改提供灵活性。 Java类库中的许多类，比如 String 和 Integer，都可以把 它们的 hashCode 方法返回的确切值规定为该实例值的一个函数。一般来说，这并不是个好主意，因为这样做严格地限制了在未来的版本中改进散列函数的能力。 如果没有规定散列函数的细节，那么当你发现了它的内部缺陷时，或者发现了更好的散列函数时，就可以在后面的发行版本中修正它。</p><h2 id="12-始终要覆盖toString">12. 始终要覆盖toString</h2><p>虽然Object提供了 toString 方法的一个实现，但它返回的字符串通常并不是类的用户所期望看到的。它包含类的名称，以及一个“＠”符号，接着是散列码的无符号十六进制表示法，例如PhoneNumber@163b91。 toString的通用约定指出，被返回的字符串应该是一个“简洁的但信息丰富，并且易于阅读的表达形式”。</p><ul><li>遵守toString约定并不像遵守 equals 和 hashCode 的约定那么重要，但是，提供好的toString实现可以便类用起来更加舒适，使用了这个类的系统也更易于调试。</li><li>在实际应用中， toString 方法应该返回对象中包含的所有值得关注的信息。</li><li>无论是否指定返回值（字符串）格式，都应该在文档注释中明确地表明你的意图。</li><li>无论是否指定返回值（字符串）格式，都为toString返回值中包含的所有信息提供一种可以通过编程访问到的途径。 即提供方法获取toString中的某一部分数据，而不需要去解析toString。</li></ul><h2 id="13-谨慎地覆盖clone">13. 谨慎地覆盖clone</h2><p>Cloneable接口的目的是作为对象的UI个mixin接口，表明这样的对象允许克隆。但是这个接口没有定义clone方法，并且Object的clone方法是受保护的。所以，<strong>如果不借助反射，就不能仅仅因为一个对象实现了Cloneable接口，就调用clone方法。</strong></p><blockquote><p>Cloneable接口并没有包含任何方法，那么这个接口有什么作用呢？</p><p>这个接口是一个标记接口（空接口），<strong>他决定了Object中受保护的clone方法实现的行为。<strong>如果一个类实现了Cloneable接口，Object的clone方法就返回该对象的</strong>浅拷贝</strong>；如果没有实现Cloneable接口就会抛出CloneNotSupportedException异常。</p><p>【Object的clone方法被 protected 和 native 修饰 （见相关博客）】</p></blockquote><p>事实上，实现Cloneable接口的类都是为了提供一个功能适当的公有的clone方法。</p><hr><p>注意事项：</p><ul><li><p>**不可变的类永远都不应该提供clone方法。**它只会激发不必要的克隆。</p></li><li><p>clone默认是浅拷贝，如果对象的域引用了可变的对象（数组），需要重写clone方法深拷贝。</p></li><li><p>**Cloneable架构与引用可变对象的final域的正常用法是不兼容的。**clone方法被禁止给final域对象赋新值。</p></li><li><p>**公有的clone方法应该省略throws声明。**因为不会抛出受检异常的方法使用起来更加轻松。</p></li><li><p><strong>对象拷贝的更好的办法是提供一个拷贝构造器或者拷贝工厂</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy constructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Yum</span><span class="params">(Yum yum)</span> &#123; ... &#125;;</span><br><span class="line"><span class="comment">// Copy factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Yum <span class="title function_">newInstance</span><span class="params">(Yum yum)</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用clone方法克隆复杂对象的一种方法：首先，调用super.clone方法（归根结底是Object的clone方法，浅拷贝）；然后把对象中的所有域（属性）设置成初始状态，然后调用子类的方法给域（属性）重新赋值。</p></li></ul><p>相关博客：<a href="https://blog.csdn.net/m0_68402491/article/details/130675660">java实现简单的克隆-CSDN博客</a></p><h2 id="14-考虑实现Comparable接口">14. 考虑实现Comparable接口</h2><p>实现Comparable接口主要是重写compareTo方法。该方法的目的不但允许进行简单的等同性比较，而且允许执行顺序比较。</p><ol><li>如果一个对象没有实现Comparable接口，或者需要使用一个非标准的排序关系，就可以使用一个显示的Comparator来代替，或者编写自己的比较器，或者使用已有的比较器。</li><li>在compareTo方法中使用关系操作符&lt;、&gt;（大于号、小于号）是非常繁琐的，并且容易出错，所以不建议使用。应该在装箱基本类型的类中使用静态的compare方法，或者Comparator接口中使用比较器构造方法。</li></ol><h2 id="15-使类和成员的可访问性最小化">15. 使类和成员的可访问性最小化</h2><p>区分一个组件设计的好不好，唯一重要的因素是：它对于外部的其他组件而言，是否隐藏了其内部数据和其他细节实现。好的组件会隐藏所有的实现细节，把API与实现清晰地隔离出来，组件之间只通过API进行通信，一个模块不需要知道其他模块的内部工作情况。这种设计也被称为信息隐藏或封装。</p><p>Java提供了许多机制来协助信息隐藏。<strong>访问控制</strong>机制通过访问修饰符决定类、接口和成员的可访问性。</p><p><strong>规则：</strong></p><ol><li><p>尽可能地使每个类或者成员不被外界访问</p><ul><li><p>类和接口：只有两种访问级别，包级私有（无修饰）和公有（public修饰）。<strong>如果能把类/接口做成包级私有，就需要定义为包级私有。</strong></p><blockquote><p>如果一个包级私有的顶层类/接口<strong>只在</strong>某一个类的内部被用到，就应该考虑使它成为唯一使用的类的私有嵌套类</p></blockquote></li><li><p>成员（域、方法、嵌套类、嵌套接口）：私有（private）、包级私有（无修饰）、受保护的（protected修饰）、公有（public修饰）</p></li></ul></li><li><p>公有类的实例域决不能是公有的。如果公有类的实例域一旦公有，你就等于放弃了对存储在这个域中的值进行限制的能力；<strong>并且包含公有可变域的类通常并不是线程安全的。</strong></p><blockquote><p>让类具有公有的静态final数据域，或者返回这种域的访问方法，是错误的。</p></blockquote></li></ol><h2 id="16-要在公有类而非公有域中使用访问方法">16. 要在公有类而非公有域中使用访问方法</h2><p>对于公有类，他的域尽可能的私有。所以，如果需要访问域时，需要共有类提供访问方法，比如getXXX()。</p><p>不过，如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误。</p><h2 id="17-使可变性最小化">17. 使可变性最小化</h2><p>不可变类是指其实例不能被修改的类，每个实例中包含的所有信息都必须在创建该实例的时候就提供，并且在对象的整个生命周期内固定不变。</p><p><strong>如果要使类成为不可变类，必须要遵循的规则：</strong></p><ol><li>不要提供任何会修改对象状态的方法</li><li>保证类不会被拓展（一般是用final声明）</li><li>声明所有域都是final的</li><li>声明所有域都是私有的</li><li>确保对任何可变组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。</li></ol><p><strong>不可变类的优点：</strong></p><ol><li>不可变类比较简单，只有一种状态，即被创建时的状态。</li><li>不可变对象本质是线程安全的，他们不要求同步。</li><li>不可变对象可以被自由的共享，甚至可以共享类的内部信息。</li><li>不可变对象为其他对象提供了大量的构件。</li><li>不可变对象无偿的提供了失败的原子性，不存在临时不一致的可能性。</li></ol><p>**不可变类的缺点：**真正唯一的缺点是对于每个不同的值，都需要一个单独的对象。</p><p><strong>类创建原则：</strong></p><ol><li>除非有很好的理由要让类成为可变的类，否则他就应该是不可变的。</li><li>如果类不能被做成不可变的，仍然应该尽可能地限制他的可变性。</li><li>除非有令人信服的理由要使域变成是非final的，否则每个域都应该是private final的。</li><li>构造器应该创建完全初始化的对象，并建立起所有的约束关系。</li></ol><h2 id="18-复合优先于继承">18. 复合优先于继承</h2><p><code>本小节的继承指：一个类拓展另一个类的时候。（不考虑一个类实现一个接口或者一个接口扩展另一个接口的时候）</code></p><p>继承是实现代码重用的有利手段，但并非永远是最佳工具。</p><p>**因为和方法调用不同，继承打破了封装性。**子类依赖于其超类中特定功能的实现细节。超类的实现有可能会随着发行版本的不同而有所变化，如果真的发生了变化，子类可能会遭到破坏，即使它的代码完全没有改变。 因而，子类必须要跟着其 超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文挡说明。</p><blockquote><p>只有当子类真正是超类的子类型时，才适合用继承。</p></blockquote><p>**复合：**不扩展现有类，而是在新的类中增加一个私有域，引用现有类的一个实例。新类中的每个实例方法都可以调用被包含的先有类中对应的方法，并返回它的结果。这被称为转发，新类中的方法被称为转发方法。</p><h2 id="19-要么设计继承并提供文档说明，要么禁止继承">19. 要么设计继承并提供文档说明，要么禁止继承</h2><p>对于专门为了继承而设计并且具有良好文档说明的类而言：</p><ol><li>该类必须有文档说明它可覆盖的方法的自用型</li></ol><blockquote><p>好的API文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。</p></blockquote><ol start="2"><li>类必须以精心挑选的受保护的方法的形式，提供适当的钩子（hook），以便进入其内部工作中。</li></ol><blockquote><p>钩子（hook）：允许程序员在程序运行的不同阶段插入额外的代码，以实现对程序行为的控制和定制化。JAVA中的hook通常通过回调函数或者监听器的方式实现。当程序到达某个特定的状态或者事件发生时，钩子会触发相应的回调函数或者事件处理方法，从而执行额外的逻辑。</p></blockquote><ol start="2"><li>对于为了继承而设计的类，唯一的测试方式就是编写子类。换句话说，必须在发布类之前先编写子类对类进行测试。</li><li><strong>构造器决不能调用可被覆盖的方法。</strong></li><li>如果类实现了Cloneable或者Serializable接口，无论是clone还是readObject方法，都不可以调用可覆盖的方法，不管是以直接还是间接的方式。</li><li>对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化。</li></ol><h2 id="20-接口优于抽象类">20. 接口优于抽象类</h2><p>Java提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。并且Java 8以后，接口引入了缺省方法。这两种机制都允许为某些实例方法提供实现。</p><ol><li><p>现有的类可以很容易被更新，以实现新的接口</p></li><li><p>接口是定义mixin（混合类型）的理想选择</p><blockquote><p>混合类型：类除了实现它的“基本类型”以外，还可以实现mixin类型，以表明它提供了某些可选择的行为。</p></blockquote></li><li><p>接口允许构造非层次结构的类型框架</p></li><li><p>接口使得安全地增强类的功能成为可能（包装类模式）</p></li><li><p><strong>通过对接口提供一个抽象的骨架实现类（即抽象类实现接口，使用类继承抽象类）</strong>，可以把接口和抽象类的优点结合起来。接口负责定义类型，也可以提供一些缺省方法，抽象类则负责实现除基本类型接口方法以外的方法。（模板方法模式）</p></li><li><p>对于骨架实现类而言，好的文档绝对是非常必要的</p></li></ol><h2 id="21-为后代设计接口">21. 为后代设计接口</h2><p>在Java 8发行之前，如果不破坏现有的实现，是不可能给接口添加方法的。如果给某个接口添加了一个新的方法，就会导致编译错误。Java 8以后，增加了缺省方法构造，目的就是允许给现有的接口添加方法。</p><p>注意：</p><ol><li>并非每一个可能实现的所有变体，始终都可以编写出一个缺省方法</li><li>有了缺省方法，接口的现有实现就不会出现编译时没有报错或警告，运行时却失败的情况。</li><li>谨慎设计接口仍然是至关重要的</li></ol><h2 id="22-接口只用于定义类型">22. 接口只用于定义类型</h2><p>当类实现接口时，接口就充当可以引用这个类的实例的类型。因此，类实现了接口，就表明客户端可以对这个类的实例实施某些动作。</p><p>注意：</p><ol><li><p>常量接口模式是对接口的不良使用</p><blockquote><p>有一种接口被称为常量接口（constant interface），它不满足上面的条件。这种接口不包含任何方法，它只包含静态的final域，每个域都导出一个常量。使用这些常量的类实现这个接口，以避免用类名来修饰常量名。</p></blockquote></li><li><p>如果要导出常量类，可以把这些常量添加到这个类或者接口中，比如Integer的MAX_VALUE；如果这些常量最好被看做枚举类型的成员，就应该用枚举类型；如果不行，应该使用不可实例化的工具类来导出这些常量；如果大量利用工具类导出的常量，可以通过利用<strong>静态导入</strong>机制，避免使用类名修饰常量名。</p></li></ol><h2 id="23-类层次优于标签类">23. 类层次优于标签类</h2><p>标签类过于冗长、容易出错，并且效率低下。</p><p>标签类属于类层次的一种</p><h2 id="24-静态成员类优于非静态成员类">24. 静态成员类优于非静态成员类</h2><p>嵌套类（nested class）是指指定在另一个类的内部的类。嵌套类存在的目的应该只是为了它的外围（enclosing class）提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该顶层类（top-level class）。嵌套类有四种：静态成员类（static member class）、非静态成员类（nonstatic member class）、匿名名（anonymous class）和局部类（local class）。除了第一种之外，其他三种都称为内部类（inner class）。</p><p>静态成员类是最简单的一种嵌套类。最好把它看作是普通类，只是碰巧被声明在另一个类的内部而已，它可以访问外围的所有成员，包括那些声明为私有的成员。静态成员类是外围的一个静态成员，与其他的静态成员一样，也遵守同样的可访问性规则。如果它被声明为私有的，它就只能在外围类的内部才能被访问，等等。静态成员类的一种常见用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。</p><p>非静态成员类的一种常见用法是定义一个Adapter，它允许外部类的实例被看作是另一个不相关的类的实例。 如果声明成员类不要求访问外围实例，就要始终把修饰符 static 放在它的声明中， 使它应当把嵌套类声明成静态成员类，而不是非静态成员类。如果省略了 static 修饰符，则每个实例都将包含一个额外的指向外围对象的引用。如前所述，保存这份引用要消耗时间和空间，并且会导致外围实例在符合垃圾回收时仍然得以保留。由此造成的内存泄漏可能是灾难性的。但是常常难以发现，因为这个引用是不可见的。</p><p>如果相关的类是导出类的公有或受保护的成员，毫无疑问，在静态和非静态成员类之间做出正确的选择是非常重要的。在这种情况下，该成员类就是导出的 API 元素，在后续的发行版本中，如果不违背向后兼容性，就无法从非静态成员类变为静态成员类。</p><p>匿名类是没有名字的。它不是外围类的一个成员。它并非与其他的成员一起被声明，而是在使用的同时被声明和实例化。匿名类可以出现在代码中任何允许存在表达式的地方。当且仅当匿名类出现在非静态的环境中时，它才拥有外围实例。但是即使它们出现在静态的环境中，也不可能拥有任何静态成员，而是拥有常数变量（constant variable），常数变量是 final 基本类型，或者是被初始化为常量表达式[JLS, 4.12.4]的字符串字面量。</p><p>匿名类的运用受到诸多的限制。除了在它们被声明的时候之外，是无法将它们实例化的。不能执行 instanceof 测试，或者做任何需要命名类的其他事情。无法声明一个匿名类来实现多个接口，或者扩展一个类，并同时扩展类和实现接口。除了从超类型继承得到之外，匿名类的客户端无法调用任何成员。由于匿名类出现在表达式中，它们必须保持简短（大约 10 行或者更少），否则会影响程序的可读性。</p><p>局部类是四种嵌套类中使用最少的类。在任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。局部类与其他三种嵌套类中的每一种都有一些共同的属性。与成员类一样，局部类有名字，可以被重复使用。与匿名类一样，只有当局部类是在非静态态环境中定义的时候，才有外围实例，它们也不能包含静态成员。与匿名类一样，它们必须非常简短以便不会影响可读性。</p><p>总而言之，共有四种不同的嵌套类，每一种都有自己的用途。如果一个嵌套类需要在单个方法之外仍然是可见的，或者它太长了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向其外围实例的引用，就把成员类做成非静态的；否则，就做成静态的。假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预设的类型可以说明这个类的特征，就把它做成匿名类；否则，就做成分部类。</p><h2 id="25-限制源文件为单个顶级类">25. 限制源文件为单个顶级类</h2><p>永远不要把多个顶级类或者接口放在一个源文件中。遵循这个规则可以确保编译时一个类不会有多重定义。这么做反过来也能确保编译产生的类文件，以及程序的结果的行为，都不会受到源文件被传送给编译器时的顺序的影响。</p>]]></content>
      
      
      <categories>
          
          <category> 读书inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书inG </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书-Effective Java系列（二）</title>
      <link href="/posts/fee147ff.html"/>
      <url>/posts/fee147ff.html</url>
      
        <content type="html"><![CDATA[<h1>一</h1><h2 id="1-以静态工厂方法代替构造函数">1. 以静态工厂方法代替构造函数</h2><p>客户端获取类实例的方法：</p><ol><li>构造器</li><li>静态工厂方法</li></ol><p>推荐使用静态工厂方法，而不是构造器方法。</p><p>静态工厂优点：</p><ol><li><p>静态工厂方法有确切的名称，构造器只能是类名</p></li><li><p>静态工厂方法可以通过不需要在每次调用时创建新的对象。类似于享元模式</p></li><li><p>静态工厂方法可以获取返回类型的子类对象</p></li><li><p>静态工厂方法返回对象的类可以随调用的不同而变化，作为输入参数的函数</p><blockquote><p>比如：</p><p>构造方法：Map&lt;String, List&lt;String&gt;&gt; m = new HasMap&lt;String, List&lt;String&gt;&gt;();</p><p>静态工厂方法：</p><p>public static &lt;K, V&gt; HashMap&lt;K, V&gt; newInstance() {</p><p>​return new HashMap&lt;K, V&gt;();</p><p>}</p></blockquote></li></ol><p>静态工厂缺点：</p><ol><li><p>没有公共或受保护构造函数的类不能被子类化</p></li><li><p>和其他静态方法实际上没有任何区别</p><blockquote><p>为了加以区别，静态工厂使用一些惯用名称</p><ul><li>valueOf：该方法返回的实例和参数的数值相同。实际上是一种类型转换方法</li><li>of：valueOf的简洁替代</li><li>getInstance：返回的实例通过参数来描述。对于单例模式，该方法没有参数并返回唯一实例</li><li>newInstance：多例模式，每次返回新值</li><li>getType：和getInstance类似，但是在工厂方法处于不同的类中使用</li><li>newType：和newInstance类似，但是在工厂方法处于不同的类中使用</li></ul></blockquote></li></ol><h2 id="2-遇到多个构造器参数时考虑用构建器">2. 遇到多个构造器参数时考虑用构建器</h2><p>静态工厂和构造器有一个共同的缺陷，他们都不能很好的扩展到大量的可选参数。如果一个类新建有大量的可选参数，通常采用<strong>重叠构造器模式</strong>，多个构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Telescoping constructor pattern - does not scale well!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize; <span class="comment">// (mL) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings; <span class="comment">// (per container) required</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories; <span class="comment">// (per serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat; <span class="comment">// (g/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium; <span class="comment">// (mg/serving) optional</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate; <span class="comment">// (g/serving) optional</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings, <span class="type">int</span> calories, <span class="type">int</span> fat, <span class="type">int</span> sodium, <span class="type">int</span> carbohydrate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">        <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        <span class="built_in">this</span>.calories = calories;</span><br><span class="line">        <span class="built_in">this</span>.fat = fat;</span><br><span class="line">        <span class="built_in">this</span>.sodium = sodium;</span><br><span class="line">        <span class="built_in">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建实例的时候，就需要利于利用参数列表最短的构造器，但是这个列表包含了要设置的所有参数。</p><blockquote><p>重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难编写，并且仍然难以阅读。如果客户端颠倒参数的位置，有可能编译器也不会报错，但是程序运行时错误。</p></blockquote><p>替代方法二：<strong>JavaBeans模式</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBeans Pattern - allows inconsistency, mandates mutability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="comment">// Parameters initialized to default values (if any)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servingSize</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">servings</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// Required; no default value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NutritionFacts</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// Setters</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServingSize</span><span class="params">(<span class="type">int</span> val)</span> &#123; servingSize = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServings</span><span class="params">(<span class="type">int</span> val)</span> &#123; servings = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCalories</span><span class="params">(<span class="type">int</span> val)</span> &#123; calories = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFat</span><span class="params">(<span class="type">int</span> val)</span> &#123; fat = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSodium</span><span class="params">(<span class="type">int</span> val)</span> &#123; sodium = val; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCarbohydrate</span><span class="params">(<span class="type">int</span> val)</span> &#123; carbohydrate = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用一个无参构造器创建对象，然后调用setter方法设置每个必要的参数。</p><blockquote><p>JavaBeans模式自身有很严重的缺点</p><ol><li>因为构造过程被分到了几个调用中，<strong>在构造的过程中JavaBeans可能处于不一致的状态</strong>。</li><li>JavaBeans模式阻止了把类做成不可变的可能，需要额外的处理保证线程的安全。</li></ol></blockquote><p>最佳替代：构建器（Builder模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Builder Pattern</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NutritionFacts</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">// Required parameters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> servings;</span><br><span class="line">        <span class="comment">// Optional parameters - initialized to default values</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">calories</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fat</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sodium</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">carbohydrate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(<span class="type">int</span> servingSize, <span class="type">int</span> servings)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="built_in">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">calories</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">fat</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">sodium</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">carbohydrate</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            carbohydrate = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> NutritionFacts <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NutritionFacts</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">        sodium = builder.sodium;</span><br><span class="line">        carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------使用----------------------</span></span><br><span class="line"><span class="type">NutritionFacts</span> <span class="variable">cocaCola</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NutritionFacts</span>.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">.calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br></pre></td></tr></table></figure><p>不直接生成对象，而是让客户端利用所有必要的参数调动构造器（静态工厂），得到一个builder对象，然后在builder对象上调用类似setter的方法，最后调用无参的builder()方法生成不可变对象。builder类是它创建类的静态成员类。</p><blockquote><p>优点：builder模式十分灵活，可以利用单个builder创建多个对象，可以自动填充某些属性。</p><p>缺点：性能开销</p></blockquote><h2 id="3-用私有构造器或者枚举类型强化Singleton属性">3. 用私有构造器或者枚举类型强化Singleton属性</h2><p>Singleton单例是一个只实例化一次的类。</p><p>实现单例有两种常见的方法。两者都基于保持构造函数私有和导出公共静态成员以提供对唯一实例的访问。</p><ol><li>在第一种方法中，成员是一个 final 字段：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有构造函数只调用一次，用于初始化 public static final 修饰的 Elvis 类型字段 INSTANCE。不使用 public 或 protected 的构造函数保证了「独一无二」的空间：一旦初始化了 Elvis 类，就只会存在一个 Elvis 实例，不多也不少。客户端所做的任何事情都不能改变这一点，但有一点需要注意：拥有特殊权限的客户端可以借助 AccessibleObject.setAccessible 方法利用反射调用私有构造函数。如果需要防范这种攻击，请修改构造函数，使其在请求创建第二个实例时抛出异常。</p><p><strong>使用 <code>AccessibleObject.setAccessible</code> 方法调用私有构造函数示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = Elvis.class.getDeclaredConstructors();</span><br><span class="line">AccessibleObject.setAccessible(constructors, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">Arrays.stream(constructors).forEach(name -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.toString().contains(<span class="string">&quot;Elvis&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">Elvis</span> <span class="variable">instance</span> <span class="operator">=</span> (Elvis) name.newInstance();</span><br><span class="line">        instance.leaveTheBuilding();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>在实现单例的第二种方法中，公共成员是一种静态工厂方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Elvis</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Elvis</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Elvis</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有对 <code>getInstance()</code> 方法的调用都返回相同的对象引用，并且不会创建其他 Elvis 实例（与前面提到的警告相同）。</p><p>静态工厂方法的一个优点是，它可以在不更改 API 的情况下决定类是否是单例。工厂方法返回唯一的实例，但是可以对其进行修改，为调用它的每个线程返回一个单独的实例。第二个优点是，如果应用程序需要的话，可以编写泛型的单例工厂。使用静态工厂的最后一个优点是方法引用能够作为一个提供者，例如 <code>Elvis::getInstance</code> 是 <code>Supplier&lt;Elvis&gt;</code> 的提供者。除非能够与这些优点沾边，否则使用 public 字段的方式更可取。</p><p><strong>但是要使单例类使用这两种方法中的任何一种实现可序列化，仅仅在其声明中添加实现 serializable 是不够的</strong>。</p><p>​    要维护单例保证，应声明所有实例字段为 transient，并提供 readResolve 方法。否则，每次反序列化实例时，都会创建一个新实例，在我们的示例中，这会导致出现虚假的 Elvis。为了防止这种情况发生，将这个 readResolve 方法添加到 Elvis 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">    <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>从1.5开始，实现Singleton还可以编写一个包含单个元素的枚举类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Elvis</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveTheBuilding</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法类似于 public 字段方法，但是它更简洁，默认提供了序列化机制，提供了对多个实例化的严格保证，即使面对复杂的序列化或反射攻击也是如此。这种方法可能有点不自然，但是<strong>单元素枚举类型通常是实现单例的最佳方法。</strong></p><blockquote><p>注意：如果你的单例必须扩展一个超类而不是 Enum（尽管你可以声明一个 Enum 来实现接口），你就不能使用这种方法。</p><hr><p>拓展：<a href="https://www.yisu.com/ask/53336890.html">如何使用java枚举实现单例模式 - 问答 - 亿速云 (yisu.com)</a></p></blockquote><h2 id="4-通过私有构造器强化不可实例化的能力">4. 通过私有构造器强化不可实例化的能力</h2><p>对于某些类比如<code>java.lang.Math、java.util.Arrays</code>等工具类，不希望被实例化，因为实例化没有任何意义。然而如果在缺少显示构造器的情况下，编译器会自动补全一个公有、无参的缺省（default）构造器。</p><blockquote><p>同时，<strong>虽然将类声明成抽象类后就不能实例化，不能将不希望被实例化的类做成抽象类</strong>。因为该类可以被子类化，子类可以被实例化。这种做法会误导用户，以为这种类是专门为了继承而设计的。</p></blockquote><p>我们可以将类声明一个私有的构造器，他就不能被实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UtilityClass</span> &#123;</span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">UtilityClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125; ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为显式构造函数是私有的，所以在类之外是不可访问的。AssertionError 不是严格要求的，但是它提供了保障，以防构造函数意外地被调用。它保证类在任何情况下都不会被实例化。这个习惯用法有点违反常规，因为构造函数是明确提供的，但不能调用它。因此，最好在代码中增加注释。</p><blockquote><p>缺点：使一个类不能被子类化。</p><p>因为所有的构造器都必须显示或者隐式的调用超类（super）构造器，这种情况下，子类就没有可访问的超类构造器可调用。</p></blockquote><h2 id="5-优先考虑依赖注入来引入资源">5. 优先考虑依赖注入来引入资源</h2><p>有许多类会依赖一个或多个底层的资源。<strong>不要用Singleton和静态工具类来实现依赖一个或多个底层资源的类；也不要直接用这个类来创建这些资源。应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过他们来创建类。这种方式也叫作<code>依赖注入</code>。</strong></p><p>以拼写检查程序为例，拼写检查依赖字典。常见的做法是将该类作为静态实用工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Lexicon</span> <span class="variable">dictionary</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SpellChecker</span><span class="params">()</span> &#123;&#125; <span class="comment">// Noninstantiable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是其单例实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inappropriate use of singleton - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lexicon</span> <span class="variable">dictionary</span> <span class="operator">=</span> ...;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SpellChecker</span><span class="params">(...)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">static</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpellChecker</span>(...);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：他们都假设只使用了一个字典，但是在实际应用中，每种语言都有自己的字典，特殊的字典用于特殊的词汇表。</p><hr><p>可以尝试让SpellChecker 支持多个字典：</p><p>首先，取消 dictionary 字段的 final 修饰，并在现有的拼写检查器中添加更改 dictionary 的方法。但是在<code>并发环境</code>中这种做法是笨拙的、容易出错的和不可行的。<strong>静态实用工具类和单例不适用于由底层资源参数化的类。</strong></p><p>其次，需要的是能够支持类的多个实例（拼写检查器），每一个实例都是用客户端指定的资源（字典）。满足该需求最简单的模式就是，**当创建一个新的实例时，就将该资源传到构造器中。这种形式也是<code>依赖注入</code>的一种。**词典是拼写检查器的一个依赖，在创建拼写检查器的时候就将词典注入其中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dependency injection provides flexibility and testability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpellChecker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpellChecker</span><span class="params">(Lexicon dictionary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String word)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">suggestions</span><span class="params">(String typo)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>**依赖注入同样适用于构造器、静态工厂和构建器。**这种模式另一种变体就是将资源工厂传递给构造器，工厂是可以被重复调用来创建类型实例的一个对象。这类工厂具体表现为工厂方法。</p><blockquote><p>在Java 8中增加的接口<code>Supplier&lt;T&gt;</code>，最适合用于表示工厂。带有 <code>Supplier&lt;T&gt;</code> 的方法通常应该使用有界通配符类型来约束工厂的类型参数，以允许客户端传入创建指定类型的任何子类型的工厂。</p></blockquote><p>比如，下面一个生产马赛克的方法，利用客户端提供的工厂来生产每一篇马赛克。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mosaic <span class="title function_">create</span><span class="params">(Supplier&lt;? extends Tile&gt; tileFactory)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><hr><p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能会使大型项目变得混乱，这些项目通常包含数千个依赖项。通过使用依赖注入框架（如 Dagger、Guice 或 Spring），几乎可以消除这种混乱。这些框架的使用超出了本书的范围，<strong>但是请注意，设计成手动依赖注入的API，一般都适用于这些框架。</strong></p><h2 id="6-避免创建不必要的对象">6. 避免创建不必要的对象</h2><p><strong>一般来说，最好能重用对象而不是在每次需要的时候就创建一个功能相同的新对象。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;bikini&quot;</span>); <span class="comment">// DON&#x27;T DO THIS!‘</span></span><br><span class="line"><span class="built_in">String</span> s = <span class="string">&quot;bikini&quot;</span>;</span><br></pre></td></tr></table></figure><p>第一条语句每次执行时都会创建一个新的 String 实例，而这些对象创建都不是必需的。String 构造函数的参数 <code>(&quot;bikini&quot;)</code> 本身就是一个 String 实例，在功能上与构造函数创建的所有对象相同。如果这种用法发生在循环或频繁调用的方法中，创建大量 String 实例是不必要的。</p><p>第二条语句使用单个 String 实例，而不是每次执行时都创建一个新的实例。此外，可以保证在同一虚拟机中运行的其他代码都可以复用该对象，只要恰好包含相同的字符串字面量</p><hr><p><strong>对于同时提供静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象</strong></p><p>因为构造器每一次在被调用的时候都会创建一个新的对象，而静态工厂方法则从来不要求这样做。</p><hr><p><strong>有些对象创建的成本比其他对象要高得多，如果重复使用这类“昂贵的对象”，建议将它缓存下来重用。</strong></p><p>比如，使用一个正则表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span> + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题在于String#matches方法。这个方法每次调用都会在内部为正则表达式创建一个Pattern实例（需要将正则表达式编译成一个有限状态机），但是只使用了一次就回收，成本很高。</p><p>为了提升性能，需要显示地将正则表达式编译成一个Pattern实例，让它成为类初始化的一部分，并缓存起来、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RomanNumerals</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ROMAN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span> + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRomanNumeral</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">即 变量.matches(常量) 变为 常量.matcher(变量).matches()</span><br></pre></td></tr></table></figure><p>如果RomanNumerals类被初始化但是isRomanNumeral方法没有被使用过，则ROMAN对象理论上将不需要初始化。可以使用懒加载ROMAN对象。<code>但是，不建议懒加载ROMAN，会使方法实现更加复杂。</code></p><blockquote><p>类加载通常指的是类的生命周期中加载、连接、初始化三个阶段。当方法没有在类加载过程中被使用时，可以不初始化与之相关的字段</p></blockquote><p>当一个对象是不可变的，很明显，它可以安全地复用，但在其他情况下，它远不那么明显，甚至违反直觉。考虑适配器的情况，也称为视图。适配器是委托给支持对象的对象，提供了一个替代接口。因为适配器的状态不超过其支持对象的状态，所以<strong>不需要为给定对象创建一个给定适配器的多个实例。</strong></p><p>例如，Map 接口的 keySet 方法返回 Map 对象的 Set 视图，其中包含 Map 中的所有键。天真的是，对 keySet 的每次调用都必须创建一个新的 Set 实例，但是对给定 Map 对象上的 keySet 的每次调用都可能返回相同的 Set 实例。虽然返回的 Set 实例通常是可变的，但所有返回的对象在功能上都是相同的：当返回的对象之一发生更改时，所有其他对象也会发生更改，因为它们都由相同的 Map 实例支持。虽然创建 keySet 视图对象的多个实例基本上是无害的，但这是不必要的，也没有好处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keySet源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取HashMap的键的集合，以Set&lt;K&gt;保存</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回key的集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  说明：</span></span><br><span class="line"><span class="comment">1.可以看到其实该方法中，并没有将HashMap中的键添加到Set集合中，那么是如何实现的呢？</span></span><br><span class="line"><span class="comment">2.但实际上，我们访问Set集合，根本就无法通过索引，而是需要通过迭代器Iterator才能访问到元素，foreach本质上也是迭代器</span></span><br><span class="line"><span class="comment">3.这里的 ks 就仅仅只是一个Set引用，指向HashMap内部类KeySet的一个实例，重点在于该实例拥有自己的迭代器，当我们在使用增强for循环时才会调用该迭代器，也才会输出我们想要的东西</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="literal">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> <span class="title class_">KeySet</span>();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">来源：https:<span class="comment">//blog.csdn.net/cnds123321/article/details/113791846</span></span><br></pre></td></tr></table></figure><p>另一种创建不必要对象的方法是自动装箱，它允许程序员混合基本类型和包装类型，根据需要自动装箱和拆箱。<strong>自动装箱模糊了基本类型和包装类型之间的区别，</strong> 两者有细微的语义差别和不明显的性能差别。考虑下面的方法，它计算所有正整数的和。为了做到这一点，程序必须使用 long，因为 int 值不够大，不足以容纳所有正整数值的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>教训很清楚：<strong>基本类型优于包装类，还应提防意外的自动装箱。</strong></p><blockquote><p>本条目不应该被曲解为是在暗示创建对象是成本昂贵的，应该避免。相反，创建和回收这些小对象的构造函数成本是很低廉的，尤其是在现代 JVM 实现上。创建额外的对象来增强程序的清晰性、简单性或功能通常是件好事。</p><p>相反，通过维护自己的对象池来避免创建对象不是一个好主意，除非池中的对象非常重量级。证明对象池是合理的对象的典型例子是数据库连接。建立连接的成本非常高，因此复用这些对象是有意义的。然而，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，在轻量级对象上很容易胜过这样的对象池。</p></blockquote><p>当前项的描述是：「在应该复用现有对象时不要创建新对象」，而 Item 50 的描述则是：「在应该创建新对象时不要复用现有对象」。请注意，当需要进行防御性复制时，复用对象所受到的惩罚远远大于不必要地创建重复对象所受到的惩罚。在需要时不制作防御性副本可能导致潜在的 bug 和安全漏洞；而不必要地创建对象只会影响样式和性能。</p><h2 id="7-消除过期的对象引用">7. 消除过期的对象引用</h2><p>即使Java有内存管理机制，对于开发者来说仍需要考虑内存管理的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can you spot the &quot;memory leak&quot;?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">     * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码没有明显的错误。但是程序中隐藏着一个问题，可能会存在“内存泄露”。<code>如果一个栈先是增长（push），然后收缩（pop），被栈弹出的对象不会被当做垃圾回收。（因为这个弹出只是逻辑上的弹出，弹出的对象仍然在数组中）。</code>所以存在内存泄露的风险。这种引用也被称为过期引用</p><blockquote><p>过期引用：本文的过期引用指逻辑上应该被清空，但是物理上还存在的引用。</p></blockquote><p>这类问题的修复很简单，一旦对象引用过期，只需要手动清空这些引用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// Eliminate obsolete reference</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空过期引用有另一个好处：如果这些过期引用又被错误的使用，程序就会立刻抛出NullPointerException异常，而不是悄悄的错误运行下去。</p><p>但是<code>也没有必要过分小心：对于每一个对象引用，一旦程序不再使用，就把它清空</code>。因为这样会把代码弄得很乱，后期也不容易维护。**清空对象引用应该是一种例外，而不是一种规范的行为。**消除过期引用最好的方法就是让包含该引用的变量结束其生命周期。</p><p><strong>但为何上述Stack存在内存泄露的风险？</strong></p><p>简单地说，它管理自己的内存。存储池包含元素数组的元素（element, 对象引用单元，而不是对象本身）。数组的活动部分（size）中的元素被分配，而数组其余部分中的元素是空闲的。垃圾收集器没有办法知道这一点；对于垃圾收集器，元素数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。只要数组元素成为非活动部分的一部分，程序员就可以通过手动清空数组元素，有效地将这个事实传递给垃圾收集器。</p><p><strong>注意事项：</strong></p><p>所以，**只要类是自己管理内存，程序员就应该警惕内存泄露问题。**一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空。</p><p>同时，**也要注意缓存，因为内存泄露的另一个常见来源是缓存。**一旦将对象引用放入缓存中，就很容易忘记它就在那里，并且后续不在使用的时候仍在留在缓冲中一段时间。</p><blockquote><p>避免方式：</p><ol><li><p>可以在缓存中使用弱引用，保证缓存的自动清除。当缓存对象只有缓存的弱引用时，就会在下一个垃圾回收时回收。</p></li><li><p>增加一个后台线程（比如ScheduledThreadPoolExecutor），或者在缓存添加新条目的时候顺带清除掉没用的对象。</p></li></ol></blockquote><p>还有，**缓存泄露的第三个常见来源是监听器和其他回调。**比如，实现了一个API，客户端在这个API中注册了回调，但是没有显示的取消注册，那么除非采取某些动作，否则他们就会不断的堆积起来。</p><blockquote><p>避免方式：</p><p>确保回调立即被当做垃圾回收的最佳方式就是只保存它们的弱引用，比如只将它们保存成WeakHashMap中的键。</p></blockquote><p>最后，可以考虑借助Heap剖析工具（Heap profiler）发现内存泄露问题。</p><h2 id="8-避免使用终结方法和清除方法">8. 避免使用终结方法和清除方法</h2><blockquote><p>本小节内所表述的使用终结方法、清除方法是指像普通方法一样使用，不作为安全网时使用。</p></blockquote><p>终结方法通常是不可预测的，一般情况下不建议使用。及时在Java 9中用清除方法代替了终结方法，但是仍是不可预测、运行缓慢的。</p><p>类的终结方法、清除方法的缺点：</p><ol><li><p>不能保证会被及时执行。从一个对象变得不可到达开始，到他的终结方法被执行，所花费的这段时间是任意长的。<strong>注重时间的任务不应该由终结方法或者清除方法来完成</strong>。比如文件类型。</p><p>Java语言规范不仅不保证终结方法或者清除方法会被及时的执行，甚至根本就不保证他们会被执行。有一种可能：当程序终止的时候，某些对象的终结方法还没有被执行。<strong>永远不应该依赖终结方法或者清除方法来更新重要的持久状态。</strong></p><blockquote><p>即使Java底层有System.gc和System.runFinalization这两个方法，这也只是增加了终结方法和清除方法被执行的机会，并不能保证终结方法或者清除方法一定被执行。</p></blockquote></li><li><p>使用终结方法，无法捕获该方法中的异常，甚至连警告都不会打印出来。（清除方法没有这个问题：因为使用清除方法的一个类库在控制它的线程）。</p></li><li><p><strong>使用终结方法和清除方法会有非常严重的性能损失。</strong>（但是如果把终结方法、清除方法作为安全网，则效率不会性能很多）</p></li><li><p>**终结方法有一个严重的安全问题，为终结方法攻击提供了可能。**即如果对象在执行构造方法的时候抛出异常，终结方法也会运行，即使这个类的构造方法没有执行完。总之：从构造器抛出的异常，应该足以防止对象继续存在；但有了终结方法，这点就做不到了。</p></li></ol><p>如果类对象中封装了资源（比如文件或者线程），确实终止。<strong>只需让类实现AutoCloseable</strong>，并重写close方法，客户端在实例不需要的时候调用close方法即可。</p><blockquote><p>值得提及的一个细节是，该实例必须记录下自己是否已经被关闭了：close方法必须在一个私有域中记录下“该对象已经不再有效”。 如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域，并抛出 IllegalStateException 异常。</p></blockquote><p>类的终结方法、清除方法的优点：</p><ol><li>当资源的所有者忘记调用close方法时，终结方法或者清除方法可以充当“安全网”。虽然不能保证方法被及时的运行。</li><li>方便关闭对象的本地对等体。本地对等体就是<code>一个本地（非Java的）对象</code>，是普通对象（Java对等体）通过本地方法委托给一个本地对象。因为本地对象不会被Java的垃圾回收器回收，所以可以在Java对等体被回收的时候，使用终结方法、清除方法关闭本地对等体。</li></ol><hr><p>清除方法的使用有一定的技巧，下面以简单的Room类为例，假设房间在回收之前必须被清除。Room类实现了AutoCloseable，并利用清除方法自动清除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.Cleaner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An autocloseable class using a cleaner as a safety net</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Cleaner</span> <span class="variable">cleaner</span> <span class="operator">=</span> Cleaner.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resource that requires cleaning. Must not refer to Room!</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">State</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="type">int</span> numJunkPiles; <span class="comment">// Number of junk piles in this room</span></span><br><span class="line"></span><br><span class="line">        State(<span class="type">int</span> numJunkPiles) &#123;</span><br><span class="line">            <span class="built_in">this</span>.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoked by close method or cleaner</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Cleaning room&quot;</span>);</span><br><span class="line">            numJunkPiles = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The state of this room, shared with our cleanable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">    <span class="comment">// Our cleanable. Cleans the room when it’s eligible for gc</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">(<span class="type">int</span> numJunkPiles)</span> &#123;</span><br><span class="line">        state = <span class="keyword">new</span> <span class="title class_">State</span>(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(<span class="built_in">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内嵌的静态类State保存清除方法清除房间所需的资源；numJunkPiles域，表示房间的杂乱度。State实现了Runnable接口，他的run方法最多被Cleanable调用一次。有两种情况会触发run方法的调用：1. 调用Room的close方法，本质是调用cleanable.clean()。2. 如果Room实例应该被垃圾回收时，客户端没有调用close方法，清除方法就会调用State的run方法。</p><blockquote><p>State实例没有引用它的Room实例。 如果它引用了就会造成循环，阻止Room实例被垃圾回收（以及防止被自动清除）。因此State必须是一个静态的嵌套类，因为非静态的嵌套类包含了对其外围实例的引用。同样地，也不建议使用lambda, 因为它们很容易捕捉到对外围对象的引用。</p></blockquote><p>就像之前说的，Room类的清除器只是用作安全网。如果客户端将所有Room实例包围在带有资源的try块中，则永远不需要自动清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adult</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Room</span> <span class="variable">myRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="number">7</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Goodbye&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果是下面这种场景，则不会打印出&quot;Cleaning room&quot;。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teenager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Peace out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Cleaner规范：清除方法在System.exit期间的行为和实现有关，但是不确保清除方法是否会被调用。</p><blockquote><p>在sout之前，添加System.gc()，就可以让其在退出之前打印出Cleaning room。</p></blockquote><p><strong>总而言之，除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用清除方法，对于在Java 9之前的发行版本，则尽量不要使用终结方法。若使用了终结方法或者清除方法，则要注意它的不确定性和性能后果。</strong></p><h2 id="9-try-with-resource优先于try-finally">9. try-with-resource优先于try-finally</h2><p>Java库包含许多必须通过调用close方法手动关闭的资源。常见的有InputStream、OutputStream 和 java.sql.Connection。客户端经常会忽略资源的关闭，而造成严重的性能后果。虽然许多资源用终结方法作为安全网，但是这种方法也不是很理想。</p><p>根据经验，try-finally 语句是确保正确关闭资源的最佳方法，即使在出现异常或返回时也是如此：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally - No longer the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可能看起来好像也不坏，但添加第二个资源时，情况会变得更糟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">                out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使try-finally语句正确地关闭了资源，但是也存在一些不足：</p><p>​以第一个firstLineOfFile为例，如果运行时物理设备异常，则调用readLine方法时就会抛出异常，但是由于同样的原因，close方法也会异常。这种场景下，第二个异常完全抹除了第一个异常，在异常堆栈里找不到第一个异常。<strong>这时候有可能会使调试变得非常复杂</strong>。</p><hr><p>当 Java 7 引入 try-with-resources 语句时，所有这些问题都一次性解决了。要使用这个结构，资源必须实现 AutoCloseable 接口，它包含了单个返回void的 close 方法组成。Java 库和第三方库中的许多类和接口现在都实现或扩展了 AutoCloseable。如果你编写的类存在必须关闭的资源，那么也应该实现 AutoCloseable。</p><p>下面是使用 try-with-resources 的第一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是使用 try-with-resources 的第二个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources on multiple resources - short and sweet</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dst)) &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">            out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和使用 try-finally 的最开始的两个代码相比，try-with-resources 为开发者提供了更好的诊断方式。如果使用 try-with-resources ，这时候运行 firstLineOfFile 方法，如果异常是由 readLine 调用和不可见的 close 抛出的，第二个异常就会被禁止，第一个异常就会被保留（如果有多个异常，也只会保留第一个）。这些被禁止的异常并不是被简单的抛弃，而是被打印在堆栈轨迹中，并注明是被禁止的异常。通过编程调用getSuppressed方法还可以访问到它们。【getSuppressed方法也已经添加在java 7的Throwable中了】。</p><p>try-with-resources 中也可以使用 catch 子句，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources with a catch clause</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">firstLineOfFile</span><span class="params">(String path, String defaultVal)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以：在处理必须关闭的资源时，始终要优先考虑用 try-with-resources，而不是try-finally。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书inG </tag>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W-RPC开发问题</title>
      <link href="/posts/57e465a9.html"/>
      <url>/posts/57e465a9.html</url>
      
        <content type="html"><![CDATA[<h1>手搓RPC</h1><h2 id="序列化、反序列化问题">序列化、反序列化问题</h2><p>RPC远程调用时，需要将对象进行序列化/反序列化操作。</p><p>比如RPC框架的response、request对象需要传递给服务提供方/服务消费方。所以需要对RPC的response、request对象进行序列化、反序列化操作。</p><p>实现方式：</p><ul><li>第三方序列化框架<ul><li>推荐。比较方便，但是该项目不需要太复杂，所以暂不使用。</li></ul></li><li>继承Serializable接口<ul><li><code>Serializable</code>接口本身不包含任何方法或字段，它是一个标记接口（marker interface）</li><li>具体的序列化方法主要通过<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>这两个类来完成</li><li>如果更好的控制序列化过程，还需要使用<code>writeObject()</code>和<code>readObject()</code>方法</li><li>每一个继承该接口，同时想要精细化控制的类都需要实现<code>writeObject()</code>和<code>readObject()</code>方法</li></ul></li><li>自定义一个Serializer序列化器<ul><li>自己定义序列化、反序列化方法，将控制序列化的方法都写在序列化器中，不需要每个类自己写一遍。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(obj);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            objectInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>流的<code>flush方法</code>和<code>close方法</code></li></ul><blockquote><ul><li><p><code>flush()</code>方法的主要作用是立即将缓冲区中的所有数据写入到目标输出流中。这保证了即使在程序异常终止的情况下，已经调用过的方法所要写入的数据能够被保存下来。</p></li><li><p><code>close()</code>方法不仅会调用<code>flush()</code>方法来清空缓冲区，还会关闭底层的输出流，释放与之关联的所有系统资源。一旦流被关闭，就不能再进行任何读写操作，否则会抛出<code>IOException</code>。</p></li></ul><p><strong>使用建议</strong></p><p>在实际编程中，推荐的做法是在完成所有写入操作后，总是调用<code>close()</code>方法来关闭流。由于<code>close()</code>方法内部会调用<code>flush()</code>，所以通常不需要显式地调用<code>flush()</code>，除非有特定的需求（例如，在多次写入之间需要立即同步数据）。</p></blockquote><h2 id="消费方发起调用的方法">消费方发起调用的方法</h2><p>rpc本质就是远程调用，比如服务提供方A，消费方B、C…，无论消费方有多少，获取提供方A的某个数据所需要的请求代码都是相同的。所以可以采用代理的方法（代理本来要用作方法的增强，在这里直接调用相同的代码逻辑）。</p><p>缺点：这样实现的接口<code>UserService</code>必须在common包里定义，提供方实现这个接口才可以。因为消费方也需要。</p>]]></content>
      
      
      <categories>
          
          <category> 工作inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手搓RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W-子组件调整element#message的高度</title>
      <link href="/posts/87d480c0.html"/>
      <url>/posts/87d480c0.html</url>
      
        <content type="html"><![CDATA[<h1>子组件调整element#message的高度</h1><h2 id="message组件">message组件</h2><p>Element UI 的 <code>Message</code> 组件默认是在全局范围内显示消息提示，可以在子组件中使用它，但是Message是在全局注册，所以位置参数都是针对整个app.vue（页面来显示的）</p><h2 id="调整高度">调整高度</h2><p><code>message</code>有属性offset，可以用来调整高度。所以需要每次this.$message时，给offset属性赋值即可。</p><h2 id="计算子组件高度">计算子组件高度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">updateComponentPosition() &#123;</span><br><span class="line">    // myComponent是子组件</span><br><span class="line">    const componentRect = this.$refs.myComponent.getBoundingClientRect();</span><br><span class="line">    // 如果使用该vue文件自身，需要用getElementById或者getElementByClassName获取到该vue文件的dom元素</span><br><span class="line">const componentRect = document.getElementBy(&#x27;myElement&#x27;);</span><br><span class="line"></span><br><span class="line">    this.componentTopPosition = componentRect.top;</span><br><span class="line">    this.componentHeight = componentRect.height;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">this.$message(&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 此时位置在子组件的最上方</span><br><span class="line">    offset: this.componentTopPosition + this.componentHeight</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>getBoundingClientRect()</code> 是一个 DOM 元素的方法，用于获取一个元素的大小及其相对于视口的位置。这个方法返回一个对象，该对象包含了元素的 top、right、bottom、left、width 和 height 属性，这些属性都是相对于视口的坐标系。</p><h3 id="返回的对象属性说明">返回的对象属性说明</h3><ul><li><code>top</code>: 元素上边界到视口顶部的距离。</li><li><code>right</code>: 视口右侧到元素右边界的距离（不是元素到视口右边界的距离）。</li><li><code>bottom</code>: 视口底部到元素下边界的距离（不是元素到视口底边界的距离）。</li><li><code>left</code>: 元素左边界到视口左侧的距离。</li><li><code>width</code>: 元素的宽度。</li><li><code>height</code>: 元素的高度。</li></ul><h3 id="注意事项">注意事项</h3><ul><li><code>getBoundingClientRect()</code> 返回的值是相对于视口的，而不是相对于文档的。这意味着如果页面有滚动，返回的坐标会考虑到滚动的影响。</li><li>方法返回的坐标是浮点数，即使元素的样式是整数。</li><li>如果元素不在视口内（例如，完全被其他元素遮挡或在折叠面板后面），<code>getBoundingClientRect()</code> 仍然可以返回准确的坐标信息。</li><li>在移动设备上，坐标可能因缩放而发生变化。</li></ul><blockquote><p>视口（Viewport）：</p><p>指的是用户通过浏览器或其他客户端软件查看网页内容时可见的区域。视口的概念尤其重要于响应式设计和移动设备的网页布局中，因为它直接影响了网页内容如何适应不同的屏幕尺寸和设备特性。</p><p>视口可以分为几种类型，每种类型在网页布局和响应式设计中扮演着不同的角色：</p><ol><li><strong>布局视口（Layout Viewport）</strong>:</li></ol><ul><li>在早期的网页设计中，布局视口通常指的是未缩放的浏览器窗口大小。然而，在移动设备上，为了兼容传统桌面网页的宽度，布局视口经常被设置为一个固定的宽度（如980px或1024px），这使得网页可以按预期显示，而不必做额外的缩放。</li></ul><ol start="2"><li><strong>视觉视口（Visual Viewport）</strong>:</li></ol><ul><li>视觉视口是用户当前在屏幕上实际看到的网页部分。当用户缩放页面时，视觉视口的大小会改变，但布局视口的大小通常保持不变。这意味着即使用户缩放页面，网页的布局计算仍然基于布局视口的大小。</li></ul><ol start="3"><li><strong>理想视口（Ideal Viewport）</strong>:</li></ol><ul><li>理想视口是为了使网页在移动设备上有最佳浏览体验而设定的视口大小。理想视口的宽度通常等于设备的实际屏幕宽度（以CSS像素计），这样网页可以完全填充屏幕，无需水平滚动。</li></ul><ol start="4"><li><strong>设备视口（Device Viewport）</strong>:</li></ol><ul><li>设备视口是指设备本身的屏幕尺寸，包括其物理像素尺寸和设备像素比（DPR）。设备视口对于确定网页在设备上的最终呈现至关重要。</li></ul></blockquote><h3 id="使用场景">使用场景</h3><ul><li>动态调整元素位置或大小。</li><li>检测元素是否在视口内，用于懒加载图片等。</li><li>实现拖拽效果或碰撞检测。</li><li>计算元素之间的距离或重叠部分。</li></ul><h3 id="浏览器兼容性">浏览器兼容性</h3><p><code>getBoundingClientRect()</code> 方法在现代浏览器中（包括 IE9+）广泛支持，但在一些较老的浏览器中可能不可用，这时可以使用 <code>getBoundingClientRectNoScroll</code> 作为兼容方案，不过这种方法在现代开发中已经很少使用。</p><p>总之，<code>getBoundingClientRect()</code> 是一个非常实用的方法，可以用于获取元素的精确位置和尺寸信息，对于实现响应式设计、动态布局和其他交互效果都非常有用。</p>]]></content>
      
      
      <categories>
          
          <category> 工作inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBase-Redis初级学习</title>
      <link href="/posts/57902a6a.html"/>
      <url>/posts/57902a6a.html</url>
      
        <content type="html"><![CDATA[<h1>Redis初级</h1><h2 id="目标">目标</h2><ol><li>线程模型</li><li>数据结构</li><li>lua</li><li>虚拟内存</li><li>持久化</li><li>事务机制</li><li>内存淘汰</li><li>缓存穿透、击穿、雪崩</li><li>分布式锁</li><li>redission（watchdog/lock/tryLock/jedis）</li><li>key过期</li></ol><h2 id="线程模型">线程模型</h2><blockquote><p>参考文章：</p><p><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E9%87%8D%E8%A6%81">https://javaguide.cn/database/redis/redis-questions-01.html#redis-线程模型-重要</a></p><p><a href="https://www.xiaolincoding.com/redis/base/redis_interview.html#redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">https://www.xiaolincoding.com/redis/base/redis_interview.html#redis-线程模型</a></p></blockquote><h2 id="数据结构">数据结构</h2><h3 id="字符串">字符串</h3><h4 id="SDS">SDS</h4><p>Redis 构建了简单动态字符串（SDS）的数据类型，作为 Redis 的默认字符串表示，包含字符串的键值对在底层都是由 SDS 实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 【字节】数组，用于保存字符串（不是字符数组）</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SDS 遵循 C 字符串<strong>以空字符结尾</strong>的惯例， 保存空字符的 1 字节不计算在 len 属性，SDS 会自动为空字符分配额外的 1 字节空间和添加空字符到字符串末尾，所以空字符对于 SDS 的使用者来说是完全透明的</p><p><img src="../image/post/Redis-SDS%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt=""></p><hr><h4 id="对比">对比</h4><p>常数复杂度获取字符串长度：</p><ul><li>C 字符串不记录自身的长度，获取时需要遍历整个字符串，遇到空字符串为止，时间复杂度为 O(N)</li><li>SDS 获取字符串长度的时间复杂度为 O(1)，设置和更新 SDS 长度由函数底层自动完成</li></ul><p>杜绝缓冲区溢出：</p><ul><li><p>C 字符串调用 strcat 函数拼接字符串时，如果字符串内存不够容纳目标字符串，就会造成缓冲区溢出（Buffer Overflow）</p><p>s1 和 s2 是内存中相邻的字符串，执行 <code>strcat(s1, &quot; Cluster&quot;)</code>（有空格）：</p><p><img src="../image/post/Redis-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98.png" alt=""></p></li><li><p>SDS 空间分配策略：当对 SDS 进行修改时，首先检查 SDS 的空间是否满足修改所需的要求， 如果不满足会自动将 SDS 的空间扩展至执行修改所需的大小，然后执行实际的修改操作， 避免了缓冲区溢出的问题</p></li></ul><p>二进制安全：</p><ul><li>C 字符串中的字符必须符合某种编码（比如 ASCII）方式，除了字符串末尾以外其他位置不能包含空字符，否则会被误认为是字符串的结尾，所以只能保存文本数据</li><li>SDS 的 API 都是二进制安全的，使用字节数组 buf 保存一系列的二进制数据，使用 len 属性来判断数据的结尾，所以可以保存图片、视频、压缩文件等二进制数据</li></ul><p>兼容 C 字符串的函数：SDS 会在为 buf 数组分配空间时多分配一个字节来保存空字符，所以可以重用一部分 C 字符串函数库的函数</p><hr><h4 id="内存">内存</h4><p>C 字符串<strong>每次</strong>增长或者缩短都会进行一次内存重分配，拼接操作通过重分配扩展底层数组空间，截断操作通过重分配释放不使用的内存空间，防止出现内存泄露</p><p>SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联，在 SDS 中 buf 数组的长度不一定就是字符数量加一， 数组里面可以包含未使用的字节，字节的数量由 free 属性记录</p><p>内存重分配涉及复杂的算法，需要执行系统调用，是一个比较耗时的操作，SDS 的两种优化策略：</p><ul><li><p>空间预分配：当 SDS 的 API 进行修改并且需要进行空间扩展时，程序不仅会为 SDS 分配修改所必需的空间， 还会为 SDS 分配额外的未使用空间</p><ul><li><p>对 SDS 修改之后，SDS 的长度（len 属性）小于 1MB，程序分配和 len 属性同样大小的未使用空间，此时 len 和 free 相等</p><p>s 为 Redis，执行 <code>sdscat(s, &quot; Cluster&quot;)</code> 后，len 变为 13 字节，所以也分配了 13 字节的 free 空间，总长度变为 27 字节（额外的一字节保存空字符，13 + 13 + 1 = 27）</p><p><img src="../image/post/Redis-SDS%E5%86%85%E5%AD%98%E9%A2%84%E5%88%86%E9%85%8D.png" alt=""></p></li><li><p>对 SDS 修改之后，SDS 的长度大于等于 1MB，程序会分配 1MB 的未使用空间</p></li></ul><p>在扩展 SDS 空间前，API 会先检查 free 空间是否足够，如果足够就无需执行内存重分配，所以通过预分配策略，SDS 将连续增长 N 次字符串所需内存的重分配次数从<strong>必定 N 次降低为最多 N 次</strong></p></li><li><p>惰性空间释放：当 SDS 的 API 需要缩短字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用</p><p>SDS 提供了相应的 API 来真正释放 SDS 的未使用空间，所以不用担心空间惰性释放策略造成的内存浪费问题</p></li></ul><hr><h3 id="链表">链表</h3><p>链表提供了高效的节点重排能力，C 语言并没有内置这种数据结构，所以 Redis 构建了链表数据类型</p><p>链表节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>多个 listNode 通过 prev 和 next 指针组成<strong>双端链表</strong>：</p><p><img src="../image/post/Redis-%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt=""></p><p>list 链表结构：提供了表头指针 head 、表尾指针 tail 以及链表长度计数器 len</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="type">void</span> *(*dup) (<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等</span></span><br><span class="line">    <span class="type">int</span> (*match) (<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><p><img src="../image/post/Redis-%E9%93%BE%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt=""></p><p>Redis 链表的特性：</p><ul><li>双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是 O(1)</li><li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点</li><li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针，获取链表的表头节点和表尾节点的时间复杂度为 O(1)</li><li>带链表长度计数器：使用 len 属性来对 list 持有的链表节点进行计数，获取链表中节点数量的时间复杂度为 O(1)</li><li>多态：链表节点使用 void * 指针来保存节点值， 并且可以通过 dup、free 、match 三个属性为节点值设置类型特定函数，所以链表可以保存各种<strong>不同类型的值</strong></li></ul><hr><h3 id="字典">字典</h3><h4 id="哈希表">哈希表</h4><p>Redis 字典使用的哈希表结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组，数组中每个元素指向 dictEntry 结构</span></span><br><span class="line">dictEntry **table;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 哈希表大小，数组的长度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 哈希表大小掩码，用于计算索引值，总是等于 【size-1】</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 该哈希表已有节点的数量 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>哈希表节点结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line"><span class="type">void</span> *key;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 值，可以是一个指针，或者整数</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;<span class="comment">// 指针</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 指向下个哈希表节点，形成链表，用来解决冲突问题</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p><img src="../image/post/Redis-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt=""></p><hr><h4 id="字典结构">字典结构</h4><p>字典，又称为符号表、关联数组、映射（Map），用于保存键值对的数据结构，字典中的每个键都是独一无二的。底层采用哈希表实现，一个哈希表包含多个哈希表节点，每个节点保存一个键值对</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表，数组中的每个项都是一个dictht哈希表，</span></span><br><span class="line">    <span class="comment">// 一般情况下字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p><ul><li>type 属性是指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数</li><li>privdata 属性保存了需要传给那些类型特定函数的可选参数</li></ul><p><img src="../image/post/Redis-%E5%AD%97%E5%85%B8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt=""></p><hr><h4 id="哈希冲突">哈希冲突</h4><p>Redis 使用 MurmurHash 算法来计算键的哈希值，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快</p><p>将一个新的键值对添加到字典里，需要先根据键 key 计算出哈希值，然后进行取模运算（取余）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask</span><br></pre></td></tr></table></figure><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上时，就称这些键发生了哈希冲突（collision）</p><p>Redis 的哈希表使用链地址法（separate chaining）来解决键哈希冲突， 每个哈希表节点都有一个 next 指针，多个节点通过 next 指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题</p><p>dictEntry 节点组成的链表没有指向链表表尾的指针，为了速度考虑，程序总是将新节点添加到链表的表头位置（<strong>头插法</strong>），时间复杂度为 O(1)</p><p><img src="../image/post/Redis-%E5%AD%97%E5%85%B8%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81.png" alt=""></p><hr><h4 id="负载因子">负载因子</h4><p>负载因子的计算方式：哈希表中的<strong>节点数量</strong> / 哈希表的大小（<strong>长度</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure><p>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时 ，程序会自动对哈希表的大小进行相应的扩展或者收缩</p><p>哈希表执行扩容的条件：</p><ul><li><p>服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 1</p></li><li><p>服务器正在执行 BGSAVE 或者 BGREWRITEAOF 命令，哈希表的负载因子大于等于 5</p><p>原因：执行该命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on­-write）技术来优化子进程的使用效率，通过提高执行扩展操作的负载因子，尽可能地避免在子进程存在期间进行哈希表扩展操作，可以避免不必要的内存写入操作，最大限度地节约内存</p></li></ul><p>哈希表执行收缩的条件：负载因子小于 0.1（自动执行，servreCron 中检测），缩小为字典中数据个数的 50% 左右</p><hr><h4 id="重新散列">重新散列</h4><p>扩展和收缩哈希表的操作通过 rehash（重新散列）来完成，步骤如下：</p><ul><li>为字典的 ht[1] 哈希表分配空间，空间大小的分配情况：<ul><li>如果执行的是扩展操作，ht[1] 的大小为第一个大于等于 $ht[0].used * 2$ 的 $2^n$</li><li>如果执行的是收缩操作，ht[1] 的大小为第一个大于等于 $ht[0].used$ 的 $2^n$</li></ul></li><li>将保存在 ht[0] 中所有的键值对重新计算哈希值和索引值，迁移到 ht[1] 上</li><li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0]变为空表）， 释放 ht[0]，将 ht[1] 设置为 ht[0]，并在 ht[1] 创建一个新的空白哈希表，为下一次 rehash 做准备</li></ul><p>如果哈希表里保存的键值对数量很少，rehash 就可以在瞬间完成，但是如果哈希表里数据很多，那么要一次性将这些键值对全部 rehash 到 ht[1] 需要大量计算，可能会导致服务器在一段时间内停止服务</p><p>Redis 对 rehash 做了优化，使 rehash 的动作并不是一次性、集中式的完成，而是分多次，渐进式的完成，又叫<strong>渐进式 rehash</strong></p><ul><li>为 ht[1] 分配空间，此时字典同时持有 ht[0] 和 ht[1] 两个哈希表</li><li>在字典中维护了一个索引计数器变量 rehashidx，并将变量的值设为 0，表示 rehash 正式开始</li><li>在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，rehash 完成之后<strong>将 rehashidx 属性的值增一</strong></li><li>随着字典操作的不断执行，最终在某个时间点上 ht[0] 的所有键值对都被 rehash 至 ht[1]，这时程序将 rehashidx 属性的值设为 -1，表示 rehash 操作已完成</li></ul><p>渐进式 rehash 采用<strong>分而治之</strong>的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式 rehash 带来的庞大计算量</p><p>渐进式 rehash 期间的哈希表操作：</p><ul><li>字典的查找、删除、更新操作会在两个哈希表上进行，比如查找一个键会先在 ht[0] 上查找，查找不到就去 ht[1] 继续查找</li><li>字典的添加操作会直接在 ht[1] 上添加，不在 ht[0] 上进行任何添加</li></ul><hr><h3 id="跳跃表">跳跃表</h3><h4 id="底层结构">底层结构</h4><p>跳跃表（skiplist）是一种有序（<strong>默认升序</strong>）的数据结构，在链表的基础上<strong>增加了多级索引以提升查找的效率</strong>，索引是占内存的，所以是一个<strong>空间换时间</strong>的方案，跳表平均 O(logN)、最坏 O(N) 复杂度的节点查找，效率与平衡树相当但是实现更简单</p><p>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势可以被放大，而缺点（占内存）则可以忽略</p><p>Redis 只在两个地方应用了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点，O(1) 的时间复杂度定位头尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">head</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表的长度，也就是表内的节点数量 (表头节点不计算在内)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数 (表头节点的层高不计算在内)</span></span><br><span class="line">    <span class="type">int</span> level</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><img src="../image/post/Redis-%E8%B7%B3%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt=""></p><hr><h4 id="属性分析">属性分析</h4><p>层：level 数组包含多个元素，每个元素包含指向其他节点的指针。根据幕次定律（power law，越大的数出现的概率越小）<strong>随机</strong>生成一个介于 1 和 32 之间的值（Redis5 之后最大为 64）作为 level 数组的大小，这个大小就是层的高度，节点的第一层是 level[0] = L1</p><p>前进指针：forward 用于从表头到表尾方向正序（升序）遍历节点，遇到 NULL 停止遍历</p><p>跨度：span 用于记录两个节点之间的距离，用来<strong>计算排位（rank）</strong>：</p><ul><li><p>两个节点之间的跨度越大相距的就越远，指向 NULL 的所有前进指针的跨度都为 0</p></li><li><p>在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，结果就是目标节点在跳跃表中的排位，按照上图所示：</p><p>查找分值为 3.0 的节点，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为 3，所以目标节点在跳跃表中的排位为 3</p><p>查找分值为 2.0 的节点，沿途经历的层：经过了两个跨度为 1 的节点，因此可以计算出目标节点在跳跃表中的排位为 2</p></li></ul><p>后退指针：backward 用于从表尾到表头方向逆序（降序）遍历节点</p><p>分值：score 属性一个 double 类型的浮点数，跳跃表中的所有节点都<strong>按分值从小到大来排序</strong></p><p>成员对象：obj 属性是一个指针，指向一个 SDS 字符串对象。同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值可以是相同的，分值相同的节点将按照成员对象在字典序中的大小来进行排序（从小到大）</p><p>个人笔记：JUC → 并发包 → ConcurrentSkipListMap 详解跳跃表</p><hr><h3 id="整数集合">整数集合</h3><h4 id="底层结构-2">底层结构</h4><p>整数集合（intset）是用于保存整数值的集合数据结构，是 Redis 集合键的底层实现之一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"><span class="comment">// 编码方式</span></span><br><span class="line"><span class="type">uint32_t</span> encoding;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 集合包含的元素数量，也就是 contents 数组的长度</span></span><br><span class="line"><span class="type">uint32_t</span> length;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>encoding 取值为三种：INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64</p><p>整数集合的每个元素都是 contents 数组的一个数组项（item），在数组中按值的大小从小到大<strong>有序排列</strong>，并且数组中<strong>不包含任何重复项</strong>。虽然 contents 属性声明为 int8_t 类型，但实际上数组并不保存任何 int8_t 类型的值， 真正类型取决于 encoding 属性</p><p><img src="../image/post/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt=""></p><p>说明：底层存储结构是数组，所以为了保证有序性和不重复性，每次添加一个元素的时间复杂度是 O(N)</p><hr><h4 id="升级降级">升级降级</h4><p>整数集合添加的新元素的类型比集合现有所有元素的类型都要长时，需要先进行升级（upgrade），升级流程：</p><ul><li><p>根据新元素的类型长度以及集合元素的数量（包括新元素在内），扩展整数集合底层数组的空间大小</p></li><li><p>将底层数组现有的所有元素都转换成与新元素相同的类型，并将转换后的元素放入正确的位置，放置过程保证数组的有序性</p><p>图示 32 * 4 = 128 位，首先将 3 放入索引 2（64 位 - 95 位），然后将 2 放置索引 1，将 1 放置在索引 0，从后向前依次放置在对应的区间，最后放置 65535 元素到索引 3（96 位- 127 位），修改 length 属性为 4</p></li><li><p>将新元素添加到底层数组里</p></li></ul><p><img src="../image/post/Redis-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A7.png" alt=""></p><p>每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为 O(N)</p><p>引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素，升级之后新元素的摆放位置：</p><ul><li>在新元素小于所有现有元素的情况下，新元素会被放置在底层数组的最开头（索引 0）</li><li>在新元素大于所有现有元素的情况下，新元素会被放置在底层数组的最末尾（索引 length-1）</li></ul><p>整数集合升级策略的优点：</p><ul><li><p>提升整数集合的灵活性：C 语言是静态类型语言，为了避免类型错误通常不会将两种不同类型的值放在同一个数据结构里面，整数集合可以自动升级底层数组来适应新元素，所以可以随意的添加整数</p></li><li><p>节约内存：要让数组可以同时保存 int16、int32、int64 三种类型的值，可以直接使用 int64_t 类型的数组作为整数集合的底层实现，但是会造成内存浪费，整数集合可以确保升级操作只会在有需要的时候进行，尽量节省内存</p></li></ul><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态</p><hr><h3 id="压缩列表">压缩列表</h3><h4 id="底层结构-3">底层结构</h4><p>压缩列表（ziplist）是 Redis 为了节约内存而开发的，是列表键和哈希键的底层实现之一。是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值</p><p><img src="../image/post/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84.png" alt=""></p><ul><li>zlbytes：uint32_t 类型 4 字节，记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分或者计算 zlend 的位置时使用</li><li>zltail：uint32_t 类型 4 字节，记录压缩列表表尾节点距离起始地址有多少字节，通过这个偏移量程序无须遍历整个压缩列表就可以确定表尾节点的地址</li><li>zllen：uint16_t 类型 2 字节，记录了压缩列表包含的节点数量，当该属性的值小于 UINT16_MAX (65535) 时，该值就是压缩列表中节点的数量；当这个值等于 UINT16_MAX 时节点的真实数量需要遍历整个压缩列表才能计算得出</li><li>entryX：列表节点，压缩列表中的各个节点，<strong>节点的长度由节点保存的内容决定</strong></li><li>zlend：uint8_t 类型 1 字节，是一个特殊值 0xFF (255)，用于标记压缩列表的末端</li></ul><p><img src="../image/post/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt=""></p><p>列表 zlbytes 属性的值为 0x50 (十进制 80)，表示压缩列表的总长为 80 字节，列表 zltail 属性的值为 0x3c (十进制 60)，假设表的起始地址为 p，计算得出表尾节点 entry3 的地址 p + 60</p><hr><h4 id="列表节点">列表节点</h4><p>列表节点 entry 的数据结构：</p><p><img src="../image/post/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%8A%82%E7%82%B9.png" alt=""></p><p>previous_entry_length：以字节为单位记录了压缩列表中前一个节点的长度，程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址，完成从表尾向表头遍历操作</p><ul><li>如果前一节点的长度小于 254 字节，该属性的长度为 1 字节，前一节点的长度就保存在这一个字节里</li><li>如果前一节点的长度大于等于 254 字节，该属性的长度为 5 字节，其中第一字节会被设置为 0xFE（十进制 254），之后的四个字节则用于保存前一节点的长度</li></ul><p>encoding：记录了节点的 content 属性所保存的数据类型和长度</p><ul><li><p>长度为 1 字节、2 字节或者 5 字节，值的最高位为 00、01 或者 10 的是字节数组编码，数组的长度由编码除去最高两位之后的其他位记录，下划线 <code>_</code> 表示留空，而 <code>b</code>、<code>x</code> 等变量则代表实际的二进制数据</p><p><img src="../image/post/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E7%BC%96%E7%A0%81.png" alt=""></p></li><li><p>长度为 1 字节，值的最高位为 11 的是整数编码，整数值的类型和长度由编码除去最高两位之后的其他位记录</p><p><img src="../image/post/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E6%95%B4%E6%95%B0%E7%BC%96%E7%A0%81.png" alt=""></p></li></ul><p>content：每个压缩列表节点可以保存一个字节数组或者一个整数值</p><ul><li><p>字节数组可以是以下三种长度的其中一种：</p><ul><li><p>长度小于等于 $63 (2^6-1)$ 字节的字节数组</p></li><li><p>长度小于等于 $16383(2^{14}-1)$ 字节的字节数组</p></li><li><p>长度小于等于 $4294967295(2^{32}-1)$ 字节的字节数组</p></li></ul></li><li><p>整数值则可以是以下六种长度的其中一种：</p><ul><li><p>4 位长，介于 0 至 12 之间的无符号整数</p></li><li><p>1 字节长的有符号整数</p></li><li><p>3 字节长的有符号整数</p></li><li><p>int16_t 类型整数</p></li><li><p>int32_t 类型整数</p></li><li><p>int64_t 类型整数</p></li></ul></li></ul><hr><h4 id="连锁更新">连锁更新</h4><p>Redis 将在特殊情况下产生的连续多次空间扩展操作称之为连锁更新（cascade update）</p><p>假设在一个压缩列表中，有多个连续的、长度介于 250 到 253 字节之间的节点 e1 至 eN。将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的头节点，new 就成为 e1 的前置节点。e1 的 previous_entry_length 属性仅为 1 字节，无法保存新节点 new 的长度，所以要对压缩列表执行空间重分配操作，并将 e1 节点的 previous_entry_length 属性从 1 字节长扩展为 5 字节长。由于 e1 原本的长度介于 250 至 253 字节之间，所以扩展后 e1 的长度就变成了 254 至 257 字节之间，导致 e2 的  previous_entry_length 属性无法保存 e1 的长度，程序需要不断地对压缩列表执行空间重分配操作，直到 eN 为止</p><p><img src="../image/post/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B01.png" alt=""></p><p>删除节点也可能会引发连锁更新，big.length &gt;= 254，small.length &lt; 254，删除 small 节点</p><p><img src="../image/post/Redis-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B02.png" alt=""></p><p>连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配，每次重分配的最坏复杂度为 O(N)，所以连锁更新的最坏复杂度为 O(N^2)</p><p>说明：尽管连锁更新的复杂度较高，但出现的记录是非常低的，即使出现只要被更新的节点数量不多，就不会对性能造成影响</p><hr><h2 id="Lua脚本">Lua脚本</h2><p>Lua是一种轻量级的、高效的、可扩展的脚本语言，常用于游戏开发、系统管理、Web应用等场景。</p><h3 id="基本使用">基本使用</h3><h4 id="数据类型">数据类型</h4><p>Lua支持多种数据类型，包括数字（整数和浮点数）、字符串、布尔值、table（类似于数组和哈希表）、函数等。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义变量</span></span><br><span class="line"><span class="keyword">local</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">local</span> y = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="keyword">local</span> z = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个变量可以在一行定义</span></span><br><span class="line"><span class="keyword">local</span> a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打印变量</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure><h4 id="控制结构">控制结构</h4><p>Lua提供常见的控制结构，如<code>if</code>、<code>for</code>、<code>while</code>、<code>repeat-until</code>等。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- if 语句</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;x is greater than 5&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- for 循环</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- while 循环</span></span><br><span class="line"><span class="keyword">local</span> count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> count &lt;= <span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">print</span>(count)</span><br><span class="line">  count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- repeat-until 循环</span></span><br><span class="line"><span class="keyword">local</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">  <span class="built_in">print</span>(num)</span><br><span class="line">  num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span> num &gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="函数">函数</h4><p>在Lua中，函数是第一类公民，可以作为参数传递，也可以从其他函数返回。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span><span class="params">(name)</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello, &quot;</span> .. name .. <span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGreeting</span><span class="params">(name)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hi, &quot;</span> .. name .. <span class="string">&quot;!&quot;</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> greeting = createGreeting(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">greeting()</span><br></pre></td></tr></table></figure><h3 id="Redis中使用">Redis中使用</h3><p>为什么使用Lua脚本？</p><ol><li><strong>减少网络延迟</strong>：通过将多个Redis命令封装在一个Lua脚本中，可以减少网络传输次数，提高响应速度。</li><li><strong>原子性</strong>：Lua脚本在Redis服务器内部以原子方式执行，这意味着脚本内的所有操作要么全部成功，要么全部失败，这有助于避免竞态条件。</li><li><strong>灵活性</strong>：Lua脚本提供了比Redis原生命令更丰富的编程能力，可以实现复杂的业务逻辑。</li></ol><h4 id="编写脚本">编写脚本</h4><p>首先，需要编写Lua脚本。脚本通常接受一些键名和参数，使用<code>KEYS</code>和<code>ARGV</code>数组来引用它们。例如，以下脚本将两个数值相加并存储结果：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将两个数值相加并存储结果</span></span><br><span class="line"><span class="keyword">local</span> sum = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]) + <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line">redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">1</span>], sum)</span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><h4 id="执行脚本">执行脚本</h4><p><strong>使用<code>EVAL</code>命令执行脚本</strong></p><p>一旦脚本编写完成，你可以使用<code>EVAL</code>命令将其发送给Redis服务器执行。<code>EVAL</code>命令接收三个参数：</p><ul><li>脚本的文本</li><li>脚本要访问的键的数量</li><li>脚本要使用的键和参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;local sum = tonumber(ARGV[1]) + tonumber(ARGV[2]); redis.call(&#x27;SET&#x27;, KEYS[1], sum); return sum;&quot; 1 myKey 10 20</span><br><span class="line"></span><br><span class="line">脚本的文本：&quot;local sum = ...... return sum;&quot;</span><br><span class="line">键的数量：1</span><br><span class="line">要使用的键：myKey</span><br><span class="line">使用的参数：10 20</span><br></pre></td></tr></table></figure><p><strong>使用<code>EVALSHA</code>命令执行脚本</strong></p><p>为了提高性能，Redis允许你通过计算脚本的SHA1校验和来缓存脚本，之后你可以使用<code>EVALSHA</code>命令通过校验和来执行脚本，而无需每次都发送脚本文本。这可以减少网络带宽的使用。</p><p>例如，如果脚本的SHA1校验和是<code>abcdef1234567890</code>，则可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVALSHA &quot;abcdef1234567890&quot; 1 myKey 10 20</span><br></pre></td></tr></table></figure><h4 id="脚本调试">脚本调试</h4><p>Redis从2.8.0版本开始支持脚本调试。你可以使用<code>DEBUG SCRIPT</code>命令来查看脚本是否被正确加载，以及脚本的详细信息。</p><h4 id="注意事项"><strong>注意事项</strong></h4><ul><li>Lua脚本在Redis服务器中是单线程执行的，这意味着在执行脚本期间，Redis不能同时处理其他命令。</li><li>应确保脚本的执行时间尽可能短，以避免阻塞Redis服务器。</li></ul><h3 id="SpringBoot中使用">SpringBoot中使用</h3><ol><li><p>创建一个<code>.lua</code>文件，例如<code>scripts.lua</code>，并在其中编写你的Lua脚本。例如，一个简单的脚本可能看起来像这样：</p></li><li><p>在你的Spring Boot应用中，注入<code>StringRedisTemplate</code>或<code>ReactiveStringRedisTemplate</code>，然后使用<code>execute</code>方法执行Lua脚本。这里以<code>StringRedisTemplate</code>为例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisService</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setIfAbsent</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        script.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;scripts.lua&quot;</span>)));</span><br><span class="line">        script.setResultType(Long.class);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.execute(script, Collections.singletonList(key), value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>setIfAbsent</code>方法使用了<code>DefaultRedisScript</code>来执行Lua脚本。<code>ClassPathResource</code>用于从类路径加载Lua脚本文件。</p></li></ol><h2 id="虚拟内存">虚拟内存</h2><p>Redis的虚拟内存（VM）机制是一种允许Redis将不经常访问的数据从内存移动到磁盘的技术，以此来节省服务器的RAM资源。</p><p><strong>在Redis从2.4版本开始废弃虚拟内存功能，并且在更高版本中不推荐使用。</strong></p><p>要在Redis中启用虚拟内存，你需要在配置文件<code>redis.conf</code>中设置以下选项：</p><ul><li><code>vm-enabled yes</code>：启用虚拟内存功能。</li><li><code>vm-max-memory &lt;bytes&gt;</code>：设置Redis可以使用的最大虚拟字节数。当数据集的大小超过这个值时，Redis会开始将不常访问的数据移到磁盘上。</li><li><code>vm-page-size &lt;bytes&gt;</code>：设定虚拟内存页面的大小，这影响到数据的分页方式。</li><li><code>vm-pages &lt;number&gt;</code>：指定可以使用的虚拟内存页面数量。</li><li><code>vm-swap-file &lt;path&gt;</code>：指定虚拟内存交换文件的路径和文件名。</li><li><code>vm-max-cache-size &lt;bytes&gt;</code>：设置在内存中缓存的已分页数据的最大大小，以加速数据的读取。</li><li><code>vm-min-cache-ttl &lt;seconds&gt;</code>：设置在内存中缓存的已分页数据的最小生存时间。</li></ul><h2 id="持久化">持久化</h2><h3 id="概述">概述</h3><p>持久化：利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化</p><p>作用：持久化用于防止数据的意外丢失，确保数据安全性，因为 Redis 是内存级，所以需要持久化到磁盘</p><p>计算机中的数据全部都是二进制，保存一组数据有两种方式<br><img src="../image/post/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png" style="zoom: 33%;" /></p><p>RDB：将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单</p><p>AOF：将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂</p><hr><h3 id="RDB">RDB</h3><h4 id="文件创建">文件创建</h4><p>RDB 持久化功能所生成的 RDB文件 是一个经过压缩的紧凑二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态，有两个 Redis 命令可以生成 RDB 文件，一个是 SAVE，另一个是 BGSAVE</p><h5 id="SAVE">SAVE</h5><p>SAVE 指令：手动执行一次保存操作，该指令的执行会阻塞当前 Redis 服务器，客户端发送的所有命令请求都会被拒绝，直到当前 RDB 过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</p><p>工作原理：Redis 是个<strong>单线程的工作模式</strong>，会创建一个任务队列，所有的命令都会进到这个队列排队执行。当某个指令在执行的时候，队列后面的指令都要等待，所以这种执行方式会非常耗时</p><p>配置 redis.conf：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> path<span class="comment">#设置存储.rdb文件的路径，通常设置成存储空间较大的目录中，目录名称data</span></span><br><span class="line">dbfilename <span class="string">&quot;x.rdb&quot;</span><span class="comment">#设置本地数据库文件名，默认值为dump.rdb，通常设置为dump-端口号.rdb</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span>|no<span class="comment">#设置存储至本地数据库时是否压缩数据，默认yes，设置为no节省CPU运行时间</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span>|no<span class="comment">#设置读写文件过程是否进行RDB格式校验，默认yes</span></span><br></pre></td></tr></table></figure><hr><h5 id="BGSAVE">BGSAVE</h5><p>BGSAVE：bg 是 background，代表后台执行，命令的完成需要两个进程，<strong>进程之间不相互影响</strong>，所以持久化期间 Redis 正常工作</p><p>工作原理：</p><img src="../image/post/Redis-bgsave%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" style="zoom:67%;" /><p>流程：客户端发出 BGSAVE 指令，Redis 服务器使用 fork 函数创建一个子进程，然后响应后台已经开始执行的信息给客户端。子进程会去执行持久化的操作，持久化过程是先将数据写入到一个临时文件中，持久化操作结束再用这个临时文件<strong>替换</strong>上次持久化的文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建子进程</span></span><br><span class="line">pid = fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 子进程负责创建 RDB 文件</span></span><br><span class="line">    rdbSave()</span><br><span class="line">    <span class="comment"># 完成之后向父进程发送信号</span></span><br><span class="line">    signal_parent()</span><br><span class="line"><span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 父进程继续处理命令请求，并通过轮询等待子进程的信号</span></span><br><span class="line">    handle_request_and_wait_signal()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 处理出错恃况</span></span><br><span class="line">    handle_fork_error() </span><br></pre></td></tr></table></figure><p>配置 redis.conf</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span>|no<span class="comment">#后台存储过程中如果出现错误，是否停止保存操作，默认yes</span></span><br><span class="line">dbfilename filename  </span><br><span class="line"><span class="built_in">dir</span> path  </span><br><span class="line">rdbcompression <span class="built_in">yes</span>|no  </span><br><span class="line">rdbchecksum <span class="built_in">yes</span>|no</span><br></pre></td></tr></table></figure><p>注意：BGSAVE 命令是针对 SAVE 阻塞问题做的优化，Redis 内部所有涉及到 RDB 操作都采用 BGSAVE 的方式，SAVE 命令放弃使用</p><p>在 BGSAVE 命令执行期间，服务器处理 SAVE、BGSAVE、BGREWRITEAOF 三个命令的方式会和平时有所不同</p><ul><li>SAVE 命令会被服务器拒绝，服务器禁止 SAVE 和 BGSAVE 命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个 rdbSave 调用，产生竞争条件</li><li>BGSAVE 命令也会被服务器拒绝，也会产生竞争条件</li><li>BGREWRITEAOF 和 BGSAVE 两个命令不能同时执行<ul><li>如果 BGSAVE 命令正在执行，那么 BGREWRITEAOF 命令会被延迟到 BGSAVE 命令执行完毕之后执行</li><li>如果 BGREWRITEAOF 命令正在执行，那么 BGSAVE 命令会被服务器拒绝</li></ul></li></ul><hr><h5 id="特殊指令">特殊指令</h5><p>RDB 特殊启动形式的指令（客户端输入）</p><ul><li><p>服务器运行过程中重启</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br></pre></td></tr></table></figure></li><li><p>关闭服务器时指定保存数据</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br></pre></td></tr></table></figure><p>默认情况下执行 shutdown 命令时，自动执行 bgsave（如果没有开启 AOF 持久化功能）</p></li><li><p>全量复制：主从复制部分详解</p></li></ul><hr><h4 id="文件载入">文件载入</h4><p>RDB 文件的载入工作是在服务器启动时自动执行，期间 Redis 会一直处于阻塞状态，直到载入完成</p><p>Redis 并没有专门用于载入 RDB 文件的命令，只要服务器在启动时检测到 RDB 文件存在，就会自动载入 RDB 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[7379] 30 Aug 21:07:01.289 * DB loaded from disk: 0.018 seconds  <span class="comment"># 服务器在成功载入 RDB 文件之后打印</span></span><br></pre></td></tr></table></figure><p>AOF 文件的更新频率通常比 RDB 文件的更新频率高：</p><ul><li>如果服务器开启了 AOF 持久化功能，那么会优先使用 AOF 文件来还原数据库状态</li><li>只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态</li></ul><hr><h4 id="自动保存">自动保存</h4><h5 id="配置文件">配置文件</h5><p>Redis 支持通过配置服务器的 save 选项，让服务器每隔一段时间自动执行一次 BGSAVE 命令</p><p>配置 redis.conf：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save second changes <span class="comment">#设置自动持久化条件，满足限定时间范围内key的变化数量就进行持久化(bgsave)</span></span><br></pre></td></tr></table></figure><ul><li>second：监控时间范围</li><li>changes：监控 key 的变化量</li></ul><p>默认三个条件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1<span class="comment"># 900s内1个key发生变化就进行持久化</span></span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>判定 key 变化的依据：</p><ul><li>对数据产生了影响，不包括查询</li><li>不进行数据比对，比如 name 键存在，重新 set name seazean 也算一次变化</li></ul><p>save 配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</p><hr><h5 id="自动原理">自动原理</h5><p>服务器状态相关的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间 </span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>Redis 服务器启动时，可以通过指定配置文件或者传入启动参数的方式设置 save 选项， 如果没有自定义就设置为三个默认值（上节提及），设置服务器状态 redisServe.saveparams 属性，该数组每一项为一个 saveparam 结构，代表 save 的选项设置</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">time_t</span> seconds</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>dirty 计数器记录距离上一次成功执行 SAVE 或者 BGSAVE 命令之后，服务器中的所有数据库进行了多少次修改（包括写入、删除、更新等操作），当服务器成功执行一个修改指令，该命令修改了多少次数据库， dirty 的值就增加多少</p></li><li><p>lastsave 属性是一个 UNIX 时间戳，记录了服务器上一次成功执行 SAVE 或者 BGSAVE 命令的时间</p></li></ul><p>Redis 的服务器周期性操作函数 serverCron 默认每隔 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护</p><p>serverCron 函数的其中一项工作是检查 save 选项所设置的保存条件是否满足，会遍历 saveparams 数组中的<strong>所有保存条件</strong>，只要有任意一个条件被满足服务器就会执行 BGSAVE 命令</p><p><img src="../image/post/Redis-BGSAVE%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt=""></p><hr><h4 id="文件结构">文件结构</h4><p>RDB 的存储结构：图示全大写单词标示常量，用全小写单词标示变量和数据</p><p><img src="../image/post/Redis-RDB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt=""></p><ul><li>REDIS：长度为 5 字节，保存着 <code>REDIS</code> 五个字符，是 RDB 文件的开头，在载入文件时可以快速检查所载入的文件是否 RDB 文件</li><li>db_version：长度为 4 字节，是一个用字符串表示的整数，记录 RDB 的版本号</li><li>database：包含着零个或任意多个数据库，以及各个数据库中的键值对数据</li><li>EOF：长度为 1 字节的常量，标志着 RDB 文件正文内容的结束，当读入遇到这个值时，代表所有数据库的键值对都已经载入完毕</li><li>check_sum：长度为 8 字节的无符号整数，保存着一个校验和，该值是通过 REDIS、db_version、databases、EOF 四个部分的内容进行计算得出。服务器在载入 RDB 文件时，会将载入数据所计算出的校验和与 check_sum 所记录的校验和进行对比，来检查 RDB 文件是否有出错或者损坏</li></ul><p>Redis 本身带有 RDB 文件检查工具 redis-check-dump</p><hr><h3 id="AOF">AOF</h3><h4 id="基本概述">基本概述</h4><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令（不记录读）来记录数据库状态，<strong>增量保存</strong>只许追加文件但不可以改写文件，<strong>与 RDB 相比可以理解为由记录数据改为记录数据的变化</strong></p><p>AOF 主要作用是解决了<strong>数据持久化的实时性</strong>，目前已经是 Redis 持久化的主流方式</p><p>AOF 写数据过程：</p><img src="../image/post/Redis-AOF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" style="zoom:67%;" /><hr><h4 id="持久实现">持久实现</h4><p>AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤</p><h5 id="命令追加">命令追加</h5><p>启动 AOF 的基本配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span>|no<span class="comment">#开启AOF持久化功能，默认no，即不开启状态</span></span><br><span class="line">appendfilename filename<span class="comment">#AOF持久化文件名，默认appendonly.aof，建议设置appendonly-端口号.aof</span></span><br><span class="line"><span class="built_in">dir</span><span class="comment">#AOF持久化文件保存路径，与RDB持久化文件路径保持一致即可</span></span><br></pre></td></tr></table></figure><p>当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的 aof_buf 缓冲区的末尾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// AOF 缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h5 id="文件写入">文件写入</h5><p>服务器在处理文件事件时可能会执行写命令，追加一些内容到 aof_buf 缓冲区里，所以服务器每次结束一个事件循环之前，就会执行 flushAppendOnlyFile 函数，判断是否需要<strong>将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件</strong>里</p><p>flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no<span class="comment">#AOF写数据策略：默认为everysec</span></span><br></pre></td></tr></table></figure><ul><li><p>always：每次写入操作都将 aof_buf 缓冲区中的所有内容<strong>写入并同步</strong>到 AOF 文件</p><p>特点：安全性最高，数据零误差，但是性能较低，不建议使用</p></li><li><p>everysec：先将 aof_buf 缓冲区中的内容写入到 AOF 文件，判断上次同步 AOF 文件的时间距离现在超过一秒钟，再次对 AOF 文件进行同步，这个同步操作是由一个（子）线程专门负责执行的</p><p>特点：在系统突然宕机的情况下丢失 1 秒内的数据，准确性较高，性能较高，建议使用，也是默认配置</p></li><li><p>no：将 aof_buf 缓冲区中的内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统来决定</p><p>特点：<strong>整体不可控</strong>，服务器宕机会丢失上次同步 AOF 后的所有写指令</p></li></ul><hr><h5 id="文件同步">文件同步</h5><p>在现代操作系统中，当用户调用 write 函数将数据写入文件时，操作系统通常会将写入数据暂时保存在一个内存缓冲区空间，等到缓冲区<strong>写满或者到达特定时间周期</strong>，才真正地将缓冲区中的数据写入到磁盘里面（刷脏）</p><ul><li>优点：提高文件的写入效率</li><li>缺点：为写入数据带来了安全问题，如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失</li></ul><p>系统提供了 fsync 和 fdatasync 两个同步函数做<strong>强制硬盘同步</strong>，可以让操作系统立即将缓冲区中的数据写入到硬盘里面，函数会阻塞到写入硬盘完成后返回，保证了数据持久化</p><p>异常恢复：AOF 文件损坏，通过 redis-check-aof–fix appendonly.aof 进行恢复，重启 Redis，然后重新加载</p><hr><h4 id="文件载入-2">文件载入</h4><p>AOF 文件里包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里的命令，就还原服务器关闭之前的数据库状态，服务器在启动时，还原数据库状态打印的日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[8321] 05 Sep 11:58:50.449 * DB loaded from append only file: 0.000 seconds </span><br></pre></td></tr></table></figure><p>AOF 文件里面除了用于指定数据库的 SELECT 命令是服务器自动添加的，其他都是通过客户端发送的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 2\r\n<span class="variable">$6</span>\r\nSELECT\r\n<span class="variable">$1</span>\r\n0\r\n<span class="comment"># 服务器自动添加</span></span><br><span class="line">* 3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nmsg\r\n<span class="variable">$5</span>\r\nhello\r\n</span><br><span class="line">* 5\r\n<span class="variable">$4</span>\r\nSADD\r\n<span class="variable">$6</span>\r\nfruits\r\n<span class="variable">$5</span>\r\napple\r\n<span class="variable">$6</span>\r\nbanana\r\n<span class="variable">$6</span>\r\ncherry\r\n</span><br></pre></td></tr></table></figure><p>Redis 读取 AOF 文件并还原数据库状态的步骤：</p><ul><li>创建一个<strong>不带网络连接的伪客户端</strong>（fake client）执行命令，因为 Redis 的命令只能在客户端上下文中执行， 而载入 AOF 文件时所使用的命令来源于本地 AOF 文件而不是网络连接</li><li>从 AOF 文件分析并读取一条写命令</li><li>使用伪客户端执行被读出的写命令，然后重复上述步骤</li></ul><hr><h4 id="重写实现">重写实现</h4><h5 id="重写策略">重写策略</h5><p>随着命令不断写入 AOF，文件会越来越大，很可能对 Redis 服务器甚至整个宿主计算机造成影响，为了解决这个问题 Redis 引入了 AOF 重写机制压缩文件体积</p><p>AOF 重写：读取服务器当前的数据库状态，<strong>生成新 AOF 文件来替换旧 AOF 文件</strong>，不会对现有的 AOF 文件进行任何读取、分析或者写入操作，而是直接原子替换。新 AOF 文件不会包含任何浪费空间的冗余命令，所以体积通常会比旧 AOF 文件小得多</p><p>AOF 重写规则：</p><ul><li><p>进程内具有时效性的数据，并且数据已超时将不再写入文件</p></li><li><p>对同一数据的多条写命令合并为一条命令，因为会读取当前的状态，所以直接将当前状态转换为一条命令即可。为防止数据量过大造成客户端缓冲区溢出，对 list、set、hash、zset 等集合类型，<strong>单条指令</strong>最多写入 64 个元素</p><p>如 lpushlist1 a、lpush list1 b、lpush list1 c 可以转化为：lpush list1 a b c</p></li><li><p>非写入类的无效指令将被忽略，只保留最终数据的写入命令，但是 select 指令虽然不更改数据，但是更改了数据的存储位置，此类命令同样需要记录</p></li></ul><p>AOF 重写作用：</p><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高 IO 性能</li><li>降低数据恢复的用时，提高数据恢复效率</li></ul><hr><h5 id="重写原理">重写原理</h5><p>AOF 重写程序 aof_rewrite 函数可以创建一个新 AOF 文件， 但是该函数会进行大量的写入操作，调用这个函数的线程将被长时间阻塞，所以 Redis 将 AOF 重写程序放到 fork 的子进程里执行，不会阻塞父进程，重写命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure><ul><li><p>子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理命令请求</p></li><li><p>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下， 保证数据的安全性</p><p><img src="../image/post/Redis-AOF%E6%89%8B%E5%8A%A8%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86.png" alt=""></p></li></ul><p>子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致，所以 Redis 设置了 AOF 重写缓冲区</p><p>工作流程：</p><ul><li>Redis 服务器执行完一个写命令，会同时将该命令追加到 AOF 缓冲区和 AOF 重写缓冲区（从创建子进程后才开始写入）</li><li>当子进程完成 AOF 重写工作之后，会向父进程发送一个信号，父进程在接到该信号之后， 会调用一个信号处理函数，该函数执行时会<strong>对服务器进程（父进程）造成阻塞</strong>（影响很小），主要工作：<ul><li>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中， 这时新 AOF 文件所保存的状态将和服务器当前的数据库状态一致</li><li>对新的 AOF 文件进行改名，<strong>原子地（atomic）覆盖</strong>现有的 AOF 文件，完成新旧两个 AOF 文件的替换</li></ul></li></ul><hr><h5 id="自动重写">自动重写</h5><p>触发时机：Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次重写后大小的一倍且文件大于 64M 时触发</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size<span class="comment">#设置重写的基准值，最小文件 64MB，达到这个值开始重写</span></span><br><span class="line">auto-aof-rewrite-percentage percent<span class="comment">#触发AOF文件执行重写的增长率，当前AOF文件大小超过上一次重写的AOF文件大小的百分之多少才会重写，比如文件达到 100% 时开始重写就是两倍时触发</span></span><br></pre></td></tr></table></figure><p>自动重写触发比对参数（ 运行指令 <code>info Persistence</code> 获取具体信息 ）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aof_current_size<span class="comment">#AOF文件当前尺寸大小（单位:字节）</span></span><br><span class="line">aof_base_size<span class="comment">#AOF文件上次启动和重写时的尺寸大小（单位:字节）</span></span><br></pre></td></tr></table></figure><p>自动重写触发条件公式：</p><ul><li>aof_current_size &gt; auto-aof-rewrite-min-size</li><li>(aof_current_size - aof_base_size) / aof_base_size &gt;= auto-aof-rewrite-percentage</li></ul><hr><h3 id="对比-2">对比</h3><p>RDB 的特点</p><ul><li><p>RDB 优点：</p><ul><li>RDB 是一个紧凑压缩的二进制文件，存储效率较高，但存储数据量较大时，存储效率较低</li><li>RDB 内部存储的是 Redis 在某个时间点的数据快照，非常<strong>适合用于数据备份，全量复制、灾难恢复</strong></li><li>RDB 恢复数据的速度要比 AOF 快很多，因为是快照，直接恢复</li></ul></li><li><p>RDB 缺点：</p><ul><li>BGSAVE 指令每次运行要执行 fork 操作创建子进程，会牺牲一些性能</li><li>RDB 方式无论是执行指令还是利用配置，无法做到实时持久化，具有丢失数据的可能性，最后一次持久化后的数据可能丢失</li><li>Redis 的众多版本中未进行 RDB 文件格式的版本统一，可能出现各版本之间数据格式无法兼容</li></ul></li></ul><p>AOF 特点：</p><ul><li>AOF 的优点：数据持久化有较好的实时性，通过 AOF 重写可以降低文件的体积</li><li>AOF 的缺点：文件较大时恢复较慢</li></ul><p>AOF 和 RDB 同时开启，系统默认取 AOF 的数据（数据不会存在丢失）</p><p>应用场景：</p><ul><li><p>对数据<strong>非常敏感</strong>，建议使用默认的 AOF 持久化方案，AOF 持久化策略使用 everysecond，每秒钟 fsync 一次，该策略 Redis 仍可以保持很好的处理性能</p><p>注意：AOF 文件存储体积较大，恢复速度较慢，因为要执行每条指令</p></li><li><p>数据呈现<strong>阶段有效性</strong>，建议使用 RDB 持久化方案，可以做到阶段内无丢失，且恢复速度较快</p><p>注意：利用 RDB 实现紧凑的数据持久化，存储数据量较大时，存储效率较低</p></li></ul><p>综合对比：</p><ul><li>RDB 与 AOF 的选择实际上是在做一种权衡，每种都有利有弊</li><li>灾难恢复选用 RDB</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用 AOF；如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用 RDB</li><li>双保险策略，同时开启 RDB 和 AOF，重启后 Redis 优先使用 AOF 来恢复数据，降低丢失数据的量</li><li>不建议单独用 AOF，因为可能会出现 Bug，如果只是做纯内存缓存，可以都不用</li></ul><hr><h3 id="fork">fork</h3><h4 id="介绍">介绍</h4><p>fork() 函数创建一个子进程，子进程与父进程几乎是完全相同的进程，系统先给子进程分配资源，然后把父进程的所有数据都复制到子进程中，只有少数值与父进程的值不同，相当于克隆了一个进程</p><p>在完成对其调用之后，会产生 2 个进程，且每个进程都会<strong>从 fork() 的返回处开始执行</strong>，这两个进程将执行相同的程序段，但是拥有各自不同的堆段，栈段，数据段，每个子进程都可修改各自的数据段，堆段，和栈段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 父进程返回子进程的pid，子进程返回0，错误返回负值，根据返回值的不同进行对应的逻辑处理</span></span><br></pre></td></tr></table></figure><p>fork 调用一次，却能够<strong>返回两次</strong>，可能有三种不同的返回值：</p><ul><li>在父进程中，fork 返回新创建子进程的进程 ID</li><li>在子进程中，fork 返回 0</li><li>如果出现错误，fork 返回一个负值，错误原因：<ul><li>当前的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN</li><li>系统内存不足，这时 errno 的值被设置为 ENOMEM</li></ul></li></ul><p>fpid 的值在父子进程中不同：进程形成了链表，父进程的 fpid 指向子进程的进程 id，因为子进程没有子进程，所以其 fpid 为0</p><p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的调度策略</p><p>每个进程都有一个独特（互不相同）的进程标识符 process ID，可以通过 getpid() 函数获得；还有一个记录父进程 pid 的变量，可以通过 getppid() 函数获得变量的值</p><hr><h4 id="使用">使用</h4><p>基本使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>   </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> fpid; <span class="comment">// fpid表示fork函数返回的值  </span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  </span><br><span class="line">    fpid = fork();   </span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>);   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the child process, my process id is %d/n&quot;</span>, getpid());    </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am the parent process, my process id is %d/n&quot;</span>, getpid());   </span><br><span class="line">        count++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count: %d/n&quot;</span>,count);<span class="comment">// 1  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* 输出内容：</span></span><br><span class="line"><span class="comment">    i am the child process, my process id is 5574</span></span><br><span class="line"><span class="comment">    count: 1</span></span><br><span class="line"><span class="comment">    i am the parent process, my process id is 5573</span></span><br><span class="line"><span class="comment">    count: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>进阶使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">   <span class="comment">// ppid 指当前进程的父进程pid  </span></span><br><span class="line">   <span class="comment">// pid 指当前进程的pid,  </span></span><br><span class="line">   <span class="comment">// fpid 指fork返回给当前进程的值，在这可以表示子进程</span></span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;  </span><br><span class="line">       <span class="type">pid_t</span> fpid = fork();  </span><br><span class="line">       <span class="keyword">if</span>(fpid == <span class="number">0</span>)  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d child  %4d %4d %4d/n&quot;</span>,i, getppid(), getpid(), fpid);  </span><br><span class="line">       <span class="keyword">else</span>  </span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d parent %4d %4d %4d/n&quot;</span>,i, getppid(), getpid(),fpid);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*输出内容：</span></span><br><span class="line"><span class="comment">i        父id  id  子id</span></span><br><span class="line"><span class="comment">0 parent 2043 3224 3225</span></span><br><span class="line"><span class="comment">    0 child  3224 3225    0</span></span><br><span class="line"><span class="comment">    1 parent 2043 3224 3226</span></span><br><span class="line"><span class="comment">    1 parent 3224 3225 3227</span></span><br><span class="line"><span class="comment">    1 child     1 3227    0</span></span><br><span class="line"><span class="comment">    1 child     1 3226    0 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="../image/post/Redis-fork%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%BC%94%E7%A4%BA.png" style="zoom: 80%;" /><p>在 p3224 和 p3225 执行完第二个循环后，main 函数退出，进程死亡。所以 p3226，p3227 就没有父进程了，成为孤儿进程，所以 p3226 和 p3227 的父进程就被置为 ID 为 1的 init 进程（笔记 Tool → Linux → 进程管理详解）</p><p>参考文章：<a href="https://blog.csdn.net/love_gaohz/article/details/41727415">https://blog.csdn.net/love_gaohz/article/details/41727415</a></p><hr><h4 id="内存-2">内存</h4><p>fork() 调用之后父子进程的内存关系</p><p>早期 Linux 的 fork() 实现时，就是全部复制，这种方法效率太低，而且造成了很大的内存浪费，现在 Linux 实现采用了两种方法：</p><ul><li><p>父子进程的代码段是相同的，所以代码段是没必要复制的，只需内核将代码段标记为只读，父子进程就共享此代码段。fork() 之后在进程创建代码段时，子进程的进程级页表项都指向和父进程相同的物理页帧</p>  <img src="../image/post/Redis-fork%E4%BB%A5%E5%90%8E%E5%86%85%E5%AD%98%E5%85%B3%E7%B3%BB1.png" style="zoom: 67%;" /></li><li><p>对于父进程的数据段，堆段，栈段中的各页，由于父子进程相互独立，采用<strong>写时复制 COW</strong> 的技术，来提高内存以及内核的利用率</p><p>在 fork 之后两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，<strong>两者的虚拟空间不同，但其对应的物理空间是同一个</strong>，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。如果两者的代码完全相同，代码段继续共享父进程的物理空间；而如果两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p><p>fork 之后内核会将子进程放在队列的前面，让子进程先执行，以免父进程执行导致写时复制，而后子进程再执行，因无意义的复制而造成效率的下降</p>  <img src="../image/post/Redis-fork%E4%BB%A5%E5%90%8E%E5%86%85%E5%AD%98%E5%85%B3%E7%B3%BB2.png" style="zoom:67%;" /></li></ul><p>补充知识：</p><p>vfork（虚拟内存 fork virtual memory fork）：调用 vfork() 父进程被挂起，子进程使用父进程的地址空间。不采用写时复制，如果子进程修改父地址空间的任何页面，这些修改过的页面对于恢复的父进程是可见的</p><p>参考文章：<a href="https://blog.csdn.net/Shreck66/article/details/47039937">https://blog.csdn.net/Shreck66/article/details/47039937</a></p><hr><h2 id="事务机制">事务机制</h2><h3 id="基本操作">基本操作</h3><p>Redis 事务的主要作用就是串联多个命令防止别的命令插队</p><ul><li><p>开启事务</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi<span class="comment">#设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</span></span><br></pre></td></tr></table></figure></li><li><p>执行事务</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span><span class="comment">#设定事务的结束位置，同时执行事务，与multi成对出现，成对使用</span></span><br></pre></td></tr></table></figure><p>加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行 exec 命令才开始执行</p></li><li><p>取消事务</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard<span class="comment">#终止当前事务的定义，发生在multi之后，exec之前</span></span><br></pre></td></tr></table></figure><p>一般用于事务执行过程中输入了错误的指令，直接取消这次事务，类似于回滚</p></li></ul><p>Redis 事务的三大特性：</p><ul><li>Redis 事务是一个单独的隔离操作，将一系列预定义命令包装成一个整体（一个队列），当执行时按照添加顺序依次执行，中间不会被打断或者干扰</li><li>Redis 事务<strong>没有隔离级别</strong>的概念，队列中的命令在事务没有提交之前都不会实际被执行</li><li>Redis 单条命令式保存原子性的，但是事务<strong>不保证原子性</strong>，事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul><hr><h3 id="工作流程">工作流程</h3><p>事务机制整体工作流程：</p><p><img src="../image/post/image-20240707155933038.png" alt="image-20240707155933038"></p><p>几种常见错误：</p><ul><li><p>定义事务的过程中，命令格式输入错误，出现语法错误造成，<strong>整体事务中所有命令均不会执行</strong>，包括那些语法正确的命令</p></li><li><p>定义事务的过程中，命令执行出现错误，例如对字符串进行 incr 操作，能够正确运行的命令会执行，运行错误的命令不会被执行</p></li><li><p>已经执行完毕的命令对应的数据不会自动回滚，需要程序员在代码中实现回滚，应该尽可能避免：</p><p>事务操作之前记录数据的状态</p><ul><li>单数据：string</li><li>多数据：hash、list、set、zset</li></ul><p>设置指令恢复所有的被修改的项</p><ul><li>单数据：直接 set（注意周边属性，例如时效）</li><li>多数据：修改对应值或整体克隆复制</li></ul></li></ul><hr><h3 id="监控锁">监控锁</h3><p>对 key 添加监视锁，是一种乐观锁，在执行 exec 前如果其他客户端的操作导致 key 发生了变化，执行结果为 nil</p><ul><li><p>添加监控锁</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch key1 [key2……]<span class="comment">#可以监控一个或者多个key</span></span><br></pre></td></tr></table></figure></li><li><p>取消对所有 key 的监视</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br></pre></td></tr></table></figure></li></ul><p>应用：基于状态控制的批量任务执行，防止其他线程对变量的修改</p><hr><h2 id="内存淘汰">内存淘汰</h2><h3 id="逐出算法">逐出算法</h3><p>数据淘汰策略：当新数据进入 Redis 时，在执行每一个命令前，会调用 <strong>freeMemoryIfNeeded()</strong> 检测内存是否充足。如果内存不满足新加入数据的最低存储要求，Redis 要临时删除一些数据为当前指令清理存储空间，清理数据的策略称为<strong>逐出算法</strong></p><p>逐出数据的过程不是 100% 能够清理出足够的可使用的内存空间，如果不成功则反复执行，当对所有数据尝试完毕，如不能达到内存清理的要求，<strong>出现 Redis 内存打满异常</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) OOM <span class="built_in">command</span> not allowed when used memory &gt;<span class="string">&#x27;maxmemory&#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="策略配置">策略配置</h3><p>Redis 如果不设置最大内存大小或者设置最大内存大小为 0，在 64 位操作系统下不限制内存大小，在 32 位操作系统默认为 3GB 内存，一般推荐设置 Redis 内存为最大物理内存的四分之三</p><p>内存配置方式：</p><ul><li><p>通过修改文件配置（永久生效）：修改配置文件 maxmemory 字段，单位为字节</p></li><li><p>通过命令修改（重启失效）：</p><ul><li><p><code>config set maxmemory 104857600</code>：设置 Redis 最大占用内存为 100MB</p></li><li><p><code>config get maxmemory</code>：获取 Redis 最大占用内存</p></li><li><p><code>info</code> ：可以查看 Redis 内存使用情况，<code>used_memory_human</code> 字段表示实际已经占用的内存，<code>maxmemory</code> 表示最大占用内存</p></li></ul></li></ul><p>影响数据淘汰的相关配置如下，配置 conf 文件：</p><ul><li><p>每次选取待删除数据的个数，采用随机获取数据的方式作为待检测删除数据，防止全库扫描，导致严重的性能消耗，降低读写性能</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples count</span><br></pre></td></tr></table></figure></li><li><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy policy</span><br></pre></td></tr></table></figure><p>数据删除的策略 policy：3 类 8 种</p><p>第一类：检测易失数据（可能会过期的数据集 server.db[i].expires）：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volatile-lru<span class="comment"># 对设置了过期时间的 key 选择最近最久未使用使用的数据淘汰</span></span><br><span class="line">volatile-lfu<span class="comment"># 对设置了过期时间的 key 选择最近使用次数最少的数据淘汰</span></span><br><span class="line">volatile-ttl<span class="comment"># 对设置了过期时间的 key 选择将要过期的数据淘汰</span></span><br><span class="line">volatile-random<span class="comment"># 对设置了过期时间的 key 选择任意数据淘汰</span></span><br></pre></td></tr></table></figure><p>第二类：检测全库数据（所有数据集 server.db[i].dict ）：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">allkeys-lru<span class="comment"># 对所有 key 选择最近最少使用的数据淘汰</span></span><br><span class="line">allkeLyRs-lfu<span class="comment"># 对所有 key 选择最近使用次数最少的数据淘汰</span></span><br><span class="line">allkeys-random<span class="comment"># 对所有 key 选择任意数据淘汰，相当于随机</span></span><br></pre></td></tr></table></figure><p>第三类：放弃数据驱逐</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no-enviction<span class="comment">#禁止驱逐数据(redis4.0中默认策略)，会引发OOM(Out Of Memory)</span></span><br></pre></td></tr></table></figure></li></ul><p>数据淘汰策略配置依据：使用 INFO 命令输出监控信息，查询缓存 hit 和 miss 的次数，根据需求调优 Redis 配置</p><hr><h2 id="缓存方案">缓存方案</h2><h3 id="缓存模式">缓存模式</h3><h4 id="旁路缓存">旁路缓存</h4><p>缓存本质：弥补 CPU 的高算力和 IO 的慢读写之间巨大的鸿沟</p><p>旁路缓存模式 Cache Aside Pattern 是平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景</p><p>Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准</p><ul><li>写操作：先更新 DB，然后直接删除 cache</li><li>读操作：从 cache 中读取数据，读取到就直接返回；读取不到就从 DB 中读取数据返回，并放到 cache</li></ul><p>时序导致的不一致问题：</p><ul><li><p>在写数据的过程中，不能先删除 cache 再更新 DB，因为会造成缓存的不一致。比如请求 1 先写数据 A，请求 2 随后读数据 A，当请求 1 删除 cache 后，请求 2 直接读取了 DB，此时请求 1 还没写入 DB（延迟双删）</p></li><li><p>在写数据的过程中，先更新 DB 再删除 cache 也会出现问题，但是概率很小，因为缓存的写入速度非常快</p></li></ul><p>旁路缓存的缺点：</p><ul><li>首次请求数据一定不在 cache 的问题，一般采用缓存预热的方法，将热点数据可以提前放入 cache 中</li><li>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，影响缓存命中率</li></ul><hr><h4 id="读写穿透">读写穿透</h4><p>读写穿透模式 Read/Write Through Pattern：服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中，cache 负责将此数据同步写入 DB，从而减轻了应用程序的职责</p><ul><li><p>写操作：先查 cache，cache 中不存在，直接更新 DB；cache 中存在则先更新 cache，然后 cache 服务更新 DB（同步更新 cache 和 DB）</p></li><li><p>读操作：从 cache 中读取数据，读取到就直接返回 ；读取不到先从 DB 加载，写入到 cache 后返回响应</p><p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，对客户端是透明的</p></li></ul><p>Read-Through Pattern 也存在首次不命中的问题，采用缓存预热解决</p><hr><h4 id="异步缓存">异步缓存</h4><p>异步缓存写入 Write Behind Pattern 由 cache 服务来负责 cache 和 DB 的读写，对比读写穿透不同的是 Write Behind Caching 是只更新缓存，不直接更新 DB，改为<strong>异步批量</strong>的方式来更新 DB，可以减小写的成本</p><p>缺点：这种模式对数据一致性没有高要求，可能出现 cache 还没异步更新 DB，服务就挂掉了</p><p>应用：</p><ul><li><p>DB 的写性能非常高，适合一些数据经常变化又对数据一致性要求不高的场景，比如浏览量、点赞量</p></li><li><p>MySQL 的 InnoDB Buffer Pool 机制用到了这种策略</p></li></ul><hr><h3 id="缓存一致">缓存一致</h3><p>使用缓存代表不需要强一致性，只需要最终一致性</p><p>缓存不一致的方法：</p><ul><li>数据库和缓存数据强一致场景：<ul><li>更新 DB 时同样更新 cache，加一个锁来保证更新 cache 时不存在线程安全问题，这样可以增加命中率</li><li>延迟双删：先淘汰缓存再写数据库，休眠 1 秒再次淘汰缓存，可以将 1 秒内造成的缓存脏数据再次删除</li><li>CDC 同步：通过 canal 订阅 MySQL binlog 的变更上报给 Kafka，系统监听 Kafka 消息触发缓存失效</li></ul></li><li>可以短暂允许数据库和缓存数据不一致场景：更新 DB 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样就可以保证即使数据不一致影响也比较小</li></ul><p>参考文章：<a href="http://cccboke.com/archives/2020-09-30-21-29-56">http://cccboke.com/archives/2020-09-30-21-29-56</a></p><hr><h3 id="企业方案">企业方案</h3><h4 id="缓存预热">缓存预热</h4><p>场景：宕机，服务器启动后迅速宕机</p><p>问题排查：</p><ol><li><p>请求数量较高，大量的请求过来之后都需要去从缓存中获取数据，但是缓存中又没有，此时从数据库中查找数据然后将数据再存入缓存，造成了短期内对 redis 的高强度操作从而导致问题</p></li><li><p>主从之间数据吞吐量较大，数据同步操作频度较高</p></li></ol><p>解决方案：</p><ul><li><p>前置准备工作：</p><ol><li><p>日常例行统计数据访问记录，统计访问频度较高的热点数据</p></li><li><p>利用 LRU 数据删除策略，构建数据留存队列例如：storm 与 kafka 配合</p></li></ol></li><li><p>准备工作：</p><ol><li><p>将统计结果中的数据分类，根据级别，redis 优先加载级别较高的热点数据</p></li><li><p>利用分布式多服务器同时进行数据读取，提速数据加载过程</p></li><li><p>热点数据主从同时预热</p></li></ol></li><li><p>实施：</p><ol start="4"><li><p>使用脚本程序固定触发数据预热过程</p></li><li><p>如果条件允许，使用了 CDN（内容分发网络），效果会更好</p></li></ol></li></ul><p>总的来说：缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据！</p><hr><h4 id="缓存雪崩">缓存雪崩</h4><p>场景：数据库服务器崩溃，一连串的问题会随之而来</p><p>问题排查：在一个较短的时间内，<strong>缓存中较多的 key 集中过期</strong>，此周期内请求访问过期的数据 Redis 未命中，Redis 向数据库获取数据，数据库同时收到大量的请求无法及时处理。</p><p>解决方案：</p><ol><li>加锁，慎用</li><li>设置热点数据永远不过期，如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</li><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li><li>构建<strong>多级缓存</strong>架构，Nginx 缓存 + Redis 缓存 + ehcache 缓存</li><li>灾难预警机制，监控 Redis 服务器性能指标，CPU 使用率、内存容量、平均响应时间、线程数</li><li>限流、降级：短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ol><p>总的来说：缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约 40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p><hr><h4 id="缓存击穿">缓存击穿</h4><p>场景：系统平稳运行过程中，数据库连接量瞬间激增，Redis 服务器无大量 key 过期，Redis 内存平稳无波动，Redis 服务器 CPU 正常，但是数据库崩溃</p><p>问题排查：</p><ol><li><p><strong>Redis 中某个 key 过期，该 key 访问量巨大</strong></p></li><li><p>多个数据请求从服务器直接压到 Redis 后，均未命中</p></li><li><p>Redis 在短时间内发起了大量对数据库中同一数据的访问</p></li></ol><p>简而言之两点：单个 key 高热数据，key 过期</p><p>解决方案：</p><ol><li><p>预先设定：以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息 key 的过期时长 注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p></li><li><p>现场调整：监控访问量，对自然流量激增的数据<strong>延长过期时间或设置为永久性 key</strong></p></li><li><p>后台刷新数据：启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</p></li><li><p><strong>二级缓存</strong>：设置不同的失效时间，保障不会被同时淘汰就行</p></li><li><p>加锁：分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重</p></li></ol><p>总的来说：缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中 Redis 后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个 key 的过期监控难度较高，配合雪崩处理策略即可</p><hr><h4 id="缓存穿透">缓存穿透</h4><p>场景：系统平稳运行过程中，应用服务器流量随时间增量较大，Redis 服务器命中率随时间逐步降低，Redis 内存平稳，内存无压力，Redis 服务器 CPU 占用激增，数据库服务器压力激增，数据库崩溃</p><p>问题排查：</p><ol><li><p>Redis 中大面积出现未命中</p></li><li><p>出现非正常 URL 访问</p></li></ol><p>问题分析：</p><ul><li>访问了不存在的数据，跳过了 Redis 缓存，数据库页查询不到对应数据</li><li>Redis 获取到 null 数据未进行持久化，直接返回</li><li>出现黑客攻击服务器</li></ul><p>解决方案：</p><ol><li><p>缓存 null：对查询结果为 null 的数据进行缓存，设定短时限，例如 30-60 秒，最高 5 分钟</p></li><li><p>白名单策略：提前预热各种分类<strong>数据 id 对应的 bitmaps</strong>，id 作为 bitmaps 的 offset，相当于设置了数据白名单。当加载正常数据时放行，加载异常数据时直接拦截（效率偏低），也可以使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</p></li><li><p>实时监控：实时监控 Redis 命中率（业务正常范围时，通常会有一个波动值）与 null 数据的占比</p><ul><li>非活动时段波动：通常检测 3-5 倍，超过 5 倍纳入重点排查对象</li><li>活动时段波动：通常检测10-50 倍，超过 50 倍纳入重点排查对象</li></ul><p>根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控</p></li><li><p>key 加密：临时启动防灾业务 key，对 key 进行业务层传输加密服务，设定校验程序，过来的 key 校验；例如每天随机分配 60 个加密串，挑选 2 到 3 个，混淆到页面数据 id 中，发现访问 key 不满足规则，驳回数据访问</p></li></ol><p>总的来说：缓存击穿是指访问了不存在的数据，跳过了合法数据的 Redis 数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除</p><p>参考视频：<a href="https://www.bilibili.com/video/BV15y4y1r7X3">https://www.bilibili.com/video/BV15y4y1r7X3</a></p><hr><h3 id="性能指标">性能指标</h3><p>Redis 中的监控指标如下：</p><ul><li><p>性能指标：Performance</p><p>响应请求的平均时间：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latency</span><br></pre></td></tr></table></figure><p>平均每秒处理请求总数：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instantaneous_ops_per_sec</span><br></pre></td></tr></table></figure><p>缓存查询命中率（通过查询总次数与查询得到非nil数据总次数计算而来）：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hit_rate(calculated)</span><br></pre></td></tr></table></figure></li><li><p>内存指标：Memory</p><p>当前内存使用量：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">used_memory</span><br></pre></td></tr></table></figure><p>内存碎片率（关系到是否进行碎片整理）：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mem_fragmentation_ratio</span><br></pre></td></tr></table></figure><p>为避免内存溢出删除的key的总数量：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evicted_keys</span><br></pre></td></tr></table></figure><p>基于阻塞操作（BLPOP等）影响的客户端数量：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blocked_clients</span><br></pre></td></tr></table></figure></li><li><p>基本活动指标：Basic_activity</p><p>当前客户端连接总数：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connected_clients</span><br></pre></td></tr></table></figure><p>当前连接 slave 总数：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connected_slaves</span><br></pre></td></tr></table></figure><p>最后一次主从信息交换距现在的秒：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_last_io_seconds_ago</span><br></pre></td></tr></table></figure><p>key 的总数：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyspace</span><br></pre></td></tr></table></figure></li><li><p>持久性指标：Persistence</p><p>当前服务器其最后一次 RDB 持久化的时间：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdb_last_save_time</span><br></pre></td></tr></table></figure><p>当前服务器最后一次 RDB 持久化后数据变化总量：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdb_changes_since_last_save</span><br></pre></td></tr></table></figure></li><li><p>错误指标：Error</p><p>被拒绝连接的客户端总数（基于达到最大连接值的因素）：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rejected_connections</span><br></pre></td></tr></table></figure><p>key未命中的总次数：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyspace_misses</span><br></pre></td></tr></table></figure><p>主从断开的秒数：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_link_down_since_seconds</span><br></pre></td></tr></table></figure></li></ul><p>要对 Redis 的相关指标进行监控，我们可以采用一些用具：</p><ul><li>CloudInsight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix</li></ul><p>命令工具：</p><ul><li><p>benchmark</p><p>测试当前服务器的并发性能：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span><br></pre></td></tr></table></figure><p>范例：100 个连接，5000 次请求对应的性能</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -c 100 -n 5000</span><br></pre></td></tr></table></figure></li><li><p>redis-cli</p><p>monitor：启动服务器调试信息</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor</span><br></pre></td></tr></table></figure><p>slowlog：慢日志</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slowlog [operator]    <span class="comment">#获取慢查询日志</span></span><br></pre></td></tr></table></figure><ul><li>get ：获取慢查询日志信息</li><li>len ：获取慢查询日志条目数</li><li>reset ：重置慢查询日志</li></ul><p>相关配置：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 1000 <span class="comment">#设置慢查询的时间下线，单位：微妙</span></span><br><span class="line">slowlog-max-len 100<span class="comment">#设置慢查询命令对应的日志显示长度，单位：命令数</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="分布式锁">分布式锁</h2><blockquote><p>参考文章：<a href="https://www.pdai.tech/md/arch/arch-z-lock.html#%E5%9F%BA%E4%BA%8Eredis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7">https://www.pdai.tech/md/arch/arch-z-lock.html#基于redis如何实现分布式锁-有什么缺陷</a></p></blockquote><h3 id="基本操作-2">基本操作</h3><p>由于分布式系统多线程并发分布在不同机器上，这将使单机部署情况下的并发控制锁策略失效，需要分布式锁</p><p>Redis 分布式锁的基本使用，悲观锁</p><ul><li><p>使用 setnx 设置一个公共锁</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx lock-key value<span class="comment"># value任意数，返回为1设置成功，返回为0设置失败</span></span><br></pre></td></tr></table></figure><ul><li>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</li><li>对于返回设置失败的，不具有控制权，排队或等待</li></ul><p><code>NX</code>：只在键不存在时，才对键进行设置操作，<code>SET key value NX</code> 效果等同于 <code>SETNX key value</code></p><p><code>XX</code> ：只在键已经存在时，才对键进行设置操作</p><p><code>EX</code>：设置键 key 的过期时间，单位时秒</p><p><code>PX</code>：设置键 key 的过期时间，单位时毫秒</p><p>说明：由于 <code>SET</code> 命令加上选项已经可以完全取代 SETNX、SETEX、PSETEX 的功能，Redis 不推荐使用这几个命令</p></li><li><p>操作完毕通过 del 操作释放锁</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del lock-key </span><br></pre></td></tr></table></figure></li><li><p>使用 expire 为锁 key 添加存活（持有）时间，过期自动删除（放弃）锁</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key second </span><br><span class="line">pexpire lock-key milliseconds</span><br></pre></td></tr></table></figure><p>通过 expire 设置过期时间缺乏原子性，如果在 setnx 和 expire 之间出现异常，锁也无法释放</p></li><li><p>在 set 时指定过期时间</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds | PX milliseconds] NX</span><br></pre></td></tr></table></figure></li></ul><p>应用：解决抢购时出现超卖现象</p><hr><h3 id="防误删">防误删</h3><p>setnx 获取锁时，设置一个指定的唯一值（uuid），释放前获取这个值，判断是否自己的锁，防止出现线程之间误删了其他线程的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁, unique_value作为客户端唯一性的标识</span></span><br><span class="line">SET lock_key unique_value NX PX <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>unique_value 是客户端的<strong>唯一标识</strong>，可以用一个随机生成的字符串来表示，PX 10000 则表示 lock_key 会在 10s 后过期，以免客户端在这期间发生异常而无法释放锁</p><hr><h2 id="redission（watchdog-lock-tryLock-jedis）">redission（watchdog/lock/tryLock/jedis）</h2><blockquote><p>参考文章：<a href="https://javaguide.cn/distributed-system/distributed-lock-implementations.html#%E5%9F%BA%E4%BA%8E-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">https://javaguide.cn/distributed-system/distributed-lock-implementations.html#基于-redis-实现分布式锁</a></p></blockquote><hr><h2 id="key过期（过期删除）">key过期（过期删除）</h2><h3 id="删除策略">删除策略</h3><p>删除策略就是<strong>针对已过期数据的处理策略</strong>，已过期的数据不一定被立即删除，在不同的场景下使用不同的删除方式会有不同效果，在内存占用与 CPU 占用之间寻找一种平衡，顾此失彼都会造成整体 Redis 性能的下降，甚至引发服务器宕机或内存泄露</p><p>针对过期数据有三种删除策略：</p><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><p><strong>Redis 采用<code>惰性删除</code>和<code>定期删除</code>策略的<code>结合使用</code></strong></p><hr><h3 id="定时删除">定时删除</h3><p>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间到达时，立即执行对键的删除操作</p><ul><li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：对 CPU 不友好，无论 CPU 此时负载多高均占用 CPU，会影响 Redis 服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间（拿时间换空间）</li></ul><p>创建一个定时器需要用到 Redis 服务器中的时间事件，而时间事件的实现方式是无序链表，查找一个事件的时间复杂度为 O(N)，并不能高效地处理大量时间事件，所以采用这种方式并不现实</p><hr><h3 id="惰性删除">惰性删除</h3><p>数据到达过期时间不做处理，等下次访问到该数据时执行 <strong>expireIfNeeded()</strong> 判断：</p><ul><li>如果输入键已经过期，那么 expireIfNeeded 函数将输入键从数据库中删除，接着访问就会返回空</li><li>如果输入键未过期，那么 expireIfNeeded 函数不做动作</li></ul><p>所有的 Redis 读写命令在执行前都会调用 expireIfNeeded 函数进行检查，该函数就像一个过滤器，在命令真正执行之前过滤掉过期键</p><p>惰性删除的特点：</p><ul><li>优点：节约 CPU 性能，删除的目标仅限于当前处理的键，不会在删除其他无关的过期键上花费任何 CPU 时间</li><li>缺点：内存压力很大，出现长期占用内存的数据，如果过期键永远不被访问，这种情况相当于内存泄漏</li><li>总结：用存储空间换取处理器性能（拿空间换时间）</li></ul><hr><h3 id="定期删除">定期删除</h3><p>定期删除策略是每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响</p><ul><li>如果删除操作执行得太频繁，或者执行时间太长，就会退化成定时删除策略，将 CPU 时间过多地消耗在删除过期键上</li><li>如果删除操作执行得太少，或者执行时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况</li></ul><p>所以采用定期删除策略的话，服务器必须根据情况合理地设置删除操作的执行时长和执行频率</p><p>定期删除是<strong>周期性轮询 Redis 库中的时效性</strong>数据，从过期字典中随机抽取一部分键检查，利用过期数据占比的方式控制删除频度</p><ul><li><p>Redis 启动服务器初始化时，读取配置 server.hz 的值，默认为 10，执行指令 info server 可以查看，每秒钟执行 server.hz 次 <code>serverCron() → activeExpireCycle()</code></p></li><li><p>activeExpireCycle() 对某个数据库中的每个 expires 进行检测，工作模式：</p><ul><li><p>轮询每个数据库，从数据库中取出一定数量的随机键进行检查，并删除其中的过期键</p></li><li><p>全局变量 current_db 用于记录 activeExpireCycle() 的检查进度（哪一个数据库），下一次调用时接着该进度处理</p></li><li><p>随着函数的不断执行，服务器中的所有数据库都会被检查一遍，这时将 current_db 重置为 0，然后再次开始新一轮的检查</p></li></ul></li></ul><p>定期删除特点：</p><ul><li>CPU 性能占用设置有峰值，检测频度可自定义设置</li><li>内存压力不是很大，长期占用内存的<strong>冷数据会被持续清理</strong></li><li>周期性抽查存储空间（随机抽查，重点抽查）</li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> DataBase </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Redis初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W-nextTick 和 async await</title>
      <link href="/posts/288ab87b.html"/>
      <url>/posts/288ab87b.html</url>
      
        <content type="html"><![CDATA[<h1>$nextTick</h1><h2 id="nextTick-和-async-await">$nextTick 和 async await</h2><p>this.$nextTick 和 async/await 在Vue中都是用于处理异步操作的重要工具，但它们服务于不同的目的和场景。</p><h2 id="nextTick-使用场景">$nextTick 使用场景</h2><p>nextTick是vue提供出来更新视图之后回调的函数，也就是说我们在操作dom更新视图的时候，由于vue的视图渲染是异步的，可能会导致一些视图已经更新了，但是我们获取到的视图数据信息不是最新的，使用nextTick可以保证视图在下一次更新之后进行调用</p><p>参考文章：<a href="https://cloud.tencent.com/developer/article/2008569">https://cloud.tencent.com/developer/article/2008569</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W-vue中的this指向</title>
      <link href="/posts/9619dfa9.html"/>
      <url>/posts/9619dfa9.html</url>
      
        <content type="html"><![CDATA[<h1>vue中的this指向</h1><h1>this指向</h1><p><strong>js：</strong></p><ul><li>普通函数，谁调用的它，this就指向谁，</li><li>箭头函数没有this，它的this指向一般就是上下文中，与谁调用它没关系。</li></ul><p><strong>vue：</strong></p><ul><li>methods、生命周期函数中如果用的是正常函数，那么它的this就指向<strong>Vue实例</strong>；</li><li>如果是箭头函数，在非严格模式下this就指向window对象，严格模式下是undefind。</li></ul><p>原因：vue 内部实际上对methods属性中的方法进行了遍历，将对应的方法通过bind绑定了this，使得this指向Vue实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue1.vue</span></span><br><span class="line">...</span><br><span class="line"><span class="title function_">function1</span>() &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">xxx</span>=xxx;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2.vue</span></span><br><span class="line">...</span><br><span class="line"><span class="title function_">function2</span>(function1) &#123;</span><br><span class="line">  <span class="title function_">function1</span>();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2调用function1()时，this扔指向vue1，不指向vue2</span></span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://juejin.cn/post/7109889547537743886"><strong>https://juejin.cn/post/7109889547537743886</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 工作inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBase-MyBatis初级学习</title>
      <link href="/posts/a8bbac52.html"/>
      <url>/posts/a8bbac52.html</url>
      
        <content type="html"><![CDATA[<h1>MyBatis初级</h1><h2 id="目标">目标</h2><ol><li>优点</li><li># 和 $</li><li>插件机制</li><li>缓存机制</li><li>连接池</li><li>动态SQL</li><li>分页</li><li>MyBatisPlus</li></ol><h2 id="基本介绍">基本介绍</h2><p>ORM（Object Relational Mapping）： 对象关系映射，指的是持久化数据和实体对象的映射模式，解决面向对象与关系型数据库存在的互不匹配的现象</p><p><img src="../image/post/MyBatis-ORM%E4%BB%8B%E7%BB%8D.png" alt=""></p><p><strong>MyBatis</strong>：</p><ul><li><p>MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 Statement 等过程。</p></li><li><p>MyBatis 通过 XML 或注解的方式将要执行的各种 Statement 配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句。</p></li><li><p>MyBatis 框架执行 SQL 并将结果映射为 Java 对象并返回。采用 ORM 思想解决了实体和数据库映射的问题，对 JDBC 进行了封装，屏蔽了 JDBC 底层 API 的调用细节，使我们不用操作 JDBC API，就可以完成对数据库的持久化操作。</p></li></ul><h2 id="和">#{}和${}</h2><p><strong>#{}：<strong>占位符，传入的内容会作为字符串</strong>加上引号</strong>，以<strong>预编译</strong>的方式传入，将 sql 中的 #{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值，有效的防止 SQL 注入，提高系统安全性</p><p><strong>${}：<strong>拼接符，传入的内容会</strong>直接替换</strong>拼接，不会加上引号，可能存在 sql 注入的安全隐患</p><ul><li><p>能用 #{} 的地方就用 #{}，不用或少用 ${}</p></li><li><p>必须使用 ${} 的情况：</p><ul><li>表名作参数时，如：<code>SELECT * FROM $&#123;tableName&#125;</code></li><li>order by 时，如：<code>SELECT * FROM t_user ORDER BY $&#123;columnName&#125;</code></li></ul></li><li><p>sql 语句使用 #{}，properties 文件内容获取使用 ${}</p></li></ul><h2 id="缓存机制">缓存机制</h2><h3 id="缓存概述">缓存概述</h3><p>缓存：缓存就是一块内存空间，保存临时数据</p><p>作用：将数据源（数据库或者文件）中的数据读取出来存放到缓存中，再次获取时直接从缓存中获取，可以减少和数据库交互的次数，提升程序的性能</p><p>缓存适用：</p><ul><li>适用于缓存的：经常查询但不经常修改的，数据的正确与否对最终结果影响不大的</li><li>不适用缓存的：经常改变的数据 , 敏感数据（例如：股市的牌价，银行的汇率，银行卡里面的钱）等等</li></ul><p>缓存类别：</p><ul><li>一级缓存：SqlSession 级别的缓存，又叫本地会话缓存，自带的（不需要配置），一级缓存的生命周期与 SqlSession 一致。在操作数据库时需要构造 SqlSession 对象，<strong>在对象中有一个数据结构（HashMap）用于存储缓存数据</strong>，不同的 SqlSession 之间的缓存数据区域是互相不影响的</li><li>二级缓存：mapper（namespace）级别的缓存，二级缓存的使用，需要手动开启（需要配置）。多个 SqlSession 去操作同一个 Mapper 的 SQL 可以共用二级缓存，二级缓存是跨 SqlSession 的</li></ul><p>开启缓存：配置核心配置文件中 <settings> 标签</p><ul><li>cacheEnabled：true 表示全局性地开启所有映射器配置文件中已配置的任何缓存，默认 true</li></ul><p><img src="../image/post/MyBatis-%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p><p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7342498.html">https://www.cnblogs.com/ysocean/p/7342498.html</a></p><hr><h3 id="一级缓存">一级缓存</h3><p>一级缓存是 SqlSession 级别的缓存</p><img src="../image/post/MyBatis-%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98.png" style="zoom: 67%;" /><p>工作流程：第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息，得到用户信息，将用户信息存储到一级缓存中；第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。</p><p>一级缓存的失效：</p><ul><li>SqlSession 不同</li><li>SqlSession 相同，查询条件不同时（还未缓存该数据）</li><li>SqlSession 相同，手动清除了一级缓存，调用 <code>sqlSession.clearCache()</code></li><li>SqlSession 相同，执行 commit 操作或者执行插入、更新、删除，清空 SqlSession 中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，<strong>避免脏读</strong></li></ul><p>Spring 整合 MyBatis 后，一级缓存作用：</p><ul><li>未开启事务的情况，每次查询 Spring 都会创建新的 SqlSession，因此一级缓存失效</li><li>开启事务的情况，Spring 使用 ThreadLocal 获取当前资源绑定同一个 SqlSession，因此此时一级缓存是有效的</li></ul><p>测试一级缓存存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFirstLevelCache</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取sqlSession对象</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionFactoryUtils.openSession();</span><br><span class="line">    <span class="comment">//2. 通过sqlSession对象获取UserDao接口的代理对象</span></span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);</span><br><span class="line">    <span class="comment">//3. 调用UserDao接口的代理对象的findById方法获取信息</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userDao1.findById(<span class="number">1</span>);</span><br><span class="line">System.out.println(user1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sqlSession.clearCache() 清空缓存</span></span><br><span class="line">    </span><br><span class="line">   <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> sqlSession.getMapper(UserDao.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.findById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.测试两次结果是否一样</span></span><br><span class="line">    System.out.println(user1 == user2);<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 提交事务关闭资源</span></span><br><span class="line">    SqlSessionFactoryUtils.commitAndClose(sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二级缓存">二级缓存</h3><h4 id="基本介绍-2">基本介绍</h4><p>二级缓存是 mapper 的缓存，只要是同一个命名空间（namespace）的 SqlSession 就共享二级缓存的内容，并且可以操作二级缓存</p><p>作用：作用范围是整个应用，可以跨线程使用，适合缓存一些修改较少的数据</p><p>工作流程：一个会话查询数据，这个数据就会被放在当前会话的一级缓存中，如果<strong>会话关闭或提交</strong>一级缓存中的数据会保存到二级缓存</p><p>二级缓存的基本使用：</p><ol><li><p>在 MyBatisConfig.xml 文件开启二级缓存，<strong>cacheEnabled 默认值为 true</strong>，所以这一步可以省略不配置</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置开启二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置 Mapper 映射文件</p><p><code>&lt;cache&gt;</code> 标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;dao.UserDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启user支持二级缓存--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;6000&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;&quot;</span> <span class="attr">size</span>=<span class="string">&quot;1024&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span> <span class="comment">&lt;!--则表示所有属性使用默认值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>eviction（清除策略）：</p><ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象，默认</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们</li><li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象</li><li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象</li></ul><p>flushInterval（刷新间隔）：可以设置为任意的正整数， 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新</p><p>size（引用数目）：缓存存放多少元素，默认值是 1024</p><p>readOnly（只读）：可以被设置为 true 或 false</p><ul><li>只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，促进了性能提升</li><li>可读写的缓存会（通过序列化）返回缓存对象的拷贝， 速度上会慢一些，但是更安全，因此默认值是 false</li></ul><p>type：指定自定义缓存的全类名，实现 Cache 接口即可</p></li><li><p>要进行二级缓存的类必须实现 java.io.Serializable 接口，可以使用序列化方式来保存对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="相关属性">相关属性</h4><ol><li><p>select 标签的 useCache 属性</p><p>映射文件中的 <code>&lt;select&gt;</code> 标签中设置 <code>useCache=&quot;true&quot;</code> 代表当前 statement 要使用二级缓存（默认）</p><p>注意：如果每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>每个增删改标签都有 flushCache 属性，默认为 true，代表在<strong>执行增删改之后就会清除一、二级缓存</strong>，保证缓存的一致性；而查询标签默认值为 false，所以查询不会清空缓存</p></li><li><p>localCacheScope：本地缓存作用域，<settings> 中的配置项，默认值为 SESSION，当前会话的所有数据保存在会话缓存中，设置为 STATEMENT 禁用一级缓存</p></li></ol><hr><h4 id="源码解析">源码解析</h4><p>事务提交二级缓存才生效：DefaultSqlSession 调用 commit() 时会回调 <code>executor.commit()</code></p><ul><li><p>CachingExecutor#query()：执行查询方法，查询出的数据会先放入 entriesToAddOnCommit 集合暂存</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从二缓存中获取数据，获取不到去一级缓存获取</span></span><br><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 回调 BaseExecutor#query</span></span><br><span class="line">    list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    <span class="comment">// 将数据放入 entriesToAddOnCommit 集合暂存，此时还没放入二级缓存</span></span><br><span class="line">    tcm.putObject(cache, key, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>commit()：事务提交，<strong>清空一级缓存，放入二级缓存</strong>，二级缓存使用 TransactionalCacheManager（tcm）管理</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">boolean</span> required)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 首先调用 BaseExecutor#commit 方法，【清空一级缓存】</span></span><br><span class="line">    delegate.commit(required);</span><br><span class="line">    tcm.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TransactionalCacheManager#commit：查询出的数据放入二级缓存</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取所有的缓存事务，挨着进行提交</span></span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">        txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">        delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 entriesToAddOnCommit 中的数据放入二级缓存</span></span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    <span class="comment">// 清空相关集合</span></span><br><span class="line">    reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushPendingEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 将数据放入二级缓存</span></span><br><span class="line">        delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>增删改操作会清空缓存：</p><ul><li><p>update()：CachingExecutor 的更新操作</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="comment">// 回调 BaseExecutor#update 方法，也会清空一级缓存</span></span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flushCacheIfRequired()：判断是否需要清空二级缓存</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> &#123;</span><br><span class="line">    <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">    <span class="comment">// 判断二级缓存是否存在，然后判断标签的 flushCache 的值，增删改操作的 flushCache 属性默认为 true</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="literal">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">        <span class="comment">// 清空二级缓存</span></span><br><span class="line">        tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="自定义缓存">自定义缓存</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>type 属性指定的类必须实现 org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cache</span> &#123;</span><br><span class="line">  String <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object key, Object value)</span>;</span><br><span class="line">  Object <span class="title function_">getObject</span><span class="params">(Object key)</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(Object key)</span>;</span><br><span class="line">  Object <span class="title function_">removeObject</span><span class="params">(Object key)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存的配置，只需要在缓存实现中添加公有的 JavaBean 属性，然后通过 cache 元素传递属性值，例如在缓存实现上调用一个名为 <code>setCacheFile(String file)</code> 的方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/tmp/my-custom-cache.tmp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以使用所有简单类型作为 JavaBean 属性的类型，MyBatis 会进行转换。</li><li>可以使用占位符（如 <code>$&#123;cache.file&#125;</code>），以便替换成在配置文件属性中定义的值</li></ul><p>MyBatis 支持在所有属性设置完毕之后，调用一个初始化方法， 如果想要使用这个特性，可以在自定义缓存类里实现 <code>org.apache.ibatis.builder.InitializingObject</code> 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InitializingObject</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：对缓存的配置（如清除策略、可读或可读写等），不能应用于自定义缓存</p><p>对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新，在多个命名空间中共享相同的缓存配置和实例，可以使用 cache-ref 元素来引用另一个缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.someone.application.data.SomeMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="构造语句">构造语句</h2><h3 id="动态-SQL">动态 SQL</h3><h4 id="基本介绍-3">基本介绍</h4><p>动态 SQL 是 MyBatis 强大特性之一，逻辑复杂时，MyBatis 映射配置文件中，SQL 是动态变化的，所以引入动态 SQL 简化拼装 SQL 的操作</p><p>DynamicSQL 包含的标签：</p><ul><li>if</li><li>where</li><li>set</li><li>choose (when、otherwise)</li><li>trim</li><li>foreach</li></ul><p>各个标签都可以进行灵活嵌套和组合</p><p>OGNL：Object Graphic Navigation Language（对象图导航语言），用于对数据进行访问</p><p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7289529.html">https://www.cnblogs.com/ysocean/p/7289529.html</a></p><hr><h4 id="where">where</h4><p><where>：条件标签，有动态条件则使用该标签代替 WHERE 关键字，封装查询条件</p><p>作用：如果标签返回的内容是以 AND 或 OR 开头的，标签内会剔除掉</p><p>表结构：</p><p><img src="../image/post/MyBatis-%E5%8A%A8%E6%80%81sql%E7%94%A8%E6%88%B7%E8%A1%A8.png" alt=""></p><hr><h4 id="if">if</h4><p>基本格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">“条件判断”</span>&gt;</span></span><br><span class="line">查询条件拼接</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询，如果username 不同空时还要加入用户名作为条件，这种情况在我们的多条件组合查询中经常会碰到。</p><ul><li><p>UserMapper.xml</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null &quot;</span>&gt;</span></span><br><span class="line">                id = #&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null &quot;</span>&gt;</span></span><br><span class="line">                AND username = #&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null &quot;</span>&gt;</span></span><br><span class="line">                AND sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>MyBatisConfig.xml，引入映射配置文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mapper引入指定的映射配置 resource属性执行的映射配置文件的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DAO 层 Mapper 接口</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//多条件查询</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;User&gt; <span class="title function_">selectCondition</span><span class="params">(Student stu)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectCondition</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> ssf.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">2</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="comment">//user.setSex(男); AND 后会自动剔除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">        List&lt;Student&gt; list = mapper.selectCondition(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="set">set</h4><p><set>：进行更新操作的时候，含有 set 关键词，使用该标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user u</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                u.username = #&#123;username&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                u.sex = #&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">     WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果第一个条件 username 为空，那么 sql 语句为：update user u set u.sex=? where id=?</li><li>如果第一个条件不为空，那么 sql 语句为：update user u set u.username = ? ,u.sex = ? where id=?</li></ul><hr><h4 id="choose">choose</h4><p>假如不想用到所有的查询条件，只要查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p><p>标签：<when>，<otherwise></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;id !=&#x27;&#x27; and id != null&quot;</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;username !=&#x27;&#x27; and username != null&quot;</span>&gt;</span></span><br><span class="line">                AND username=#&#123;username&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                AND sex=#&#123;sex&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有三个条件，id、username、sex，只能选择一个作为查询条件</p><ul><li><p>如果 id 不为空，那么查询语句为：select * from user where  id=?</p></li><li><p>如果 id 为空，那么看 username 是否为空</p><ul><li>如果不为空，那么语句为：select * from user where username=?</li><li>如果 username 为空，那么查询语句为 select * from user where sex=?</li></ul></li></ul><hr><h4 id="trim">trim</h4><p>trim 标记是一个格式化的标记，可以完成 set 或者是 where 标记的功能，自定义字符串截取</p><ul><li>prefix：给拼串后的整个字符串加一个前缀，trim 标签体中是整个字符串拼串后的结果</li><li>prefixOverrides：去掉整个字符串前面多余的字符</li><li>suffix：给拼串后的整个字符串加一个后缀</li><li>suffixOverrides：去掉整个字符串后面多余的字符</li></ul><p>改写 if + where 语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUserByUsernameAndSex&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and | or&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">            AND username=#&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null&quot;</span>&gt;</span></span><br><span class="line">            AND sex=#&#123;sex&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改写 if + set 语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根据 id 更新 user 表的数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ys.po.User&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user u</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            u.username = #&#123;username&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            u.sex = #&#123;sex&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    WHERE id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="foreach">foreach</h4><p>基本格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span>&gt;</span>：循环遍历标签。适用于多个参数或者的关系。</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">“”open</span>=<span class="string">“”close</span>=<span class="string">“”item</span>=<span class="string">“”separator</span>=<span class="string">“”</span>&gt;</span></span><br><span class="line">获取参数</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>collection：参数容器类型， (list-集合， array-数组)</li><li>open：开始的 SQL 语句</li><li>close：结束的 SQL 语句</li><li>item：参数变量名</li><li>separator：分隔符</li></ul><p>需求：循环执行 sql 的拼接操作，<code>SELECT * FROM user WHERE id IN (1,2,5)</code></p><ul><li><p>UserMapper.xml片段</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM student</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id IN(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码片段</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//5.调用实现类的方法，接收结果</span></span><br><span class="line">List&lt;User&gt; list = mapper.selectByIds(ids);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="SQL片段">SQL片段</h4><p>将一些重复性的 SQL 语句进行抽取，以达到复用的效果</p><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">“片段唯一标识”</span>&gt;</span>抽取的SQL语句<span class="tag">&lt;/<span class="name">sql</span>&gt;</span><span class="comment">&lt;!--抽取标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">“片段唯一标识”/</span>&gt;</span><span class="comment">&lt;!--引入标签--&gt;</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span>&gt;</span>SELECT * FROM user<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;select&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id IN(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="逆向工程">逆向工程</h3><p>MyBatis 逆向工程，可以针对<strong>单表</strong>自动生成 MyBatis 执行所需要的代码（mapper.java、mapper.xml、pojo…）</p><p>generatorConfig.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;testTables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatisrelation&quot;</span> <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">password</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">&lt;!-- targetProject:生成PO类的位置！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.po&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject:mapper映射文件生成的位置！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.mapper&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage：mapper接口生成的位置，重要！！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetPackage</span>=<span class="string">&quot;com.ys.mapper&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">targetProject</span>=<span class="string">&quot;.\src&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据库表，要生成哪些表，就写哪些表，要和数据库中对应，不能写错！ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;orders&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;orderdetail&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>生成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenerator</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;String&gt; warnings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">overwrite</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//指向逆向工程配置文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">configFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(GeneratorTest.class.</span><br><span class="line">                               getResource(<span class="string">&quot;/generatorConfig.xml&quot;</span>).getFile());</span><br><span class="line">    <span class="type">ConfigurationParser</span> <span class="variable">cp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationParser</span>(warnings);</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> cp.parseConfiguration(configFile);</span><br><span class="line">    <span class="type">DefaultShellCallback</span> <span class="variable">callback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShellCallback</span>(overwrite);</span><br><span class="line">    <span class="type">MyBatisGenerator</span> <span class="variable">myBatisGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBatisGenerator</span>(config,</span><br><span class="line">                                                             callback, warnings);</span><br><span class="line">    myBatisGenerator.generate(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/7360409.html">https://www.cnblogs.com/ysocean/p/7360409.html</a></p><hr><h3 id="构建-SQL">构建 SQL</h3><h4 id="基础语法">基础语法</h4><p>MyBatis 提供了 org.apache.ibatis.jdbc.SQL 功能类，专门用于构建 SQL 语句</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>SELECT(String… columns)</td><td>根据字段拼接查询语句</td></tr><tr><td>FROM(String… tables)</td><td>根据表名拼接语句</td></tr><tr><td>WHERE(String… conditions)</td><td>根据条件拼接语句</td></tr><tr><td>INSERT_INTO(String tableName)</td><td>根据表名拼接新增语句</td></tr><tr><td>INTO_VALUES(String… values)</td><td>根据值拼接新增语句</td></tr><tr><td>UPDATE(String table)</td><td>根据表名拼接修改语句</td></tr><tr><td>DELETE_FROM(String table)</td><td>根据表名拼接删除语句</td></tr></tbody></table><p>增删改查注解：</p><ul><li>@SelectProvider：生成查询用的 SQL 语句</li><li>@InsertProvider：生成新增用的 SQL 语句</li><li>@UpdateProvider：生成修改用的 SQL 语句注解</li><li>@DeleteProvider：生成删除用的 SQL 语句注解。<ul><li>type 属性：生成 SQL 语句功能类对象</li><li>method 属性：指定调用方法</li></ul></li></ul><hr><h4 id="基本操作">基本操作</h4><ul><li><p>MyBatisConfig.xml 配置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- mappers引入映射配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Mapper 类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> &#123;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = ReturnSql.class, method = &quot;getSelectAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Student&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增数据</span></span><br><span class="line">    <span class="meta">@InsertProvider(type = ReturnSql.class, method = &quot;getInsert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">insert</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改操作</span></span><br><span class="line">    <span class="meta">@UpdateProvider(type = ReturnSql.class, method = &quot;getUpdate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">update</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="meta">@DeleteProvider(type = ReturnSql.class, method = &quot;getDelete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Integer <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReturnSQL 类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReturnSql</span> &#123;</span><br><span class="line">    <span class="comment">//定义方法，返回查询的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSelectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                SELECT(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                FROM(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回新增的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInsert</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                INSERT_INTO(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                INTO_VALUES(<span class="string">&quot;#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回修改的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUpdate</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                UPDATE(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                SET(<span class="string">&quot;name=#&#123;name&#125;&quot;</span>,<span class="string">&quot;age=#&#123;age&#125;&quot;</span>);</span><br><span class="line">                WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法，返回删除的sql语句</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDelete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQL</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                DELETE_FROM(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">                WHERE(<span class="string">&quot;id=#&#123;id&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>功能实现类</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span>  <span class="comment">//查询全部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.加载核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;MyBatisConfig.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取SqlSession工厂对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过工厂对象获取SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类对象中的方法，接收结果</span></span><br><span class="line">        List&lt;Student&gt; list = mapper.selectAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.处理结果</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span>  <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4获取StudentMapper接口的实现类对象</span></span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.调用实现类对象中的方法，接收结果 -&gt;6 7</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;赵六&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insert(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4 5调用实现类对象中的方法，接收结果 -&gt;6 7 </span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4</span>,<span class="string">&quot;赵六wq&quot;</span>,<span class="number">36</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.update(stu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1 2 3 4 5 6 7</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> mapper.delete(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="插件使用">插件使用</h2><h3 id="插件原理">插件原理</h3><p>实现原理：插件是按照插件配置顺序创建层层包装对象，执行目标方法的之后，按照逆向顺序执行（栈）</p><img src="../image/post/MyBatis-%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86.png" style="zoom:50%;" /><p>在四大对象创建时：</p><ul><li>每个创建出来的对象不是直接返回的，而是 <code>interceptorChain.pluginAll(parameterHandler)</code></li><li>获取到所有 Interceptor（插件需要实现的接口），调用 <code>interceptor.plugin(target)</code>返回 target 包装后的对象</li><li>插件机制可以使用插件为目标对象创建一个代理对象，代理对象可以<strong>拦截到四大对象的每一个执行</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(</span></span><br><span class="line"><span class="meta">&#123;</span></span><br><span class="line"><span class="meta">@Signature(type=StatementHandler.class,method=&quot;parameterize&quot;,args=java.sql.Statement.class)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFirstPlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//intercept：拦截目标对象的目标方法的执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyFirstPlugin...intercept:&quot;</span> + invocation.getMethod());</span><br><span class="line"><span class="comment">//动态的改变一下sql运行的参数：以前1号员工，实际从数据库查询11号员工</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> invocation.getTarget();</span><br><span class="line">System.out.println(<span class="string">&quot;当前拦截到的对象：&quot;</span> + target);</span><br><span class="line"><span class="comment">//拿到：StatementHandler==&gt;ParameterHandler===&gt;parameterObject</span></span><br><span class="line"><span class="comment">//拿到target的元数据</span></span><br><span class="line"><span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> SystemMetaObject.forObject(target);</span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> metaObject.getValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;sql语句用的参数是：&quot;</span> + value);</span><br><span class="line"><span class="comment">//修改完sql语句要用的参数</span></span><br><span class="line">metaObject.setValue(<span class="string">&quot;parameterHandler.parameterObject&quot;</span>, <span class="number">11</span>);</span><br><span class="line"><span class="comment">//执行目标方法</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line"><span class="comment">//返回执行后的返回值</span></span><br><span class="line"><span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plugin：包装目标对象的，为目标对象创建一个代理对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line"><span class="comment">//可以借助 Plugin 的 wrap 方法来使用当前 Interceptor 包装我们目标对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;MyFirstPlugin...plugin:mybatis将要包装的对象&quot;</span> + target);</span><br><span class="line"><span class="type">Object</span> <span class="variable">wrap</span> <span class="operator">=</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//返回为当前target创建的动态代理</span></span><br><span class="line"><span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setProperties：将插件注册时的property属性设置进来</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;插件配置的信息：&quot;</span> + properties);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--plugins：注册插件  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;mybatis.dao.MyFirstPlugin&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="分页插件">分页插件</h3><p><img src="../image/post/%E5%88%86%E9%A1%B5%E4%BB%8B%E7%BB%8D.png" alt=""></p><ul><li>分页可以将很多条结果进行分页显示。如果当前在第一页，则没有上一页。如果当前在最后一页，则没有下一页，需要明确当前是第几页，这一页中显示多少条结果。</li><li>MyBatis 是不带分页功能的，如果想实现分页功能，需要手动编写 LIMIT 语句，不同的数据库实现分页的 SQL 语句也是不同，手写分页 成本较高。</li><li>PageHelper：第三方分页助手，将复杂的分页操作进行封装，从而让分页功能变得非常简单</li></ul><hr><h3 id="分页操作">分页操作</h3><p>开发步骤：</p><ol><li><p>导入 PageHelper 的 Maven 坐标</p></li><li><p>在 MyBatis 核心配置文件中配置 PageHelper 插件</p><p>注意：分页助手的插件配置在通用 Mapper 之前</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定方言 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>.........<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>与 MySQL 分页查询页数计算公式不同</p><p><code>static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize)</code>：pageNum第几页，pageSize页面大小</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//第一页：显示2条数据</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    List&lt;Student&gt; students = sqlSession.selectList(<span class="string">&quot;StudentMapper.selectAll&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="参数获取">参数获取</h3><p>PageInfo构造方法：</p><ul><li><code>PageInfo&lt;Student&gt; info = new PageInfo&lt;&gt;(list)</code> : list 是 SQL 执行返回的结果集合，参考上一节</li></ul><p>PageInfo相关API：</p><ol><li>startPage()：设置分页参数</li><li>PageInfo：分页相关参数功能类。</li><li>getTotal()：获取总条数</li><li>getPages()：获取总页数</li><li>getPageNum()：获取当前页</li><li>getPageSize()：获取每页显示条数</li><li>getPrePage()：获取上一页</li><li>getNextPage()：获取下一页</li><li>isIsFirstPage()：获取是否是第一页</li><li>isIsLastPage()：获取是否是最后一页</li></ol>]]></content>
      
      
      <categories>
          
          <category> DataBaseing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBase </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MyBatis初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBase-MySQL初级学习</title>
      <link href="/posts/2866a1c7.html"/>
      <url>/posts/2866a1c7.html</url>
      
        <content type="html"><![CDATA[<h1>MySQL初级</h1><h2 id="目标">目标</h2><ol><li>Inonodb</li><li>索引原理</li><li>锁原理</li><li>事务&amp;隔离级别</li><li>日志</li><li>回表</li><li>索引失效&amp;错选索引</li><li>orderby</li><li>bufferPool</li><li>死锁</li><li>慢SQL排查</li><li>join</li></ol><h2 id="体系架构">体系架构</h2><h3 id="整体架构">整体架构</h3><p>体系结构详解：</p><ul><li>第一层：网络连接层<ul><li>一些客户端和链接服务，包含本地 Socket 通信和大多数基于客户端/服务端工具实现的 TCP/IP 通信，主要完成一些类似于连接处理、授权认证、及相关的安全方案</li><li>在该层上引入了<strong>连接池</strong> Connection Pool 的概念，管理缓冲用户连接，线程处理等需要缓存的需求</li><li>在该层上实现基于 SSL 的安全链接，服务器也会为安全接入的每个客户端验证它所具有的操作权限</li></ul></li></ul><ul><li>第二层：核心服务层<ul><li>查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，所有的内置函数（日期、数学、加密函数等）<ul><li>Management Serveices &amp; Utilities：系统管理和控制工具，备份、安全、复制、集群等</li><li>SQL Interface：接受用户的 SQL 命令，并且返回用户需要查询的结果</li><li>Parser：SQL 语句分析器</li><li>Optimizer：查询优化器</li><li>Caches &amp; Buffers：查询缓存，服务器会查询内部的缓存，如果缓存空间足够大，可以在大量读操作的环境中提升系统性能</li></ul></li><li>所有<strong>跨存储引擎的功能</strong>在这一层实现，如存储过程、触发器、视图等</li><li>在该层服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询顺序，是否利用索引等， 最后生成相应的执行操作</li><li>MySQL 中服务器层不管理事务，<strong>事务是由存储引擎实现的</strong></li></ul></li><li>第三层：存储引擎层<ul><li>Pluggable Storage Engines：存储引擎接口，MySQL 区别于其他数据库的重要特点就是其存储引擎的架构模式是插件式的（存储引擎是基于表的，而不是数据库）</li><li>存储引擎<strong>真正的负责了 MySQL 中数据的存储和提取</strong>，服务器通过 API 和存储引擎进行通信</li><li>不同的存储引擎具有不同的功能，共用一个 Server 层，可以根据开发的需要，来选取合适的存储引擎</li></ul></li><li>第四层：系统文件层<ul><li>数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互</li><li>File System：文件系统，保存配置文件、数据文件、日志文件、错误文件、二进制文件等</li></ul></li></ul><p><img src="../image/post/MySQL-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p><hr><h3 id="工作流程">工作流程</h3><p>当执行完全相同的 SQL 语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存</p><p>查询过程：</p><ol><li>客户端发送一条查询给服务器</li><li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果（一般是 K-V 键值对），否则进入下一阶段</li><li>分析器进行 SQL 分析，再由优化器生成对应的执行计划</li><li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询</li><li>将结果返回给客户端</li></ol><p>大多数情况下不建议使用查询缓存，因为查询缓存往往弊大于利</p><ul><li>查询缓存的<strong>失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能费力地把结果存起来，还没使用就被一个更新全清空了，对于更新压力大的数据库来说，查询缓存的命中率会非常低</li><li>除非业务就是有一张静态表，很长时间才会更新一次，比如一个系统配置表，那这张表上的查询才适合使用查询缓存</li></ul><hr><h3 id="优化器">优化器</h3><h4 id="成本分析">成本分析</h4><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序</p><ul><li>根据搜索条件找出所有可能的使用的索引</li><li>成本分析，执行成本由 I/O 成本和 CPU 成本组成，计算全表扫描和使用不同索引执行 SQL 的代价</li><li>找到一个最优的执行方案，用最小的代价去执行语句</li></ul><p>在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少意味着访问磁盘的次数越少，消耗的 CPU 资源越少，优化器还会结合是否使用临时表、是否排序等因素进行综合判断</p><hr><h4 id="统计数据">统计数据</h4><p>MySQL 中保存着两种统计数据：</p><ul><li>innodb_table_stats 存储了表的统计数据，每一条记录对应着一个表的统计数据</li><li>innodb_index_stats 存储了索引的统计数据，每一条记录对应着一个索引的一个统计项的数据</li></ul><p>MySQL 在真正执行语句之前，并不能精确地知道满足条件的记录有多少条，只能根据统计信息来估算记录，统计信息就是索引的区分度,一个索引上不同的值的个数（比如性别只能是男女，就是 2 ），称之为基数（cardinality），<strong>基数越大说明区分度越好</strong></p><p>通过<strong>采样统计</strong>来获取基数，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</p><p>在 MySQL 中，有两种存储统计数据的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p><ul><li>ON：表示统计信息会持久化存储（默认），采样页数 N 默认为 20，可以通过 <code>innodb_stats_persistent_sample_pages</code> 指定，页数越多统计的数据越准确，但消耗的资源更大</li><li>OFF：表示统计信息只存储在内存，采样页数 N 默认为 8，也可以通过系统变量设置（不推荐，每次重新计算浪费资源）</li></ul><p>数据表是会持续更新的，两种统计信息的更新方式：</p><ul><li>设置 <code>innodb_stats_auto_recalc</code> 为 1，当发生变动的记录数量超过表大小的 10% 时，自动触发重新计算，不过是<strong>异步进行</strong></li><li>调用 <code>ANALYZE TABLE t</code> 手动更新统计信息，只对信息做<strong>重新统计</strong>（不是重建表），没有修改数据，这个过程中加了 MDL 读锁并且是同步进行，所以会暂时阻塞系统</li></ul><p><strong>EXPLAIN 执行计划在优化器阶段生成</strong>，如果 explain 的结果预估的 rows 值跟实际情况差距比较大，可以执行 analyze 命令重新修正信息</p><hr><h4 id="错选索引">错选索引</h4><p>采样统计本身是估算数据，或者 SQL 语句中的字段选择有问题时，可能导致 MySQL 没有选择正确的执行索引</p><p>解决方法：</p><ul><li><p>采用 force index 强行选择一个索引</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> FORCE INDEX(name) <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;seazean&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>可以考虑修改 SQL 语句，引导 MySQL 使用期望的索引</p></li><li><p>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</p></li></ul><hr><h3 id="终止流程">终止流程</h3><h4 id="终止语句">终止语句</h4><p>终止线程中正在执行的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL QUERY thread_id</span><br></pre></td></tr></table></figure><p>KILL 不是马上终止的意思，而是告诉执行线程这条语句已经不需要继续执行，可以开始执行停止的逻辑（类似于打断）。因为对表做增删改查操作，会在表上加 MDL 读锁，如果线程被 KILL 时就直接终止，那这个 MDL 读锁就没机会被释放了</p><p>命令 <code>KILL QUERYthread_id_A</code> 的执行流程：</p><ul><li>把 session A 的运行状态改成 THD::KILL_QUERY（将变量 killed 赋值为 THD::KILL_QUERY）</li><li>给 session A 的执行线程发一个信号，让 session A 来处理这个 THD::KILL_QUERY 状态</li></ul><p>会话处于等待状态（锁阻塞），必须满足是一个可以被唤醒的等待，必须有机会去<strong>判断线程的状态</strong>，如果不满足就会造成 KILL 失败</p><p>典型场景：innodb_thread_concurrency 为 2，代表并发线程上限数设置为 2</p><ul><li>session A 执行事务，session B 执行事务，达到线程上限；此时 session C 执行事务会阻塞等待，session D 执行 kill query C 无效</li><li>C 的逻辑是每 10 毫秒判断是否可以进入 InnoDB 执行，如果不行就调用 nanosleep 函数进入 sleep 状态，没有去判断线程状态</li></ul><p><code>补充：执行 Ctrl+C 的时候，是 MySQL 客户端另外启动一个连接，然后发送一个 KILL QUERY 命令</code></p><hr><h4 id="终止连接">终止连接</h4><p>断开线程的连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KILL CONNECTION id</span><br></pre></td></tr></table></figure><p>断开连接后执行 SHOW PROCESSLIST 命令，如果这条语句的 Command 列显示 Killed，代表线程的状态是 KILL_CONNECTION，说明这个线程有语句正在执行，当前状态是停止语句执行中，终止逻辑耗时较长</p><ul><li>超大事务执行期间被 KILL，这时回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长</li><li>大查询回滚，如果查询过程中生成了比较大的临时文件，删除临时文件可能需要等待 IO 资源，导致耗时较长</li><li>DDL 命令执行到最后阶段被 KILL，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久</li></ul><p>总结：KILL CONNECTION 本质上只是把客户端的 SQL 连接断开，后面的终止流程还是要走 KILL QUERY</p><p>一个事务被 KILL 之后，持续处于回滚状态，不应该强行重启整个 MySQL 进程，应该等待事务自己执行完成，因为重启后依然继续做回滚操作的逻辑</p><h2 id="存储引擎">存储引擎</h2><h3 id="基本介绍">基本介绍</h3><p>对比其他数据库，MySQL 的架构可以在不同场景应用并发挥良好作用，主要体现在存储引擎，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取分离，可以针对不同的存储需求可以选择最优的存储引擎</p><p>存储引擎的介绍：</p><ul><li>MySQL 数据库使用不同的机制存取表文件 , 机制的差别在于不同的存储方式、索引技巧、锁定水平等不同的功能和能力，在 MySQL 中，将这些不同的技术及配套的功能称为存储引擎</li><li>Oracle、SqlServer 等数据库只有一种存储引擎，MySQL <strong>提供了插件式的存储引擎架构</strong>，所以 MySQL 存在多种存储引擎 , 就会让数据库采取了不同的处理数据的方式和扩展功能</li><li>在关系型数据库中数据的存储是以表的形式存进行，所以存储引擎也称为表类型（存储和操作此表的类型）</li><li>通过选择不同的引擎，能够获取最佳的方案,  也能够获得额外的速度或者功能，提高程序的整体效果。</li></ul><p>MySQL 支持的存储引擎：</p><ul><li>MySQL 支持的引擎包括：InnoDB、MyISAM、MEMORY、Archive、Federate、CSV、BLACKHOLE 等</li><li>MySQL5.5 之前的默认存储引擎是 MyISAM，5.5 之后就改为了 InnoDB</li></ul><hr><h3 id="引擎对比">引擎对比</h3><p>MyISAM 存储引擎：</p><ul><li>特点：不支持事务和外键，读取速度快，节约资源</li><li>应用场景：查询和插入操作为主，只有很少更新和删除操作，并对事务的完整性、并发性要求不高</li><li>存储方式：<ul><li>每个 MyISAM 在磁盘上存储成 3 个文件，其文件名都和表名相同，拓展名不同</li><li>表的定义保存在 .frm 文件，表数据保存在 .MYD (MYData) 文件中，索引保存在 .MYI (MYIndex) 文件中</li></ul></li></ul><p>InnoDB 存储引擎：(MySQL5.5 版本后默认的存储引擎)</p><ul><li>特点：<strong>支持事务</strong>和外键操作，支持并发控制。对比 MyISAM 的存储引擎，InnoDB 写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li><li>应用场景：对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，读写频繁的操作</li><li>存储方式：<ul><li>使用共享表空间存储， 这种方式创建的表的表结构保存在 .frm 文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中，可以是多个文件</li><li>使用多表空间存储，创建的表的表结构存在 .frm 文件中，每个表的数据和索引单独保存在 .ibd 中</li></ul></li></ul><p>MERGE 存储引擎：</p><ul><li><p>特点：</p><ul><li>是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，通过将不同的表分布在多个磁盘上</li><li>MERGE 表本身并没有存储数据，对 MERGE 类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的 MyISAM 表进行的</li></ul></li><li><p>应用场景：将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象引用他们，适合做数据仓库</p></li><li><p>操作方式：</p><ul><li>插入操作是通过 INSERT_METHOD 子句定义插入的表，使用 FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上；不定义这个子句或者定义为 NO，表示不能对 MERGE 表执行插入操作</li><li>对 MERGE 表进行 DROP 操作，但是这个操作只是删除 MERGE 表的定义，对内部的表是没有任何影响的</li></ul></li></ul><table><thead><tr><th>特性</th><th>MyISAM</th><th>InnoDB</th><th>MEMORY</th></tr></thead><tbody><tr><td>存储限制</td><td>有（平台对文件系统大小的限制）</td><td>64TB</td><td>有（平台的内存限制）</td></tr><tr><td><strong>事务安全</strong></td><td><strong>不支持</strong></td><td><strong>支持</strong></td><td><strong>不支持</strong></td></tr><tr><td><strong>锁机制</strong></td><td><strong>表锁</strong></td><td><strong>表锁/行锁</strong></td><td><strong>表锁</strong></td></tr><tr><td>B+Tree 索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>集群索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>数据索引</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>数据缓存</td><td>不支持</td><td>支持</td><td>N/A</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td><td>N/A</td></tr><tr><td>数据可压缩</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>空间使用</td><td>低</td><td>高</td><td>N/A</td></tr><tr><td>内存使用</td><td>低</td><td>高</td><td>中等</td></tr><tr><td>批量插入速度</td><td>高</td><td>低</td><td>高</td></tr><tr><td><strong>外键</strong></td><td><strong>不支持</strong></td><td><strong>支持</strong></td><td><strong>不支持</strong></td></tr></tbody></table><p>MyISAM 和 InnoDB 的区别？</p><ul><li>事务：InnoDB 支持事务，MyISAM 不支持事务</li><li>外键：InnoDB 支持外键，MyISAM 不支持外键</li><li>索引：InnoDB 是聚集（聚簇）索引，MyISAM 是非聚集（非聚簇）索引</li><li>锁粒度：InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁</li><li>存储结构：参考本节上半部分</li></ul><hr><h3 id="引擎操作">引擎操作</h3><ul><li><p>查询数据库支持的存储引擎</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%storage_engine%&#x27;; -- 查看Mysql数据库默认的存储引擎 </span><br></pre></td></tr></table></figure></li><li><p>查询某个数据库中所有数据表的存储引擎</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称;</span><br></pre></td></tr></table></figure></li><li><p>查询某个数据库中某个数据表的存储引擎</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称 WHERE NAME = &#x27;数据表名称&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>创建数据表，指定存储引擎</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名,数据类型,</span><br><span class="line">    ...</span><br><span class="line">)ENGINE = 引擎名称;</span><br></pre></td></tr></table></figure></li><li><p>修改数据表的存储引擎</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE = 引擎名称;</span><br></pre></td></tr></table></figure></li></ul><h2 id="索引机制">索引机制</h2><h3 id="索引介绍">索引介绍</h3><h4 id="基本介绍-2">基本介绍</h4><p>MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的一种数据结构，**本质是排好序的快速查找数据结构。**在表数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><strong>索引是在存储引擎层实现的</strong>，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样</p><p>索引使用：一张数据表，用于保存数据；一个索引配置文件，用于保存索引；每个索引都指向了某一个数据<br><img src="../image/post/MySQL-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D.png" alt=""></p><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据的物理地址的指针，这样就可以运用二叉查找快速获取到相应数据</p><p>索引的优点：</p><ul><li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的 IO 成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗</li></ul><p>索引的缺点：</p><ul><li>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式<strong>存储在磁盘</strong>上</li><li>虽然索引大大提高了查询效率，同时却也降低更新表的速度。对表进行 INSERT、UPDATE、DELETE 操作，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，还会调整因为更新所带来的键值变化后的索引信息，<strong>但是更新数据也需要先从数据库中获取</strong>，索引加快了获取速度，所以可以相互抵消一下。</li><li>索引会影响到 WHERE 的查询条件和排序 ORDER BY 两大功能</li></ul><hr><h4 id="索引分类">索引分类</h4><p>索引一般的分类如下：</p><ul><li><p>功能分类</p><ul><li>主键索引：一种特殊的唯一索引，不允许有空值，一般在建表时同时创建主键索引</li><li>单列索引：一个索引只包含单个列，一个表可以有多个单列索引（普通索引）</li><li>联合索引：顾名思义，就是将单列索引进行组合</li><li>唯一索引：索引列的值必须唯一，<strong>允许有空值</strong>，如果是联合索引，则列值组合必须唯一<ul><li>NULL 值可以出现多次，因为两个 NULL 比较的结果既不相等，也不不等，结果仍然是未知</li><li>可以声明不允许存储 NULL 值的非空唯一索引</li></ul></li><li>外键索引：只有 InnoDB 引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作</li></ul></li><li><p>结构分类</p><ul><li>BTree 索引：MySQL 使用最频繁的一个索引数据结构，是 InnoDB 和 MyISAM 存储引擎默认的索引类型，底层基于 B+Tree</li><li>Hash 索引：MySQL中 Memory 存储引擎默认支持的索引类型</li><li>R-tree 索引（空间索引）：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型</li><li>Full-text 索引（全文索引）：快速匹配全部文档的方式。MyISAM 支持， InnoDB 不支持 FULLTEXT 类型的索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，MEMORY 引擎不支持</li></ul><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>BTREE</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>HASH</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6 版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table></li></ul><p>联合索引图示：根据身高年龄建立的组合索引（height,age）</p><p><img src="../image/post/MySQL-%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E5%9B%BE.png" alt=""></p><hr><h3 id="索引操作">索引操作</h3><p>索引在创建表的时候可以同时创建， 也可以随时增加新的索引</p><ul><li><p>创建索引：如果一个表中有一列是主键，那么会<strong>默认为其创建主键索引</strong>（主键列不需要单独创建索引）</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 [USING 索引类型] ON 表名(列名...);</span><br><span class="line">-- 索引类型默认是 B+TREE</span><br></pre></td></tr></table></figure></li><li><p>查看索引</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM 表名;</span><br></pre></td></tr></table></figure></li><li><p>添加索引</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 单列索引</span><br><span class="line">ALTER TABLE 表名 ADD INDEX 索引名称(列名);</span><br><span class="line"></span><br><span class="line">-- 组合索引</span><br><span class="line">ALTER TABLE 表名 ADD INDEX 索引名称(列名1,列名2,...);</span><br><span class="line"></span><br><span class="line">-- 主键索引</span><br><span class="line">ALTER TABLE 表名 ADD PRIMARY KEY(主键列名); </span><br><span class="line"></span><br><span class="line">-- 外键索引(添加外键约束，就是外键索引)</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名);</span><br><span class="line"></span><br><span class="line">-- 唯一索引</span><br><span class="line">ALTER TABLE 表名 ADD UNIQUE 索引名称(列名);</span><br><span class="line"></span><br><span class="line">-- 全文索引(mysql只支持文本类型)</span><br><span class="line">ALTER TABLE 表名 ADD FULLTEXT 索引名称(列名);</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX 索引名称 ON 表名;</span><br></pre></td></tr></table></figure></li></ul><h3 id="聚簇索引">聚簇索引</h3><h4 id="对比">对比</h4><p>聚簇索引是一种数据存储方式，并不是一种单独的索引类型</p><ul><li><p>聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引</p></li><li><p>非聚簇索引的叶子节点存放的是主键值或指向数据行的指针（由存储引擎决定）</p></li></ul><p>在 Innodb 下主键索引是聚簇索引，在 MyISAM 下主键索引是非聚簇索引</p><hr><h4 id="Innodb">Innodb</h4><h5 id="聚簇索引-2">聚簇索引</h5><p>在 Innodb 存储引擎，B+ 树索引可以分为聚簇索引（也称聚集索引、clustered index）和辅助索引（也称非聚簇索引或二级索引、secondary index、non-clustered index）</p><p>InnoDB 中，聚簇索引是按照每张表的主键构造一颗 B+ 树，叶子节点中存放的就是整张表的数据，将聚簇索引的叶子节点称为数据页</p><ul><li>这个特性决定了<strong>数据也是索引的一部分</strong>，所以一张表只能有一个聚簇索引</li><li>辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引</li></ul><p>聚簇索引的优点：</p><ul><li>数据访问更快，聚簇索引将索引和数据保存在同一个 B+ 树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li></ul><p>聚簇索引的缺点：</p><ul><li><p>插入速度严重依赖于插入顺序，按照主键的顺序（递增）插入是最快的方式，否则将会出现页分裂，严重影响性能，所以对于 InnoDB 表，一般都会定义一个自增的 ID 列为主键</p></li><li><p>更新主键的代价很高，将会导致被更新的行移动，所以对于 InnoDB 表，一般定义主键为不可更新</p></li><li><p>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</p></li></ul><h5 id="辅助索引">辅助索引</h5><p>在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引等</p><p>辅助索引叶子节点存储的是主键值，而不是数据的物理地址，所以访问数据需要二次查找，推荐使用覆盖索引，可以减少回表查询</p><p><strong>检索过程</strong>：辅助索引找到主键值，再通过聚簇索引（二分）找到数据页，最后通过数据页中的 Page Directory（二分）找到对应的数据分组，遍历组内所所有的数据找到数据行</p><p>补充：无索引走全表查询，查到数据页后和上述步骤一致</p><hr><h5 id="索引实现">索引实现</h5><p>InnoDB 使用 B+Tree 作为索引结构，并且 InnoDB 一定有索引</p><p>主键索引：</p><ul><li><p>在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这个索引的 key 是数据表的主键，叶子节点 data 域保存了完整的数据记录</p></li><li><p>InnoDB 的表数据文件<strong>通过主键聚集数据</strong>，如果没有定义主键，会选择非空唯一索引代替，如果也没有这样的列，MySQL 会自动为 InnoDB 表生成一个<strong>隐含字段 row_id</strong> 作为主键，这个字段长度为 6 个字节，类型为长整形</p></li></ul><p>辅助索引：</p><ul><li><p>InnoDB 的所有辅助索引（二级索引）都引用主键作为 data 域</p></li><li><p>InnoDB 表是基于聚簇索引建立的，因此 InnoDB 的索引能提供一种非常快速的主键查找性能。不过辅助索引也会包含主键列，所以不建议使用过长的字段作为主键，<strong>过长的主索引会令辅助索引变得过大</strong></p></li></ul><p><img src="../image/post/MySQL-InnoDB%E8%81%9A%E7%B0%87%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt=""></p><hr><h4 id="MyISAM">MyISAM</h4><h5 id="非聚簇">非聚簇</h5><p>MyISAM 的主键索引使用的是非聚簇索引，索引文件和数据文件是分离的，<strong>索引文件仅保存数据的地址</strong></p><ul><li>主键索引 B+ 树的节点存储了主键，辅助键索引 B+ 树存储了辅助键，表数据存储在独立的地方，这两颗 B+ 树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别</li><li>由于索引树是独立的，通过辅助索引检索<strong>无需回表查询</strong>访问主键的索引树</li></ul><p><img src="../image/post/MySQL-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E6%A3%80%E9%94%81%E6%95%B0%E6%8D%AE%E5%9B%BE.jpg" alt=""></p><hr><h5 id="索引实现-2">索引实现</h5><p>MyISAM 的索引方式也叫做非聚集的，之所以这么称呼是为了与 InnoDB 的聚集索引区分</p><p>主键索引：MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址</p><p>辅助索引：MyISAM 中主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复</p><p><img src="../image/post/MySQL-MyISAM%E4%B8%BB%E9%94%AE%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt=""></p><p>参考文章：<a href="https://blog.csdn.net/lm1060891265/article/details/81482136">https://blog.csdn.net/lm1060891265/article/details/81482136</a></p><hr><h3 id="索引结构">索引结构</h3><h4 id="数据页">数据页</h4><p>文件系统的最小单元是块（block），一个块的大小是 4K，系统从磁盘读取数据到内存时是以磁盘块为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么</p><p>InnoDB 存储引擎中有页（Page）的概念，页是 MySQL 磁盘管理的最小单位</p><ul><li><strong>InnoDB 存储引擎中默认每个页的大小为 16KB，索引中一个节点就是一个数据页</strong>，所以会一次性读取 16KB 的数据到内存</li><li>InnoDB 引擎将若干个地址连接磁盘块，以此来达到页的大小 16KB</li><li>在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率</li></ul><p>数据页物理结构，从上到下：</p><ul><li>File Header：上一页和下一页的指针、该页的类型（索引页、数据页、日志页等）、<strong>校验和</strong>、LSN（最近一次修改当前页面时的系统 lsn 值，事务持久性部分详解）等信息</li><li>Page Header：记录状态信息</li><li>Infimum + Supremum：当前页的最小记录和最大记录（头尾指针），Infimum 所在分组只有一条记录，Supremum 所在分组可以有 1 ~ 8 条记录，剩余的分组可以有 4 ~ 8 条记录</li><li>User Records：存储数据的记录</li><li>Free Space：尚未使用的存储空间</li><li>Page Directory：分组的目录，可以通过目录快速定位（二分法）数据的分组</li><li>File Trailer：检验和字段，在刷脏过程中，页首和页尾的校验和一致才能说明页面刷新成功，二者不同说明刷新期间发生了错误；LSN 字段，也是用来校验页面的完整性</li></ul><p>数据页中包含数据行，数据的存储是基于数据行的，数据行有 next_record 属性指向下一个行数据，所以是可以遍历的，但是一组数据至多 8 个行，通过 Page Directory 先定位到组，然后遍历获取所需的数据行即可</p><p>数据行中有三个隐藏字段：trx_id、roll_pointer、row_id（在事务章节会详细介绍它们的作用）</p><hr><h4 id="BTree">BTree</h4><p>BTree 的索引类型是基于 B+Tree 树型数据结构的，B+Tree 又是 BTree 数据结构的变种，用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序</p><p>BTree 又叫多路平衡搜索树，一颗 m 叉的 BTree 特性如下：</p><ul><li>树中每个节点最多包含 m 个孩子</li><li>除根节点与叶子节点外，每个节点至少有 [ceil(m/2)] 个孩子</li><li>若根节点不是叶子节点，则至少有两个孩子</li><li>所有的叶子节点都在同一层</li><li>每个非叶子节点由 n 个 key 与 n+1 个指针组成，其中 [ceil(m/2)-1] &lt;= n &lt;= m-1</li></ul><p>5 叉，key 的数量 [ceil(m/2)-1] &lt;= n &lt;= m-1 为 2 &lt;= n &lt;=4 ，当 n&gt;4 时中间节点分裂到父节点，两边节点分裂</p><p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据的工作流程：</p><ul><li><p>插入前 4 个字母 C N G A</p><p><img src="../image/post/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png" alt=""></p></li><li><p>插入 H，n&gt;4，中间元素 G 字母向上分裂到新的节点</p><p><img src="../image/post/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png" alt=""></p></li><li><p>插入 E、K、Q 不需要分裂</p><p><img src="../image/post/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B3.png" alt=""></p></li><li><p>插入 M，中间元素 M 字母向上分裂到父节点 G</p><p><img src="../image/post/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B4.png" alt=""></p></li><li><p>插入 F，W，L，T 不需要分裂</p><p><img src="../image/post/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B5.png" alt=""></p></li><li><p>插入 Z，中间元素 T 向上分裂到父节点中</p><p><img src="../image/post/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B6.png" alt=""></p></li><li><p>插入 D，中间元素 D 向上分裂到父节点中，然后插入 P，R，X，Y 不需要分裂</p><p><img src="../image/post/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B7.png" alt=""></p></li><li><p>最后插入 S，NPQR 节点 n&gt;5，中间节点 Q 向上分裂，但分裂后父节点 DGMT 的 n&gt;5，中间节点 M 向上分裂</p><p><img src="../image/post/MySQL-BTree%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B8.png" alt=""></p></li></ul><p>BTree 树就已经构建完成了，BTree 树和二叉树相比， 查询数据的效率更高， 因为对于相同的数据量来说，<strong>BTree 的层级结构比二叉树少</strong>，所以搜索速度快</p><p>BTree 结构的数据可以让系统高效的找到数据所在的磁盘块，定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key 值互不相同，BTree 中的每个节点根据实际情况可以包含大量的关键字信息和分支<br><img src="../image/post/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%861.png" alt=""></p><p>缺点：当进行范围查找时会出现回旋查找</p><hr><h4 id="B-Tree">B+Tree</h4><h5 id="数据结构">数据结构</h5><p>BTree 数据结构中每个节点中不仅包含数据的 key 值，还有 data 值。磁盘中每一页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率，所以引入 B+Tree</p><p>B+Tree 为 BTree 的变种，B+Tree 与 BTree 的区别为：</p><ul><li>n 叉 B+Tree 最多含有 n 个 key（哈希值），而 BTree 最多含有 n-1 个 key</li></ul><ul><li>所有<strong>非叶子节点只存储键值 key</strong> 信息，只进行数据索引，使每个非叶子节点所能保存的关键字大大增加</li><li>所有<strong>数据都存储在叶子节点</strong>，所以每次数据查询的次数都一样</li><li><strong>叶子节点按照 key 大小顺序排列，左边结尾数据都会保存右边节点开始数据的指针，形成一个链表</strong></li><li>所有节点中的 key 在叶子节点中也存在（比如 5)，<strong>key 允许重复</strong>，B 树不同节点不存在重复的 key</li></ul><img src="../image/post/MySQL-B%E5%8A%A0Tree%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" style="zoom:67%;" /><p>B* 树：是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针</p><hr><h5 id="优化结构">优化结构</h5><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化，在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，<strong>提高区间访问的性能，防止回旋查找</strong></p><p>区间访问的意思是访问索引为 5 - 15 的数据，可以直接根据相邻节点的指针遍历</p><p>B+ 树的<strong>叶子节点是数据页</strong>（page），一个页里面可以存多个数据行</p><p><img src="../image/post/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E7%90%862.png" alt=""></p><p>通常在 B+Tree 上有两个头指针，<strong>一个指向根节点，另一个指向关键字最小的叶子节点</strong>，而且所有叶子节点（即数据节点）之间是一种链式环结构。可以对 B+Tree 进行两种查找运算：</p><ul><li>有范围：对于主键的范围查找和分页查找</li><li>有顺序：从根节点开始，进行随机查找，顺序查找</li></ul><p>InnoDB 中每个数据页的大小默认是 16KB，</p><ul><li>索引行：一般表的主键类型为 INT（4 字节）或 BIGINT（8 字节），指针大小在 InnoDB 中设置为 6 字节节，也就是说一个页大概存储 16KB/(8B+6B)=1K 个键值（估值）。则一个深度为 3 的 B+Tree 索引可以维护 <code>10^3 * 10^3 * 10^3 = 10亿</code> 条记录</li><li>数据行：一行数据的大小可能是 1k，一个数据页可以存储 16 行</li></ul><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2-4 层。MySQL 的 InnoDB 存储引擎在设计时是<strong>将根节点常驻内存的</strong>，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作</p><p>B+Tree 优点：提高查询速度，减少磁盘的 IO 次数，树形结构较小</p><hr><h5 id="索引维护">索引维护</h5><p>B+ 树为了保持索引的有序性，在插入新值的时候需要做相应的维护</p><p>每个索引中每个块存储在磁盘页中，可能会出现以下两种情况：</p><ul><li>如果所在的数据页已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去，这个过程称为<strong>页分裂</strong>，原本放在一个页的数据现在分到两个页中，降低了空间利用率</li><li>当相邻两个页由于删除了数据，利用率很低之后，会将数据页做<strong>页合并</strong>，合并的过程可以认为是分裂过程的逆过程</li><li>这两个情况都是由 B+ 树的结构决定的</li></ul><p>一般选用数据小的字段做索引，字段长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</p><p>自增主键的插入数据模式，可以让主键索引尽量地保持递增顺序插入，不涉及到挪动其他记录，<strong>避免了页分裂</strong></p><h3 id="设计原则">设计原则</h3><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率</p><p>创建索引时的原则：</p><ul><li>对查询频次较高，且数据量比较大的表建立索引</li><li>使用唯一索引，区分度越高，使用索引的效率越高</li><li>索引字段的选择，最佳候选列应当从 where 子句的条件中提取，使用覆盖索引</li><li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的 I/O 效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升 MySQL 访问索引的 I/O 效率</li><li>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价越高。对于插入、更新、删除等 DML 操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低 DML 操作的效率，增加相应操作的时间消耗；另外索引过多的话，MySQL 也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但提高了选择的代价</li></ul><ul><li><p>MySQL 建立联合索引时会遵守<strong>最左前缀匹配原则</strong>，即最左优先，在检索数据时从联合索引的最左边开始匹配</p><p>N 个列组合而成的组合索引，相当于创建了 N 个索引，如果查询时 where 句中使用了组成该索引的<strong>前</strong>几个字段，那么这条查询 SQL 可以利用组合索引来提升查询效率</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 对name、address、phone列建一个联合索引</span><br><span class="line">ALTER TABLE user ADD INDEX index_three(name,address,phone);</span><br><span class="line">-- 查询语句执行时会依照最左前缀匹配原则，检索时分别会使用索引进行数据匹配。</span><br><span class="line">(name,address,phone)</span><br><span class="line">(name,address)</span><br><span class="line">(name,phone)-- 只有name字段走了索引</span><br><span class="line">(name)</span><br><span class="line"></span><br><span class="line">-- 索引的字段可以是任意顺序的，优化器会帮助我们调整顺序，下面的SQL语句可以命中索引</span><br><span class="line">SELECT * FROM user WHERE address = &#x27;北京&#x27; AND phone = &#x27;12345&#x27; AND name = &#x27;张三&#x27;;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 如果联合索引中最左边的列不包含在条件查询中，SQL语句就不会命中索引，比如：</span><br><span class="line">SELECT * FROM user WHERE address = &#x27;北京&#x27; AND phone = &#x27;12345&#x27;; </span><br></pre></td></tr></table></figure></li></ul><p>哪些情况不要建立索引：</p><ul><li>记录太少的表</li><li>经常增删改的表</li><li>频繁更新的字段不适合创建索引</li><li>where 条件里用不到的字段不创建索引</li></ul><hr><h3 id="索引相关概念">索引相关概念</h3><h4 id="覆盖索引">覆盖索引</h4><p>覆盖索引：包含所有满足查询需要的数据的索引（SELECT 后面的字段刚好是索引字段），可以利用该索引返回 SELECT 列表的字段，而不必根据索引去聚簇索引上读取数据文件</p><p>回表查询：要查找的字段不在非主键索引树上时，需要通过叶子节点的主键值去主键索引上获取对应的行数据</p><p>使用覆盖索引，防止回表查询：</p><ul><li><p>表 user 主键为 id，普通索引为 age，查询语句：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE age = 30;</span><br></pre></td></tr></table></figure><p>查询过程：先通过普通索引 age=30 定位到主键值 id=1，再通过聚集索引 id=1 定位到行记录数据，需要两次扫描 B+ 树</p></li><li><p>使用覆盖索引：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX idx_age ON user;</span><br><span class="line">CREATE INDEX idx_age_name ON user(age,name);</span><br><span class="line">SELECT id,age FROM user WHERE age = 30;</span><br></pre></td></tr></table></figure><p>在一棵索引树上就能获取查询所需的数据，无需回表速度更快</p></li></ul><p>使用覆盖索引，要注意 SELECT 列表中只取出需要的列，不可用 SELECT *，所有字段一起做索引会导致索引文件过大，查询性能下降</p><hr><h4 id="索引下推">索引下推</h4><p>索引条件下推优化（Index Condition Pushdown，ICP）是 MySQL5.6 添加，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><p>索引下推充分利用了索引中的数据，在查询出整行数据之前过滤掉无效的数据，再去主键索引树上查找</p><ul><li><p>不使用索引下推优化时存储引擎通过索引检索到数据，然后回表查询记录返回给 Server 层，<strong>服务器判断数据是否符合条件</strong></p><p><img src="../image/post/MySQL-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png" alt=""></p></li><li><p>使用索引下推优化时，如果<strong>存在某些被索引的列的判断条件</strong>时，由存储引擎在索引遍历的过程中判断数据是否符合传递的条件，将符合条件的数据进行回表，检索出来返回给服务器，由此减少 IO 次数</p><p><img src="../image/post/MySQL-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png" alt=""></p></li></ul><p><strong>适用条件</strong>：</p><ul><li>需要存储引擎将索引中的数据与条件进行判断（所以<strong>条件列必须都在同一个索引中</strong>），所以优化是基于存储引擎的，只有特定引擎可以使用，适用于 InnoDB 和 MyISAM</li><li>存储引擎没有调用跨存储引擎的能力，跨存储引擎的功能有存储过程、触发器、视图，所以调用这些功能的不可以进行索引下推优化</li><li>对于 InnoDB 引擎只适用于二级索引，InnoDB 的聚簇索引会将整行数据读到缓冲区，不再需要去回表查询了，索引下推的目的减少回表的 IO 次数也就失去了意义</li></ul><p>工作过程：用户表 user，(name, age) 是联合索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user WHERE name LIKE &#x27;张%&#x27; AND　age = 10;-- 头部模糊匹配会造成索引失效</span><br></pre></td></tr></table></figure><ul><li><p>优化前：在非主键索引树上找到满足第一个条件的行，然后通过叶子节点记录的主键值再回到主键索引树上查找到对应的行数据，再对比 AND 后的条件是否符合，符合返回数据，需要 4 次回表</p><p><img src="../image/post/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%961.png" alt=""></p></li><li><p>优化后：检查索引中存储的列信息是否符合索引条件，然后交由存储引擎用剩余的判断条件判断此行数据是否符合要求，<strong>不满足条件的不去读取表中的数据</strong>，满足下推条件的就根据主键值进行回表查询，2 次回表<br><img src="../image/post/MySQL-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%962.png" alt=""></p></li></ul><p>当使用 EXPLAIN 进行分析时，如果使用了索引条件下推，Extra 会显示 Using index condition</p><p>参考文章：<a href="https://blog.csdn.net/sinat_29774479/article/details/103470244">https://blog.csdn.net/sinat_29774479/article/details/103470244</a></p><p>参考文章：<a href="https://time.geekbang.org/column/article/69636">https://time.geekbang.org/column/article/69636</a></p><hr><h4 id="前缀索引">前缀索引</h4><p>当要索引的列字符很多时，索引会变大变慢，可以只索引列开始的部分字符串，节约索引空间，提高索引效率</p><p>注意：使用前缀索引就系统就忽略覆盖索引对查询性能的优化了</p><p>优化原则：<strong>降低重复的索引值</strong></p><p>比如地区表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">areagdpcode</span><br><span class="line">chinaShanghai100aaa</span><br><span class="line">chinaDalian200bbb</span><br><span class="line">usaNewYork300ccc</span><br><span class="line">chinaFuxin400ddd</span><br><span class="line">chinaBeijing500eee</span><br></pre></td></tr></table></figure><p>发现 area 字段很多都是以 china 开头的，那么如果以前 1-5 位字符做前缀索引就会出现大量索引值重复的情况，索引值重复性越低，查询效率也就越高，所以需要建立前 6 位字符的索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_area ON table_name(area(7));</span><br></pre></td></tr></table></figure><p>场景：存储身份证</p><ul><li>直接创建完整索引，这样可能比较占用空间</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题（前 6 位相同的很多）</li><li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描</li></ul><hr><h4 id="索引合并">索引合并</h4><p>使用多个索引来完成一次查询的执行方法叫做索引合并 index merge</p><ul><li><p>Intersection 索引合并：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>; # key1 和 key3 列都是单列索引、二级索引</span><br></pre></td></tr></table></figure><p>从不同索引中扫描到的记录的 id 值取<strong>交集</strong>（相同 id），然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p></li><li><p>Union 索引合并：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>从不同索引中扫描到的记录的 id 值取<strong>并集</strong>，然后执行回表操作，要求从每个二级索引获取到的记录都是按照主键值排序</p></li><li><p>Sort-Union 索引合并</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_test <span class="keyword">WHERE</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">&gt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p>先将从不同索引中扫描到的记录的主键值进行排序，再按照 Union 索引合并的方式进行查询</p></li></ul><p>索引合并算法的效率并不好，通过将其中的一个索引改成联合索引会优化效率</p><h3 id="索引优化">索引优化</h3><h4 id="创建索引">创建索引</h4><p>索引是数据库优化最重要的手段之一，通过索引通常可以帮助用户解决大多数的 MySQL 的性能优化问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_seller` (</span><br><span class="line">`sellerid` varchar (100),</span><br><span class="line">`name` varchar (100),</span><br><span class="line">`nickname` varchar (50),</span><br><span class="line">`password` varchar (60),</span><br><span class="line">`status` varchar (1),</span><br><span class="line">`address` varchar (100),</span><br><span class="line">`createtime` datetime,</span><br><span class="line">    PRIMARY KEY(`sellerid`)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=utf8mb4;</span><br><span class="line">INSERT INTO `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) values(&#x27;xiaomi&#x27;,&#x27;小米科技&#x27;,&#x27;小米官方旗舰店&#x27;,&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,&#x27;1&#x27;,&#x27;西安市&#x27;,&#x27;2088-01-01 12:00:00&#x27;);</span><br><span class="line">CREATE INDEX idx_seller_name_sta_addr ON tb_seller(name, status, address); # 联合索引</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.png" alt=""></p><hr><h4 id="避免失效">避免失效</h4><h5 id="语句错误">语句错误</h5><ul><li><p>全值匹配：对索引中所有列都指定具体值，这种情况索引生效，执行效率高</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%951.png" alt=""></p></li><li><p><strong>最左前缀法则</strong>：联合索引遵守最左前缀法则</p><p>匹配最左前缀法则，走索引：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%952.png" alt=""></p><p>违法最左前缀法则 ， 索引失效：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE status=&#x27;1&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE status=&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%953.png" alt=""></p><p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%954.png" alt=""></p><p>虽然索引列失效，但是系统会<strong>使用了索引下推进行了优化</strong></p></li><li><p><strong>范围查询</strong>右边的列，不能使用索引：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status&gt;&#x27;1&#x27; AND address=&#x27;西安市&#x27;;</span><br></pre></td></tr></table></figure><p>根据前面的两个字段 name ， status 查询是走索引的， 但是最后一个条件 address 没有用到索引，使用了索引下推</p><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%955.png" alt=""></p></li><li><p>在索引列上<strong>函数或者运算（+ - 数值）操作</strong>， 索引将失效：会破坏索引值的有序性</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE SUBSTRING(name,3,2) = &#x27;科技&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%956.png" alt=""></p></li><li><p><strong>字符串不加单引号</strong>，造成索引失效：隐式类型转换，当字符串和数字比较时会<strong>把字符串转化为数字</strong></p><p>在查询时，没有对字符串加单引号，查询优化器会调用 CAST 函数将 status 转换为 int 进行比较，造成索引失效</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; AND status = 1;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%957.png" alt=""></p><p>如果 status 是 int 类型，SQL 为 <code>SELECT * FROM tb_seller WHERE status = '1' </code> 并不会造成索引失效，因为会将 <code>'1'</code> 转换为 <code>1</code>，并<strong>不会对索引列产生操作</strong></p></li><li><p>多表连接查询时，如果两张表的<strong>字符集不同</strong>，会造成索引失效，因为会进行类型转换</p><p>解决方法：CONVERT 函数是加在输入参数上、修改表的字符集</p></li><li><p><strong>用 OR 分割条件，索引失效</strong>，导致全表查询：</p><p>OR 前的条件中的列有索引而后面的列中没有索引或 OR 前后两个列是同一个复合索引，都造成索引失效</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;阿里巴巴&#x27; OR createtime = &#x27;2088-01-01 12:00:00&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;小米科技&#x27; OR status=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9510.png" alt=""></p><p><strong>AND 分割的条件不影响</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name=&#x27;阿里巴巴&#x27; AND createtime = &#x27;2088-01-01 12:00:00&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9511.png" alt=""></p></li><li><p><strong>以 % 开头的 LIKE 模糊查询</strong>，索引失效：</p><p>如果是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引失效</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name like &#x27;%科技%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9512.png" alt=""></p><p>解决方案：通过覆盖索引来解决</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT sellerid,name,status FROM tb_seller WHERE name like &#x27;%科技%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9513.png" alt=""></p><p>原因：在覆盖索引的这棵 B+ 数上只需要进行 like 的匹配，或者是基于覆盖索引查询再进行 WHERE 的判断就可以获得结果</p></li></ul><hr><h5 id="系统优化">系统优化</h5><p>系统优化为全表扫描：</p><ul><li><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引，索引失效：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_address ON tb_seller(address);</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE address=&#x27;西安市&#x27;;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE address=&#x27;北京市&#x27;;</span><br></pre></td></tr></table></figure><p>北京市的键值占 9/10（区分度低），所以优化为全表扫描，type = ALL</p><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9514.png" alt=""></p></li><li><p>IS  NULL、IS NOT NULL  <strong>有时</strong>索引失效：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name IS NULL;</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE name IS NOT NULL;</span><br></pre></td></tr></table></figure><p>NOT NULL 失效的原因是 name 列全部不是 null，优化为全表扫描，当 NULL 过多时，IS NULL 失效</p><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%9515.png" alt=""></p></li><li><p>IN 肯定会走索引，但是当 IN 的取值范围较大时会导致索引失效，走全表扫描：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE sellerId IN (&#x27;alibaba&#x27;,&#x27;huawei&#x27;);-- 都走索引</span><br><span class="line">EXPLAIN SELECT * FROM tb_seller WHERE sellerId NOT IN (&#x27;alibaba&#x27;,&#x27;huawei&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://time.geekbang.org/column/article/74687">MySQL 实战 45 讲</a>该章节最后提出了一种场景，获取到数据以后 Server 层还会做判断</p></li></ul><hr><h4 id="底层原理">底层原理</h4><p>索引失效一般是针对联合索引，联合索引一般由几个字段组成，排序方式是先按照第一个字段进行排序，然后排序第二个，依此类推，图示（a, b）索引，<strong>a 相等的情况下 b 是有序的</strong></p><img src="../image/post/MySQL-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%861.png" style="zoom:67%;" /><ul><li><p>最左前缀法则：当不匹配前面的字段的时候，后面的字段都是无序的。这种无序不仅体现在叶子节点，也会<strong>导致查询时扫描的非叶子节点也是无序的</strong>，因为索引树相当于忽略的第一个字段，就无法使用二分查找</p></li><li><p>范围查询右边的列，不能使用索引，比如语句： <code>WHERE a &gt; 1 AND b = 1 </code>，在 a 大于 1 的时候，b 是无序的，a &gt; 1 是扫描时有序的，但是找到以后进行寻找 b 时，索引树就不是有序的了</p>  <img src="../image/post/MySQL-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%862.png" style="zoom:67%;" /></li><li><p>以 % 开头的 LIKE 模糊查询，索引失效，比如语句：<code>WHERE a LIKE '%d'</code>，前面的不确定，导致不符合最左匹配，直接去索引中搜索以 d 结尾的节点，所以没有顺序<br><img src="../image/post/MySQL-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%863.png" alt=""></p></li></ul><p>参考文章：<a href="https://mp.weixin.qq.com/s/B_M09dzLe9w7cT46rdGIeQ">https://mp.weixin.qq.com/s/B_M09dzLe9w7cT46rdGIeQ</a></p><hr><h4 id="查看索引">查看索引</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Handler_read%&#x27;;</span><br><span class="line">SHOW GLOBAL STATUS LIKE &#x27;Handler_read%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E4%BC%98%E5%8C%96SQL%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5.png" alt=""></p><ul><li>Handler_read_first：索引中第一条被读的次数，如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）</li><li>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，值越低表示索引不经常使用（这个值越高越好）</li><li>Handler_read_next：按照键顺序读下一行的请求数，如果范围约束或执行索引扫描来查询索引列，值增加</li><li>Handler_read_prev：按照键顺序读前一行的请求数，该读方法主要用于优化 ORDER BY … DESC</li><li>Handler_read_rnd：根据固定位置读一行的请求数，如果执行大量查询并对结果进行排序则该值较高，可能是使用了大量需要 MySQL 扫描整个表的查询或连接，这个值较高意味着运行效率低，应该建立索引来解决</li><li>Handler_read_rnd_next：在数据文件中读下一行的请求数，如果正进行大量的表扫描，该值较高，说明表索引不正确或写入的查询没有利用索引</li></ul><hr><h2 id="事务机制">事务机制</h2><h3 id="基本介绍-3">基本介绍</h3><p>事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个 SQL 语句，这些语句要么都执行，要么都不执行，作为一个关系型数据库，MySQL 支持事务。</p><p>单元中的每条 SQL 语句都相互依赖，形成一个整体</p><ul><li><p>如果某条 SQL 语句执行失败或者出现错误，那么整个单元就会回滚，撤回到事务最初的状态</p></li><li><p>如果单元中所有的 SQL 语句都执行成功，则事务就顺利执行</p></li></ul><p>事务的四大特征：ACID</p><ul><li>原子性 (atomicity)</li><li>一致性 (consistency)</li><li>隔离性 (isolaction)</li><li>持久性 (durability)</li></ul><p>事务的几种状态：</p><ul><li>活动的（active）：事务对应的数据库操作正在执行中</li><li>部分提交的（partially committed）：事务的最后一个操作执行完，但是内存还没刷新至磁盘</li><li>失败的（failed）：当事务处于活动状态或部分提交状态时，如果数据库遇到了错误或刷脏失败，或者用户主动停止当前的事务</li><li>中止的（aborted）：失败状态的事务回滚完成后的状态</li><li>提交的（committed）：当处于部分提交状态的事务刷脏成功，就处于提交状态</li></ul><hr><h3 id="事务管理">事务管理</h3><h4 id="基本操作">基本操作</h4><p>事务管理的三个步骤</p><ol><li><p>开启事务：记录回滚点，并通知服务器，将要执行一组操作，要么同时成功、要么同时失败</p></li><li><p>执行 SQL 语句：执行具体的一条或多条 SQL 语句</p></li><li><p>结束事务（提交|回滚）</p><ul><li>提交：没出现问题，数据进行更新</li><li>回滚：出现问题，数据恢复到开启事务时的状态</li></ul></li></ol><p>事务操作：</p><ul><li><p>显式开启事务</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION [READ ONLY|READ WRITE|WITH CONSISTENT SNAPSHOT]; #可以跟一个或多个状态，最后的是一致性读</span><br><span class="line">BEGIN [WORK];</span><br></pre></td></tr></table></figure><p>说明：不填状态默认是读写事务</p></li><li><p>回滚事务，用来手动中止事务</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure></li><li><p>提交事务，显示执行是手动提交，MySQL 默认为自动提交</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li><li><p>保存点：在事务的执行过程中设置的还原点，调用 ROLLBACK 时可以指定回滚到哪个点</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT point_name;#设置保存点</span><br><span class="line">RELEASE point_name#删除保存点</span><br><span class="line">ROLLBACK [WORK] TO [SAVEPOINT] point_name#回滚至某个保存点，不填默认回滚到事务执行之前的状态</span><br></pre></td></tr></table></figure></li><li><p>操作演示</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 张三给李四转账500元</span><br><span class="line">-- 1.张三账户-500</span><br><span class="line">UPDATE account SET money=money-500 WHERE NAME=&#x27;张三&#x27;;</span><br><span class="line">-- 2.李四账户+500</span><br><span class="line">UPDATE account SET money=money+500 WHERE NAME=&#x27;李四&#x27;;</span><br><span class="line"></span><br><span class="line">-- 回滚事务(出现问题)</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">-- 提交事务(没出现问题)</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="提交方式">提交方式</h4><p>提交方式的相关语法：</p><ul><li><p>查看事务提交方式</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@AUTOCOMMIT;  -- 会话，1 代表自动提交    0 代表手动提交</span><br><span class="line">SELECT @@GLOBAL.AUTOCOMMIT;-- 系统</span><br></pre></td></tr></table></figure></li><li><p>修改事务提交方式</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @@AUTOCOMMIT=数字;-- 系统</span><br><span class="line">SET AUTOCOMMIT=数字;-- 会话</span><br></pre></td></tr></table></figure></li><li><p><strong>系统变量的操作</strong>：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] 变量名 <span class="operator">=</span> 值;<span class="comment">-- 默认是会话</span></span><br><span class="line"><span class="keyword">SET</span> @@[(<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION).]变量名 <span class="operator">=</span> 值;<span class="comment">-- 默认是系统</span></span><br></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] VARIABLES [<span class="keyword">LIKE</span> <span class="string">&#x27;变量%&#x27;</span>];  <span class="comment">-- 默认查看会话内系统变量值</span></span><br></pre></td></tr></table></figure></li></ul><p>工作原理：</p><ul><li>自动提交：如果没有 START TRANSACTION 显式地开始一个事务，那么<strong>每条 SQL 语句都会被当做一个事务执行提交操作</strong>；显式开启事务后，会在本次事务结束（提交或回滚）前暂时关闭自动提交</li><li>手动提交：不需要显式的开启事务，所有的 SQL 语句都在一个事务中，直到执行了提交或回滚，然后进入下一个事务</li><li>隐式提交：存在一些特殊的命令，在事务中执行了这些命令会马上<strong>强制执行 COMMIT 提交事务</strong><ul><li><strong>DDL 语句</strong> (CREATE/DROP/ALTER)、LOCK TABLES 语句、LOAD DATA 导入数据语句、主从复制语句等</li><li>当一个事务还没提交或回滚，显式的开启一个事务会隐式的提交上一个事务</li></ul></li></ul><hr><h4 id="事务-ID">事务 ID</h4><p>事务在执行过程中对某个表执行了<strong>增删改操作或者创建表</strong>，就会为当前事务分配一个独一无二的事务 ID（对临时表并不会分配 ID），如果当前事务没有被分配 ID，默认是 0</p><p>说明：只读事务不能对普通的表进行增删改操作，但是可以对临时表增删改，读写事务可以对数据表执行增删改查操作</p><p>事务 ID 本质上就是一个数字，服务器在内存中维护一个全局变量：</p><ul><li>每当需要为某个事务分配 ID，就会把全局变量的值赋值给事务 ID，然后变量自增 1</li><li>每当变量值为 256 的倍数时，就将该变量的值刷新到系统表空间的 Max Trx ID 属性中，该属性占 8 字节</li><li>系统再次启动后，会读取表空间的 Max Trx ID 属性到内存，加上 256 后赋值给全局变量，因为关机时的事务 ID 可能并不是 256 的倍数，会比 Max Trx ID 大，所以需要加上 256 保持事务 ID 是一个<strong>递增的数字</strong></li></ul><p><strong>聚簇索引</strong>的行记录除了完整的数据，还会自动添加 trx_id、roll_pointer 隐藏列，如果表中没有主键并且没有非空唯一索引，也会添加一个 row_id 的隐藏列作为聚簇索引</p><hr><h3 id="隔离级别">隔离级别</h3><h4 id="四种级别">四种级别</h4><p>事务的隔离级别：多个客户端操作时，各个客户端的事务之间应该是隔离的，<strong>不同的事务之间不该互相影响</strong>，而如果多个事务操作同一批数据时，则需要设置不同的隔离级别，否则就会产生问题。</p><p>隔离级别分类：</p><table><thead><tr><th>隔离级别</th><th>名称</th><th>会引发的问题</th><th>数据库默认隔离级别</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>读未提交</td><td>脏读、不可重复读、幻读</td><td></td></tr><tr><td>Read Committed</td><td>读已提交</td><td>不可重复读、幻读</td><td>Oracle / SQL Server</td></tr><tr><td>Repeatable Read</td><td>可重复读</td><td>幻读</td><td>MySQL</td></tr><tr><td>Serializable</td><td>可串行化</td><td>无</td><td></td></tr></tbody></table><p>一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差</p><ul><li><p>脏写 (Dirty Write)：当两个或多个事务选择同一行，最初的事务修改的值被后面事务修改的值覆盖，所有的隔离级别都可以避免脏写（又叫丢失更新），因为有行锁</p></li><li><p>脏读 (Dirty Reads)：在一个事务处理过程中读取了另一个<strong>未提交</strong>的事务中修改过的数据</p></li><li><p>不可重复读 (Non-Repeatable Reads)：在一个事务处理过程中读取了另一个事务中修改并<strong>已提交</strong>的数据</p><blockquote><p>可重复读的意思是不管读几次，结果都一样，可以重复的读，可以理解为快照读，要读的数据集不会发生变化</p></blockquote></li><li><p>幻读 (Phantom Reads)：在事务中按某个条件先后两次查询数据库，后一次查询查到了前一次查询没有查到的行，<strong>数据条目</strong>发生了变化。比如查询某数据不存在，准备插入此记录，但执行插入时发现此记录已存在，无法插入</p></li></ul><p>隔离级别操作语法：</p><ul><li><p>查询数据库隔离级别</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@TX_ISOLATION;-- 会话</span><br><span class="line">SELECT @@GLOBAL.TX_ISOLATION;-- 系统</span><br></pre></td></tr></table></figure></li><li><p>修改数据库隔离级别</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="加锁分析">加锁分析</h4><p>InnoDB 存储引擎支持事务，所以加锁分析是基于该存储引擎</p><ul><li><p>Read Uncommitted 级别，任何操作都不会加锁</p></li><li><p>Read Committed 级别，增删改操作会加写锁（行锁），读操作不加锁</p><p>在 Server 层过滤条件时发现不满足的记录会调用 unlock_row 方法释放该记录的行锁，保证最后只有满足条件的记录加锁，但是扫表过程中每条记录的<strong>加锁操作不能省略</strong>。所以对数据量很大的表做批量修改时，如果无法使用相应的索引（全表扫描），在Server 过滤数据时就会特别慢，出现虽然没有修改某些行的数据，但是还是被锁住了的现象（锁表），这种情况同样适用于  RR</p></li><li><p>Repeatable Read 级别，增删改操作会加写锁，读操作不加锁。因为读写锁不兼容，<strong>加了读锁后其他事务就无法修改数据</strong>，影响了并发性能，为了保证隔离性和并发性，MySQL 通过 MVCC 解决了读写冲突。RR 级别下的锁有很多种，锁机制章节详解</p></li><li><p>Serializable 级别，读加共享锁，写加排他锁，读写互斥，使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差</p><ul><li>串行化：让所有事务按顺序单独执行，写操作会加写锁，读操作会加读锁</li><li>可串行化：让所有操作相同数据的事务顺序执行，通过加锁实现</li></ul></li></ul><p>参考文章：<a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p><hr><h3 id="原子特性">原子特性</h3><h4 id="实现方式">实现方式</h4><p>原子性是指事务是一个不可分割的工作单位，事务的操作如果成功就必须要完全应用到数据库，失败则不能对数据库有任何影响。比如事务中一个 SQL 语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态</p><p>InnoDB 存储引擎提供了两种事务日志：redo log（重做日志）和 undo log（回滚日志）</p><ul><li>redo log 用于保证事务持久性</li><li>undo log 用于保证事务原子性和隔离性</li></ul><p>undo log 属于逻辑日志，根据每行操作进行记录，记录了 SQL 执行相关的信息，用来回滚行记录到某个版本</p><p>当事务对数据库进行修改时，InnoDB 会先记录对应的 undo log，如果事务执行失败或调用了 rollback 导致事务回滚，InnoDB 会根据 undo log 的内容<strong>做与之前相反的操作</strong>：</p><ul><li><p>对于每个 insert，回滚时会执行 delete</p></li><li><p>对于每个 delete，回滚时会执行 insert</p></li><li><p>对于每个 update，回滚时会执行一个相反的 update，把数据修改回去</p></li></ul><p>参考文章：<a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></p><hr><h4 id="DML-解析">DML 解析</h4><h5 id="INSERT">INSERT</h5><p>乐观插入：当前数据页的剩余空间充足，直接将数据进行插入</p><p>悲观插入：当前数据页的剩余空间不足，需要进行页分裂，申请一个新的页面来插入数据，会造成更多的 redo log，undo log 影响不大</p><p>当向某个表插入一条记录，实际上需要向聚簇索引和所有二级索引都插入一条记录，但是 undo log <strong>只针对聚簇索引记录</strong>，在回滚时会根据聚簇索引去所有的二级索引进行回滚操作</p><p>roll_pointer 是一个指针，<strong>指向记录对应的 undo log 日志</strong>，一条记录就是一个数据行，行格式中的 roll_pointer 就指向 undo log</p><hr><h5 id="DELETE">DELETE</h5><p>插入到页面中的记录会根据 next_record 属性组成一个单向链表，这个链表称为正常链表，被删除的记录也会通过 next_record 组成一个垃圾链表，该链表中所占用的存储空间可以被重新利用，并不会直接清除数据</p><p>在页面 Page Header 中，PAGE_FREE 属性指向垃圾链表的头节点，删除的工作过程：</p><ul><li><p>将要删除的记录的 delete_flag 位置为 1，其他不做修改，这个过程叫 <strong>delete mark</strong></p></li><li><p>在事务提交前，delete_flag = 1 的记录一直都会处于中间状态</p></li><li><p>事务提交后，有专门的线程将 delete_flag = 1 的记录从正常链表移除并加入垃圾链表，这个过程叫 <strong>purge</strong></p><p>purge 线程在执行删除操作时会创建一个 ReadView，根据事务的可见性移除数据（隔离特性部分详解）</p></li></ul><p>当有新插入的记录时，首先判断 PAGE_FREE 指向的头节点是否足够容纳新纪录：</p><ul><li>如果可以容纳新纪录，就会直接重用已删除的记录的存储空间，然后让 PAGE_FREE 指向垃圾链表的下一个节点</li><li>如果不能容纳新纪录，就直接向页面申请新的空间存储，并不会遍历垃圾链表</li></ul><p>重用已删除的记录空间，可能会造成空间碎片，当数据页容纳不了一条记录时，会判断将碎片空间加起来是否可以容纳，判断为真就会重新组织页内的记录：</p><ul><li>开辟一个临时页面，将页内记录一次插入到临时页面，此时临时页面时没有碎片的</li><li>把临时页面的内容复制到本页，这样就解放出了内存碎片，但是会耗费很大的性能资源</li></ul><hr><h5 id="UPDATE">UPDATE</h5><p>执行 UPDATE 语句，对于更新主键和不更新主键有两种不同的处理方式</p><p>不更新主键的情况：</p><ul><li><p>就地更新（in-place update），如果更新后的列和更新前的列占用的存储空间一样大，就可以直接在原记录上修改</p></li><li><p>先删除旧纪录，再插入新纪录，这里的删除不是 delete mark，而是直接将记录加入垃圾链表，并且修改页面的相应的控制信息，执行删除的线程不是 purge，是执行更新的用户线程，插入新记录时可能造成页空间不足，从而导致页分裂</p></li></ul><p>更新主键的情况：</p><ul><li>将旧纪录进行 delete mark，在更新语句提交后由 purge 线程移入垃圾链表</li><li>根据更新的各列的值创建一条新纪录，插入到聚簇索引中</li></ul><p>在对一条记录修改前会<strong>将记录的隐藏列 trx_id 和 roll_pointer 的旧值记录到 undo log 对应的属性中</strong>，这样当前记录的 roll_pointer 指向当前 undo log 记录，当前 undo log 记录的 roll_pointer 指向旧的 undo log 记录，<strong>形成一个版本链</strong></p><p>UPDATE、DELETE 操作产生的 undo 日志可能会用于其他事务的 MVCC 操作，所以不能立即删除</p><hr><h4 id="回滚日志">回滚日志</h4><p>undo log 是采用段的方式来记录，Rollback Segement 称为回滚段，本质上就是一个类型是 Rollback Segement Header 的页面</p><p>每个回滚段中有 1024 个 undo slot，每个 slot 存放 undo 链表页面的头节点页号，每个链表对应一个叫 undo log segment 的段</p><ul><li>在以前老版本，只支持 1 个 Rollback Segement，只能记录 1024 个 undo log segment</li><li>MySQL5.5 开始支持 128 个 Rollback Segement，支持 128*1024 个 undo 操作</li></ul><p>工作流程：</p><ul><li><p>事务执行前需要到系统表空间第 5 号页面中分配一个回滚段（页），获取一个 Rollback Segement Header 页面的地址</p></li><li><p>回滚段页面有 1024 个 undo slot，首先去回滚段的两个 cached 链表获取缓存的 slot，缓存中没有就在回滚段页面中找一个可用的 undo slot 分配给当前事务</p></li><li><p>如果是缓存中获取的 slot，则该 slot 对应的 undo log segment 已经分配了，需要重新分配，然后从 undo log segment 中申请一个页面作为日志链表的头节点，并填入对应的 slot 中</p></li><li><p>每个事务 undo 日志在记录的时候<strong>占用两个 undo 页面的组成链表</strong>，分别为 insert undo 链表和 update undo 链表，链表的头节点页面为 first undo page 会包含一些管理信息，其他页面为 normal undo page</p><p>说明：事务执行过程的临时表也需要两个 undo 链表，不和普通表共用，这些链表并不是事务开始就分配，而是按需分配</p></li></ul><hr><h3 id="隔离特性">隔离特性</h3><h4 id="实现方式-2">实现方式</h4><p>隔离性是指，事务内部的操作与其他事务是隔离的，多个并发事务之间要相互隔离，不能互相干扰</p><ul><li><p>严格的隔离性，对应了事务隔离级别中的 serializable，实际应用中对性能考虑很少使用可串行化</p></li><li><p>与原子性、持久性侧重于研究事务本身不同，隔离性研究的是<strong>不同事务</strong>之间的相互影响</p></li></ul><p>隔离性让并发情形下的事务之间互不干扰：</p><ul><li>一个事务的写操作对另一个事务的写操作（写写）：锁机制保证隔离性</li><li>一个事务的写操作对另一个事务的读操作（读写）：MVCC 保证隔离性</li></ul><p>锁机制：事务在修改数据之前，需要先获得相应的锁，获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁（详解见锁机制）</p><hr><h4 id="并发控制">并发控制</h4><p>MVCC 全称 Multi-Version Concurrency Control，即多版本并发控制，用来<strong>解决读写冲突的无锁并发控制</strong>，可以在发生读写请求冲突时不用加锁解决，这个读是指的快照读（也叫一致性读或一致性无锁读），而不是当前读：</p><ul><li>快照读：实现基于 MVCC，因为是多版本并发，所以快照读读到的数据不一定是当前最新的数据，有可能是历史版本的数据</li><li>当前读：又叫加锁读，读取数据库记录是当前<strong>最新的版本</strong>（产生幻读、不可重复读），可以对读取的数据进行加锁，防止其他事务修改数据，是悲观锁的一种操作，读写操作加共享锁或者排他锁和串行化事务的隔离级别都是当前读</li></ul><p>数据库并发场景：</p><ul><li><p>读-读：不存在任何问题，也不需要并发控制</p></li><li><p>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</p></li><li><p>写-写：有线程安全问题，可能会存在脏写（丢失更新）问题</p></li></ul><p>MVCC 的优点：</p><ul><li>在并发读写数据库时，做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了并发读写的性能</li><li>可以解决脏读，不可重复读等事务隔离问题（加锁也能解决），但不能解决更新丢失问题（写锁会解决）</li></ul><p>提高读写和写写的并发性能：</p><ul><li>MVCC + 悲观锁：MVCC 解决读写冲突，悲观锁解决写写冲突</li><li>MVCC + 乐观锁：MVCC 解决读写冲突，乐观锁解决写写冲突</li></ul><p>参考文章：<a href="https://www.jianshu.com/p/8845ddca3b23">https://www.jianshu.com/p/8845ddca3b23</a></p><hr><h4 id="实现原理">实现原理</h4><h5 id="隐藏字段">隐藏字段</h5><p>实现原理主要是隐藏字段，undo日志，Read View 来实现的</p><p>InnoDB 存储引擎，数据库中的<strong>聚簇索引</strong>每行数据，除了自定义的字段，还有数据库隐式定义的字段：</p><ul><li>DB_TRX_ID：最近修改事务 ID，记录创建该数据或最后一次修改该数据的事务 ID</li><li>DB_ROLL_PTR：回滚指针，<strong>指向记录对应的 undo log 日志</strong>，undo log 中又指向上一个旧版本的 undo log</li><li>DB_ROW_ID：隐含的自增 ID（<strong>隐藏主键</strong>），如果数据表没有主键，InnoDB 会自动以 DB_ROW_ID 作为聚簇索引</li></ul><p><img src="../image/post/MySQL-MVCC%E7%89%88%E6%9C%AC%E9%93%BE%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png" alt=""></p><hr><h5 id="版本链">版本链</h5><p>undo log 是逻辑日志，记录的是每个事务对数据执行的操作，而不是记录的全部数据，要<strong>根据 undo log 逆推出以往事务的数据</strong></p><p>undo log 的作用：</p><ul><li>保证事务进行 rollback 时的原子性和一致性，当事务进行回滚的时候可以用 undo log 的数据进行恢复</li><li>用于 MVCC 快照读，通过读取 undo log 的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本</li></ul><p>undo log 主要分为两种：</p><ul><li><p>insert undo log：事务在 insert 新记录时产生的 undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃</p></li><li><p>update undo log：事务在进行 update 或 delete 时产生的 undo log，在事务回滚时需要，在快照读时也需要。不能随意删除，只有在当前读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除</p></li></ul><p>每次对数据库记录进行改动，都会产生的新版本的 undo log，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，把这个链表称之为<strong>版本链</strong>，版本链的头节点就是当前的最新的 undo log，链尾就是最早的旧 undo log</p><p>说明：因为 DELETE 删除记录，都是移动到垃圾链表中，不是真正的删除，所以才可以通过版本链访问原始数据</p><img src="../image/post/MySQL-MVCC%E7%89%88%E6%9C%AC%E9%93%BE.png" style="zoom: 80%;" /><p>注意：undo 是逻辑日志，这里只是直观的展示出来</p><p>工作流程：</p><ul><li>有个事务插入 persion 表一条新记录，name 为 Jerry，age 为 24</li><li>事务 1 修改该行数据时，数据库会先对该行加排他锁，然后先记录 undo log，然后修改该行 name 为 Tom，并且修改隐藏字段的事务 ID 为当前事务 1 的 ID（默认为 1 之后递增），回滚指针指向拷贝到 undo log 的副本记录，事务提交后，释放锁</li><li>以此类推</li></ul><hr><h5 id="读视图">读视图</h5><p>Read View 是事务进行读数据操作时产生的读视图，该事务执行快照读的那一刻会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID，用来做可见性判断，根据视图判断当前事务能够看到哪个版本的数据</p><p>注意：这里的快照并不是把所有的数据拷贝一份副本，而是由 undo log 记录的逻辑日志，根据库中的数据进行计算出历史数据</p><p>工作流程：将版本链的头节点的事务 ID（最新数据事务 ID，大概率不是当前线程）DB_TRX_ID 取出来，与系统当前活跃事务的 ID 对比进行可见性分析，不可见就通过 DB_ROLL_PTR 回滚指针去取出 undo log 中的下一个 DB_TRX_ID 比较，直到找到最近的满足可见性的 DB_TRX_ID，该事务 ID 所在的旧记录就是当前事务能看见的最新的记录</p><p>Read View 几个属性：</p><ul><li>m_ids：生成 Read View 时当前系统中活跃的事务 id 列表（未提交的事务集合，当前事务也在其中）</li><li>min_trx_id：生成 Read View 时当前系统中活跃的最小的事务 id，也就是 m_ids 中的最小值（已提交的事务集合）</li><li>max_trx_id：生成 Read View 时当前系统应该分配给下一个事务的 id 值，m_ids 中的最大值加 1（未开始事务）</li><li>creator_trx_id：生成该 Read View 的事务的事务 id，就是判断该 id 的事务能读到什么数据</li></ul><p>creator 创建一个 Read View，进行可见性算法分析：（解决了读未提交）</p><ul><li><p>db_trx_id == creator_trx_id：表示这个数据就是当前事务自己生成的，自己生成的数据自己肯定能看见，所以此数据对 creator 是可见的</p></li><li><p>db_trx_id &lt;  min_trx_id：该版本对应的事务 ID 小于 Read view 中的最小活跃事务 ID，则这个事务在当前事务之前就已经被提交了，对 creator 可见（因为比已提交的最大事务 ID 小的并不一定已经提交，所以应该先判断是否在活跃事务列表）</p></li><li><p>db_trx_id &gt;= max_trx_id：该版本对应的事务 ID 大于 Read view 中当前系统的最大事务 ID，则说明该数据是在当前 Read view 创建之后才产生的，对 creator 不可见</p></li><li><p>min_trx_id&lt;= db_trx_id &lt; max_trx_id：判断 db_trx_id 是否在活跃事务列表 m_ids 中</p><ul><li>在列表中，说明该版本对应的事务正在运行，数据不能显示（<strong>不能读到未提交的数据</strong>）</li><li>不在列表中，说明该版本对应的事务已经被提交，数据可以显示（<strong>可以读到已经提交的数据</strong>）</li></ul></li></ul><hr><h5 id="工作流程-2">工作流程</h5><p>表 user 数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>nameage</span><br><span class="line">1张三   18</span><br></pre></td></tr></table></figure><p>Transaction 20：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;-- 开启事务</span><br><span class="line">UPDATE user SET name = &#x27;李四&#x27; WHERE id = 1;</span><br><span class="line">UPDATE user SET name = &#x27;王五&#x27; WHERE id = 1;</span><br></pre></td></tr></table></figure><p>Transaction 60：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;-- 开启事务</span><br><span class="line">-- 操作表的其他数据</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B1.png" alt=""></p><p>ID 为 0 的事务创建 Read View：</p><ul><li>m_ids：20、60</li><li>min_trx_id：20</li><li>max_trx_id：61</li><li>creator_trx_id：0</li></ul><p><img src="../image/post/MySQL-MVCC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png" alt=""></p><p>只有红框部分才复合条件，所以只有张三对应的版本的数据可以被看到</p><p>参考视频：<a href="https://www.bilibili.com/video/BV1t5411u7Fg">https://www.bilibili.com/video/BV1t5411u7Fg</a></p><hr><h5 id="二级索引">二级索引</h5><p>只有在聚簇索引中才有 trx_id 和 roll_pointer 的隐藏列，对于二级索引判断可见性的方式：</p><ul><li>二级索引页面的 Page Header 中有一个 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，SELECT 语句访问某个二级索引时会判断 ReadView 的 min_trx_id 是否大于该属性，大于说明该页面的所有属性对 ReadView 可见</li><li>如果属性判断不可见，就需要利用二级索引获取主键值进行<strong>回表操作</strong>，得到聚簇索引后按照聚簇索引的可见性判断的方法操作</li></ul><hr><h4 id="RC-RR">RC RR</h4><p>Read View 用于支持 RC（Read Committed，读已提交）和 RR（Repeatable Read，可重复读）隔离级别的实现，所以 <strong>SELECT 在 RC 和 RR 隔离级别使用 MVCC 读取记录</strong></p><p>RR、RC 生成时机：</p><ul><li>RC 隔离级别下，每次读取数据前都会生成最新的 Read View（当前读）</li><li>RR 隔离级别下，在第一次数据读取时才会创建 Read View（快照读）</li></ul><p>RC、RR 级别下的 InnoDB 快照读区别</p><ul><li><p>RC 级别下，事务中每次快照读都会新生成一个 Read View，这就是在 RC 级别下的事务中可以看到别的事务提交的更新的原因</p></li><li><p>RR 级别下，某个事务的对某条记录的<strong>第一次快照读</strong>会创建一个 Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，使用的是同一个 Read View，所以一个事务的查询结果每次都是相同的</p><p>RR 级别下，通过 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code> 开启事务，会在执行该语句后立刻生成一个 Read View，不是在执行第一条 SELECT 语句时生成（所以说 <code>START TRANSACTION</code> 并不是事务的起点，执行第一条语句才算起点）</p></li></ul><p>解决幻读问题：</p><ul><li><p>快照读：通过 MVCC 来进行控制的，在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，但是<strong>并不能完全避免幻读</strong></p><p>场景：RR 级别，T1 事务开启，创建 Read View，此时 T2 去 INSERT 新的一行然后提交，然后 T1 去 UPDATE 该行会发现更新成功，并且把这条新记录的 trx_id 变为当前的事务 id，所以对当前事务就是可见的。因为 <strong>Read View 并不能阻止事务去更新数据，更新数据都是先读后写并且是当前读</strong>，读取到的是最新版本的数据</p></li><li><p>当前读：通过 next-key 锁（行锁 + 间隙锁）来解决问题</p></li></ul><hr><h3 id="持久特性">持久特性</h3><h4 id="实现方式-3">实现方式</h4><p>持久性是指一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，接下来的其他操作或故障不应该对其有任何影响。</p><p>Buffer Pool 的使用提高了读写数据的效率，但是如果 MySQL 宕机，此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证，所以引入了 redo log 日志：</p><ul><li>redo log <strong>记录数据页的物理修改</strong>，而不是某一行或某几行的修改，用来恢复提交后的数据页，只能<strong>恢复到最后一次提交</strong>的位置</li><li>redo log 采用的是 WAL（Write-ahead logging，<strong>预写式日志</strong>），所有修改要先写入日志，再更新到磁盘，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求</li><li>简单的 redo log 是纯粹的物理日志，负责的 redo log 会存在物理日志和逻辑日志</li></ul><p>工作过程：MySQL 发生了宕机，InnoDB 会判断一个数据页在崩溃恢复时丢失了更新，就会将它读到内存，然后根据 redo log 内容更新内存，更新完成后，内存页变成脏页，然后进行刷脏</p><p>缓冲池的<strong>刷脏策略</strong>：</p><ul><li>redo log 文件是固定大小的，如果写满了就要擦除以前的记录，在擦除之前需要把对应的更新持久化到磁盘中</li><li>Buffer Pool 内存不足，需要淘汰部分数据页（LRU 链表尾部），如果淘汰的是脏页，就要先将脏页写到磁盘（要避免大事务）</li><li>系统空闲时，后台线程会自动进行刷脏（Flush 链表部分已经详解）</li><li>MySQL 正常关闭时，会把内存的脏页都刷新到磁盘上</li></ul><hr><h4 id="重做日志">重做日志</h4><h5 id="日志缓冲">日志缓冲</h5><p>服务器启动时会向操作系统申请一片连续内存空间作为 redo log buffer（重做日志缓冲区），可以通过 <code>innodb_log_buffer_size</code> 系统变量指定 redo log buffer 的大小，默认是 16MB</p><p>log buffer 被划分为若干 redo log block（块，类似数据页的概念），每个默认大小 512 字节，每个 block 由 12 字节的 log block head、496 字节的 log block body、4 字节的 log block trailer 组成</p><ul><li>当数据修改时，先修改 Change Buffer 中的数据，然后在 redo log buffer 记录这次操作，写入 log buffer 的过程是<strong>顺序写入</strong>的（先写入前面的 block，写满后继续写下一个）</li><li>log buffer 中有一个指针 buf_free，来标识该位置之前都是填满的 block，该位置之后都是空闲区域（<strong>碰撞指针</strong>）</li></ul><p>MySQL 规定对底层页面的一次原子访问称为一个 Mini-Transaction（MTR），比如在 B+ 树上插入一条数据就算一个 MTR</p><ul><li><p>一个事务包含若干个 MTR，一个 MTR 对应一组若干条 redo log，一组 redo log 是不可分割的，在进行数据恢复时也把一组 redo log 当作一个不可分割的整体处理</p></li><li><p>所以不是每生成一条 redo 日志就将其插入到 log buffer 中，而是一个 MTR 结束后<strong>将一组 redo 日志写入 log buffer</strong></p></li></ul><p>InnoDB 的 redo log 是<strong>固定大小</strong>的，redo 日志在磁盘中以文件组的形式存储，同一组中的每个文件大小一样格式一样，</p><ul><li><code>innodb_log_group_home_dir</code> 代表磁盘存储 redo log 的文件目录，默认是当前数据目录</li><li><code>innodb_log_file_size</code> 代表文件大小，默认 48M，<code>innodb_log_files_in_group</code> 代表文件个数，默认 2 最大 100，所以日志的文件大小为 <code>innodb_log_file_size * innodb_log_files_in_group</code></li></ul><p>redo 日志文件也是由若干个 512 字节的 block 组成，日志文件的前 2048 个字节（前 4 个 block）用来存储一些管理信息，以后的用来存储 log buffer 中的 block 镜像</p><p>注意：block 并不代表一组 redo log，一组日志可能占用不到一个 block 或者几个 block，依赖于 MTR 的大小</p><hr><h5 id="日志刷盘">日志刷盘</h5><p>redo log 需要在事务提交时将日志写入磁盘，但是比将内存中的 Buffer Pool 修改的数据写入磁盘的速度快，原因：</p><ul><li>刷脏是随机 IO，因为每次修改的数据位置随机；redo log 和 binlog 都是<strong>顺序写</strong>，磁盘的顺序 IO 比随机 IO 速度要快</li><li>刷脏是以数据页（Page）为单位的，一个页上的一个小修改都要整页写入；redo log 中只包含真正需要写入的部分，减少无效 IO</li><li><strong>组提交机制</strong>，可以大幅度降低磁盘的 IO 消耗</li></ul><p>InnoDB 引擎会在适当的时候，把内存中 redo log buffer 持久化（fsync）到磁盘，具体的<strong>刷盘策略</strong>：</p><ul><li>在事务提交时需要进行刷盘，通过修改参数 <code>innodb_flush_log_at_trx_commit</code> 设置：<ul><li>0：表示当提交事务时，并不将缓冲区的 redo 日志写入磁盘，而是等待<strong>后台线程每秒刷新一次</strong></li><li>1：在事务提交时将缓冲区的 redo 日志<strong>同步写入</strong>到磁盘，保证一定会写入成功（默认值）</li><li>2：在事务提交时将缓冲区的 redo 日志异步写入到磁盘，不能保证提交时肯定会写入，只是有这个动作。日志已经在操作系统的缓存，如果操作系统没有宕机而 MySQL 宕机，也是可以恢复数据的</li></ul></li><li>写入 redo log buffer 的日志超过了总容量的一半，就会将日志刷入到磁盘文件，这会影响执行效率，所以开发中应<strong>避免大事务</strong></li><li>服务器关闭时</li><li>checkpoint 时（下小节详解）</li><li>并行的事务提交（组提交）时，会将将其他事务的 redo log 持久化到磁盘。假设事务 A 已经写入 redo log  buffer 中，这时另外一个线程的事务 B 提交，如果 innodb_flush_log_at_trx_commit 设置的是 1，那么事务 B 要把 redo log buffer 里的日志全部持久化到磁盘，<strong>因为多个事务共用一个 redo log buffer</strong>，所以一次 fsync 可以刷盘多个事务的 redo log，提升了并发量</li></ul><p>服务器启动后 redo 磁盘空间不变，所以 redo 磁盘中的日志文件是被<strong>循环使用</strong>的，采用循环写数据的方式，写完尾部重新写头部，所以要确保头部 log 对应的修改已经持久化到磁盘</p><hr><h5 id="日志序号">日志序号</h5><p>lsn (log sequence number) 代表已经写入的 redo 日志量、flushed_to_disk_lsn 指刷新到磁盘中的 redo 日志量，两者都是<strong>全局变量</strong>，如果两者的值相同，说明 log buffer 中所有的 redo 日志都已经持久化到磁盘</p><p>工作过程：写入 log buffer 数据时，buf_free 会进行偏移，偏移量就会加到 lsn 上</p><p>MTR 的执行过程中修改过的页对应的控制块会加到 Buffer Pool 的 flush 链表中，链表中脏页是按照第一次修改的时间进行排序的（头插），控制块中有两个指针用来记录脏页被修改的时间：</p><ul><li>oldest_modification：第一次修改 Buffer Pool 中某个缓冲页时，将修改该页的 MTR <strong>开始时</strong>对应的 lsn 值写入这个属性，所以链表页是以该值进行排序的</li><li>newest_modification：每次修改页面，都将 MTR 结束时全局的 lsn 值写入这个属性，所以该值是该页面最后一次修改后的 lsn 值</li></ul><p>全局变量 checkpoint_lsn 表示<strong>当前系统可以被覆盖的 redo 日志总量</strong>，当 redo 日志对应的脏页已经被刷新到磁盘后，该文件空间就可以被覆盖重用，此时执行一次 checkpoint 来更新 checkpoint_lsn 的值存入管理信息（刷脏和执行一次 checkpoint 并不是同一个线程），该值的增量就代表磁盘文件中当前位置向后可以被覆盖的文件的量，所以该值是一直增大的</p><p><strong>checkpoint</strong>：从 flush 链表尾部中找出还未刷脏的页面，该页面是当前系统中最早被修改的脏页，该页面之前产生的脏页都已经刷脏，然后将该页 oldest_modification 值赋值给 checkpoint_lsn，因为 lsn 小于该值时产生的 redo 日志都可以被覆盖了</p><p>但是在系统忙碌时，后台线程的刷脏操作不能将脏页快速刷出，导致系统无法及时执行 checkpoint ，这时需要用户线程从 flush 链表中把最早修改的脏页刷新到磁盘中，然后执行 checkpoint</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write pos ------- checkpoint_lsn <span class="comment">// 两值之间的部分表示可以写入的日志量，当 pos 追赶上 lsn 时必须执行 checkpoint</span></span><br></pre></td></tr></table></figure><p>使用命令可以查看当前 InnoDB 存储引擎各种 lsn 的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS\G</span><br></pre></td></tr></table></figure><hr><h5 id="崩溃恢复">崩溃恢复</h5><p>恢复的起点：在从 redo 日志文件组的管理信息中获取最近发生 checkpoint 的信息，<strong>从 checkpoint_lsn 对应的日志文件开始恢复</strong></p><p>恢复的终点：扫描日志文件的 block，block 的头部记录着当前 block 使用了多少字节，填满的 block 总是 512 字节， 如果某个 block 不是 512 字节，说明该 block 就是需要恢复的最后一个 block</p><p>恢复的过程：按照 redo log 依次执行恢复数据，优化方式</p><ul><li>使用哈希表：根据 redo log 的 space ID 和 page number 属性计算出哈希值，将对同一页面的修改放入同一个槽里，可以一次性完成对某页的恢复，<strong>避免了随机 IO</strong></li><li>跳过已经刷新到磁盘中的页面：数据页的 File Header 中的 FILE_PAGE_LSN 属性（类似 newest_modification）表示最近一次修改页面时的 lsn 值，如果在 checkpoint 后，数据页被刷新到磁盘中，那么该页 lsn 属性肯定大于 checkpoint_lsn</li></ul><p>总结：先写 redo buffer，在写 change buffer，先刷 redo log，再刷脏，在删除完成刷脏 redo log</p><p>参考书籍：<a href="https://book.douban.com/subject/35231266/">https://book.douban.com/subject/35231266/</a></p><hr><h4 id="工作流程-3">工作流程</h4><h5 id="日志对比">日志对比</h5><p>MySQL 中还存在 binlog（二进制日志）也可以记录写操作并用于数据的恢复，<strong>保证数据不丢失</strong>，二者的区别是：</p><ul><li>作用不同：redo log 是用于 crash recovery （故障恢复），保证 MySQL 宕机也不会影响持久性；binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制</li><li>层次不同：redo log 是 InnoDB 存储引擎实现的，而 binlog 是MySQL的 Server 层实现的，同时支持 InnoDB 和其他存储引擎</li><li>内容不同：redo log 是物理日志，内容基于磁盘的 Page；binlog 的内容是二进制的，根据 binlog_format 参数的不同，可能基于SQL 语句、基于数据本身或者二者的混合（日志部分详解）</li><li>写入时机不同：binlog 在事务提交时一次写入；redo log 的写入时机相对多元</li></ul><p>binlog 为什么不支持奔溃恢复？</p><ul><li>binlog 记录的是语句，并不记录数据页级的数据（哪个页改了哪些地方），所以没有能力恢复数据页</li><li>binlog 是追加写，保存全量的日志，没有标志确定从哪个点开始的数据是已经刷盘了，而 redo log 只要在 checkpoint_lsn 后面的就是没有刷盘的</li></ul><hr><h5 id="更新记录">更新记录</h5><p>更新一条记录的过程：写之前一定先读</p><ul><li><p>在 B+ 树中定位到该记录（这个过程也被称作加锁读），如果该记录所在的页面不在 Buffer Pool 里，先将其加载进内存</p></li><li><p>首先更新该记录对应的聚簇索引，更新聚簇索引记录时：</p><ul><li><p>更新记录前向 undo 页面写 undo 日志，由于这是更改页面，所以需要记录一下相应的 redo 日志</p><p>注意：修改 undo页面也是在<strong>修改页面</strong>，事务凡是修改页面就需要先记录相应的 redo 日志</p></li><li><p>然后<strong>先记录对应的的 redo 日志</strong>（等待 MTR 提交后写入 redo log buffer），<strong>最后进行真正的更新记录</strong></p></li></ul></li><li><p>更新其他的二级索引记录，不会再记录 undo log，只记录 redo log 到 buffer 中</p></li><li><p>在一条更新语句执行完成后（也就是将所有待更新记录都更新完了），就会开始记录该语句对应的 binlog 日志，此时记录的 binlog 并没有刷新到硬盘上，还在内存中，在事务提交时才会统一将该事务运行过程中的所有 binlog 日志刷新到硬盘</p></li></ul><p>假设表中有字段 id 和 a，存在一条 <code>id = 1, a = 2</code> 的记录，此时执行更新语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> a<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>InnoDB 会真正的去执行把值修改成 (1,2) 这个操作，先加行锁，在去更新，并不会提前判断相同就不修改了</p><p>参考文章：<a href="https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA">https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA</a></p><hr><h5 id="两段提交">两段提交</h5><p>当客户端执行 COMMIT 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，分两阶段来完成 XA 事务的提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><img src="../image/post/MySQL-update%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" style="zoom: 33%;" /><p>流程说明：执行引擎将这行新数据读入到内存中（Buffer Pool）后，先将此次更新操作记录到 redo log buffer 里，然后更新记录。最后将 redo log 刷盘后事务处于 prepare 状态，执行器会生成这个操作的 binlog，并<strong>把 binlog 写入磁盘</strong>，完成提交</p><p>两阶段：</p><ul><li>Prepare 阶段：存储引擎将该事务的 <strong>redo 日志刷盘</strong>，并且将本事务的状态设置为 PREPARE，代表执行完成随时可以提交事务</li><li>Commit 阶段：先将事务执行过程中产生的 binlog 刷新到硬盘，再执行存储引擎的提交工作，引擎把 redo log 改成提交状态</li></ul><p>redo log 和 binlog 都可以用于表示事务的提交状态，而<strong>两阶段提交就是让这两个状态保持逻辑上的一致</strong>，也有利于主从复制，更好的保持主从数据的一致性</p><hr><h5 id="数据恢复">数据恢复</h5><p>系统崩溃前没有提交的事务的 redo log 可能已经刷盘（定时线程或者 checkpoint），怎么处理崩溃恢复？</p><p>工作流程：通过 undo log 在服务器重启时将未提交的事务回滚掉。首先定位到 128 个回滚段遍历 slot，获取 undo 链表首节点页面的 undo segement header 中的 TRX_UNDO_STATE 属性，表示当前链表的事务属性，事务状态是活跃的就全部回滚，如果是 PREPARE 状态，就需要根据 binlog 的状态进行判断：</p><ul><li>如果在时刻 A 发生了崩溃（crash），由于此时 binlog 还没完成，所以需要进行回滚</li><li>如果在时刻 B 发生了崩溃，redo log 和 binlog 有一个共<strong>同的数据字段叫 XID</strong>，崩溃恢复的时候，会按顺序扫描 redo log：<ul><li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，说明 binlog 也已经记录完整，直接从 redo log 恢复数据</li><li>如果 redo log 里面的事务只有 prepare，就根据 XID 去 binlog 中判断对应的事务是否存在并完整，如果完整可以恢复数据，提交事务</li></ul></li></ul><p>判断一个事务的 binlog 是否完整的方法：</p><ul><li>statement 格式的 binlog，最后会有 COMMIT</li><li>row 格式的 binlog，最后会有一个 XID event</li><li>MySQL 5.6.2 版本以后，引入了 binlog-checksum 参数用来验证 binlog 内容的正确性（可能日志中间出错）</li></ul><p>参考文章：<a href="https://time.geekbang.org/column/article/73161">https://time.geekbang.org/column/article/73161</a></p><hr><h4 id="刷脏优化">刷脏优化</h4><p>系统在进行刷脏时会占用一部分系统资源，会影响系统的性能，<strong>产生系统抖动</strong></p><ul><li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长</li><li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li></ul><p>InnoDB 刷脏页的控制策略：</p><ul><li><code>innodb_io_capacity</code> 参数代表磁盘的读写能力，建议设置成磁盘的 IOPS（每秒的 IO 次数）</li><li>刷脏速度参考两个因素：脏页比例和 redo log 写盘速度<ul><li>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%，InnoDB 会根据当前的脏页比例，算出一个范围在 0 到 100 之间的数字</li><li>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差值，InnoDB 根据差值算出一个范围在 0 到 100 之间的数字</li><li>两者较大的值记为 R，执行引擎按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度</li></ul></li><li><code>innodb_flush_neighbors</code> 参数置为 1 代表控制刷脏时检查相邻的数据页，如果也是脏页就一起刷脏，并检查邻居的邻居，这个行为会一直蔓延直到不是脏页，在 MySQL 8.0 中该值的默认值是 0，不建议开启此功能</li></ul><hr><h3 id="一致特性">一致特性</h3><p>一致性是指事务执行前后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。</p><p>数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）</p><p>实现一致性的措施：</p><ul><li>保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证</li><li>数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等</li><li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致</li></ul><hr><h2 id="锁机制">锁机制</h2><h3 id="基本介绍-4">基本介绍</h3><p>锁机制：数据库为了保证数据的一致性，在共享的资源被并发访问时变得安全有序所设计的一种规则</p><p>利用 MVCC 性质进行读取的操作叫<strong>一致性读</strong>，读取数据前加锁的操作叫<strong>锁定读</strong></p><p>锁的分类：</p><ul><li>按操作分类：<ul><li>共享锁：也叫读锁。对同一份数据，多个事务读操作可以同时加锁而不互相影响 ，但不能修改数据</li><li>排他锁：也叫写锁。当前的操作没有完成前，会阻断其他操作的读取和写入</li></ul></li><li>按粒度分类：<ul><li>表级锁：会锁定整个表，开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低，偏向 MyISAM</li><li>行级锁：会锁定当前操作行，开销大，加锁慢；会出现死锁；锁定力度小，发生锁冲突概率低，并发度高，偏向 InnoDB</li><li>页级锁：锁的力度、发生冲突的概率和加锁开销介于表锁和行锁之间，会出现死锁，并发性能一般</li></ul></li><li>按使用方式分类：<ul><li>悲观锁：每次查询数据时都认为别人会修改，很悲观，所以查询时加锁</li><li>乐观锁：每次查询数据时都认为别人不会修改，很乐观，但是更新时会判断一下在此期间别人有没有去更新这个数据</li></ul></li></ul><ul><li><p>不同存储引擎支持的锁</p><table><thead><tr><th>存储引擎</th><th>表级锁</th><th>行级锁</th><th>页级锁</th></tr></thead><tbody><tr><td>MyISAM</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>InnoDB</td><td><strong>支持</strong></td><td><strong>支持</strong></td><td>不支持</td></tr><tr><td>MEMORY</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>BDB</td><td>支持</td><td>不支持</td><td>支持</td></tr></tbody></table></li></ul><p>从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理系统</p><hr><h3 id="内存结构">内存结构</h3><p>对一条记录加锁的本质就是<strong>在内存中</strong>创建一个锁结构与之关联，结构包括</p><ul><li>事务信息：锁对应的事务信息，一个锁属于一个事务</li><li>索引信息：对于行级锁，需要记录加锁的记录属于哪个索引</li><li>表锁和行锁信息：表锁记录着锁定的表，行锁记录了 Space ID 所在表空间、Page Number 所在的页号、n_bits 使用了多少比特</li><li>type_mode：一个 32 比特的数，被分成 lock_mode、lock_type、rec_lock_type 三个部分<ul><li>lock_mode：锁模式，记录是共享锁、排他锁、意向锁之类</li><li>lock_type：代表表级锁还是行级锁</li><li>rec_lock_type：代表行锁的具体类型和 is_waiting 属性，is_waiting = true 时表示当前事务尚未获取到锁，处于等待状态。事务获取锁后的锁结构是 is_waiting 为 false，释放锁时会检查是否与当前记录关联的锁结构，如果有就唤醒对应事务的线程</li></ul></li></ul><p>一个事务可能操作多条记录，为了节省内存，满足下面条件的锁使用同一个锁结构：</p><ul><li>在同一个事务中的加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>加锁的状态是一样的</li></ul><hr><h3 id="Server">Server</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)</p><p>MDL 叫元数据锁，主要用来保护 MySQL 内部对象的元数据，保证数据读写的正确性，<strong>当对一个表做增删改查的时候，加 MDL 读锁；当要对表做结构变更操作 DDL 的时候，加 MDL 写锁</strong>，两种锁不相互兼容，所以可以保证 DDL、DML、DQL 操作的安全</p><p>说明：DDL 操作执行前会隐式提交当前会话的事务，因为 DDL 一般会在若干个特殊事务中完成，开启特殊事务前需要提交到其他事务</p><p>MDL 锁的特性：</p><ul><li><p>MDL 锁不需要显式使用，在访问一个表的时候会被自动加上，在事务开始时申请，整个事务提交后释放（执行完单条语句不释放）</p></li><li><p>MDL 锁是在 Server 中实现，不是 InnoDB 存储引擎层能直接实现的锁</p></li><li><p>MDL 锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁</p></li></ul><p>FLUSH TABLES WITH READ LOCK 简称（FTWRL），全局读锁，让整个库处于只读状态，DDL DML 都被阻塞，工作流程：</p><ol><li>上全局读锁（lock_global_read_lock）</li><li>清理表缓存（close_cached_tables）</li><li>上全局 COMMIT 锁（make_global_read_lock_block_commit）</li></ol><p>该命令主要用于备份工具做<strong>一致性备份</strong>，由于 FTWRL 需要持有两把全局的 MDL 锁，并且还要关闭所有表对象，因此杀伤性很大</p><hr><h3 id="MyISAM-2">MyISAM</h3><h4 id="表级锁">表级锁</h4><p>MyISAM 存储引擎只支持表锁，这也是 MySQL 开始几个版本中唯一支持的锁类型</p><p>MyISAM 引擎在执行查询语句之前，会<strong>自动</strong>给涉及到的所有表加读锁，在执行增删改之前，会<strong>自动</strong>给涉及的表加写锁，这个过程并不需要用户干预，所以用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁</p><ul><li><p>加锁命令：（对 InnoDB 存储引擎也适用）</p><p>读锁：所有连接只能读取数据，不能修改</p><p>写锁：其他连接不能查询和修改数据</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 读锁</span><br><span class="line">LOCK TABLE table_name READ;</span><br><span class="line"></span><br><span class="line">-- 写锁</span><br><span class="line">LOCK TABLE table_name WRITE;</span><br></pre></td></tr></table></figure></li><li><p>解锁命令：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 将当前会话所有的表进行解锁</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></li></ul><p>锁的兼容性：</p><ul><li>对 MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求</li><li>对 MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作</li></ul><p><img src="../image/post/MySQL-MyISAM%20%E9%94%81%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt=""></p><p>锁调度：<strong>MyISAM 的读写锁调度是写优先</strong>，因为写锁后其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞，所以 MyISAM 不适合做写为主的表的存储引擎</p><hr><h4 id="锁操作">锁操作</h4><h5 id="读锁">读锁</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p><ul><li><p>数据准备：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_book` (</span><br><span class="line">  `id` INT(11) AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) DEFAULT NULL,</span><br><span class="line">  `publish_time` DATE DEFAULT NULL,</span><br><span class="line">  `status` CHAR(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=MYISAM DEFAULT CHARSET=utf8 ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,&#x27;java编程思想&#x27;,&#x27;2088-08-01&#x27;,&#x27;1&#x27;);</span><br><span class="line">INSERT INTO tb_book (id, NAME, publish_time, STATUS) VALUES(NULL,&#x27;mysql编程思想&#x27;,&#x27;2088-08-08&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>C1、C2 加读锁，同时查询可以正常查询出数据</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;-- C1、C2</span><br><span class="line">SELECT * FROM tb_book;-- C1、C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-MyISAM%20%E8%AF%BB%E9%94%811.png" alt=""></p></li><li><p>C1 加读锁，C1、C2 查询未锁定的表，C1 报错，C2 正常查询</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;-- C1</span><br><span class="line">SELECT * FROM tb_user;-- C1、C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-MyISAM%20%E8%AF%BB%E9%94%812.png" alt=""></p><p>C1、C2 执行插入操作，C1 报错，C2 等待获取</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;Spring高级&#x27;,&#x27;2088-01-01&#x27;,&#x27;1&#x27;);-- C1、C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-MyISAM%20%E8%AF%BB%E9%94%813.png" alt=""></p><p>当在 C1 中释放锁指令 UNLOCK TABLES，C2 中的 INSERT 语句立即执行</p></li></ul><hr><h5 id="写锁">写锁</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p><ul><li><p>C1 加写锁，C1、C2查询表，C1 正常查询，C2 需要等待</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE tb_book WRITE;-- C1</span><br><span class="line">SELECT * FROM tb_book;-- C1、C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-MyISAM%20%E5%86%99%E9%94%811.png" alt=""></p><p>当在 C1 中释放锁指令 UNLOCK TABLES，C2 中的 SELECT 语句立即执行</p></li><li><p>C1、C2 同时加写锁</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE tb_book WRITE;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-MyISAM%20%E5%86%99%E9%94%812.png" alt=""></p></li><li><p>C1 加写锁，C1、C2查询未锁定的表，C1 报错，C2 正常查询</p></li></ul><hr><h4 id="锁状态">锁状态</h4><ul><li><p>查看锁竞争：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B1.png" alt=""></p><p>In_user：表当前被查询使用的次数，如果该数为零，则表是打开的，但是当前没有被使用</p><p>Name_locked：表名称是否被锁定，名称锁定用于取消表或对表进行重命名等操作</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE tb_book READ;-- 执行命令</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E9%94%81%E4%BA%89%E7%94%A8%E6%83%85%E5%86%B5%E6%9F%A5%E7%9C%8B2.png" alt=""></p></li><li><p>查看锁状态：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;Table_locks%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-MyISAM%20%E9%94%81%E7%8A%B6%E6%80%81.png" alt=""></p><p>Table_locks_immediate：指的是能立即获得表级锁的次数，每立即获取锁，值加 1</p><p>Table_locks_waited：指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加 1，此值高说明存在着较为严重的表级锁争用情况</p></li></ul><hr><h3 id="InnoDB">InnoDB</h3><h4 id="行级锁">行级锁</h4><h5 id="记录锁">记录锁</h5><p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁，<strong>InnoDB 同时支持表锁和行锁</strong></p><p>行级锁，也称为记录锁（Record Lock），InnoDB  实现了以下两种类型的行锁：</p><ul><li>共享锁 (S)：又称为读锁，简称 S 锁，多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改</li><li>排他锁 (X)：又称为写锁，简称 X 锁，不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，只有获取排他锁的事务是可以对数据读取和修改</li></ul><p>RR 隔离界别下，对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会<strong>自动给涉及数据集加排他锁</strong>（行锁），在 commit 时自动释放；对于普通 SELECT 语句，不会加任何锁（只是针对 InnoDB 层来说的，因为在 Server 层会<strong>加 MDL 读锁</strong>），通过 MVCC 防止并发冲突</p><p>在事务中加的锁，并不是不需要了就释放，而是在事务中止或提交时自动释放，这个就是<strong>两阶段锁协议</strong>。所以一般将更新共享资源（并发高）的 SQL 放到事务的最后执行，可以让其他线程尽量的减少等待时间</p><p>锁的兼容性：</p><ul><li>共享锁和共享锁     兼容</li><li>共享锁和排他锁     冲突</li><li>排他锁和排他锁     冲突</li><li>排他锁和共享锁     冲突</li></ul><p>显式给数据集加共享锁或排他锁：<strong>加锁读就是当前读，读取的是最新数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE-- 共享锁</span><br><span class="line">SELECT * FROM table_name WHERE ... FOR UPDATE-- 排他锁</span><br></pre></td></tr></table></figure><p>注意：<strong>锁默认会锁聚簇索引（锁就是加在索引上）</strong>，但是当使用覆盖索引时，加共享锁只锁二级索引，不锁聚簇索引</p><hr><h5 id="锁操作-2">锁操作</h5><p>两个客户端操作 Client 1和 Client 2，简化为 C1、C2</p><ul><li><p>环境准备</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test_innodb_lock(</span><br><span class="line">id INT(11),</span><br><span class="line">name VARCHAR(16),</span><br><span class="line">sex VARCHAR(1)</span><br><span class="line">)ENGINE = INNODB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_innodb_lock VALUES(1,&#x27;100&#x27;,&#x27;1&#x27;);</span><br><span class="line">-- ..........</span><br><span class="line"></span><br><span class="line">CREATE INDEX idx_test_innodb_lock_id ON test_innodb_lock(id);</span><br><span class="line">CREATE INDEX idx_test_innodb_lock_name ON test_innodb_lock(name);</span><br></pre></td></tr></table></figure></li><li><p>关闭自动提交功能：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;-- C1、C2</span><br></pre></td></tr></table></figure><p>正常查询数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock;-- C1、C2</span><br></pre></td></tr></table></figure></li><li><p>查询 id 为 3 的数据，正常查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock WHERE id=3;-- C1、C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%94%81%E6%93%8D%E4%BD%9C1.png" alt=""></p></li><li><p>C1 更新 id 为 3 的数据，但不提交：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;300&#x27; WHERE id=3;-- C1</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%94%81%E6%93%8D%E4%BD%9C2.png" alt=""></p><p>C2 查询不到 C1 修改的数据，因为隔离界别为 REPEATABLE READ，C1 提交事务，C2 查询：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;-- C1</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%94%81%E6%93%8D%E4%BD%9C3.png" alt=""></p><p>提交后仍然查询不到 C1 修改的数据，因为隔离级别可以防止脏读、不可重复读，所以 C2 需要提交才可以查询到其他事务对数据的修改：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;-- C2</span><br><span class="line">SELECT * FROM test_innodb_lock WHERE id=3;-- C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%94%81%E6%93%8D%E4%BD%9C4.png" alt=""></p></li><li><p>C1 更新 id 为 3 的数据，但不提交，C2 也更新 id 为 3 的数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;3&#x27; WHERE id=3;-- C1</span><br><span class="line">UPDATE test_innodb_lock SET name=&#x27;30&#x27; WHERE id=3;-- C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%94%81%E6%93%8D%E4%BD%9C5.png" alt=""></p><p>当 C1 提交，C2 直接解除阻塞，直接更新</p></li><li><p>操作不同行的数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;10&#x27; WHERE id=1;-- C1</span><br><span class="line">UPDATE test_innodb_lock SET name=&#x27;30&#x27; WHERE id=3;-- C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%94%81%E6%93%8D%E4%BD%9C6.png" alt=""></p><p>由于 C1、C2 操作的不同行，获取不同的行锁，所以都可以正常获取行锁</p></li></ul><hr><h4 id="锁分类">锁分类</h4><h5 id="间隙锁">间隙锁</h5><p>InnoDB 会对间隙（GAP）进行加锁，就是间隙锁 （RR 隔离级别下才有该锁）。间隙锁之间不存在冲突关系，<strong>多个事务可以同时对一个间隙加锁</strong>，但是间隙锁会阻止往这个间隙中插入一个记录的操作</p><p>InnoDB 加锁的基本单位是 next-key lock，该锁是行锁和 gap lock 的组合（X or S 锁），但是加锁过程是分为间隙锁和行锁两段执行</p><ul><li>可以<strong>保护当前记录和前面的间隙</strong>，遵循左开右闭原则，单纯的是间隙锁左开右开</li><li>假设有 10、11、13，那么可能的间隙锁包括：(负无穷,10]、(10,11]、(11,13]、(13,正无穷)</li></ul><p>几种索引的加锁情况：</p><ul><li>唯一索引加锁在值存在时是行锁，next-key lock 会退化为行锁，值不存在会变成间隙锁</li><li>普通索引加锁会继续向右遍历到不满足条件的值为止，next-key lock 退化为间隙锁</li><li>范围查询无论是否是唯一索引，都需要访问到不满足条件的第一个值为止</li><li>对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么会加间隙锁</li></ul><p>间隙锁优点：RR 级别下间隙锁可以解决事务的一部分的<strong>幻读问题</strong>，通过对间隙加锁，可以防止读取过程中数据条目发生变化。一部分的意思是不会对全部间隙加锁，只能加锁一部分的间隙。</p><p>间隙锁危害：</p><ul><li>当锁定一个范围的键值后，即使某些不存在的键值也会被无辜的锁定，造成在锁定的时候无法插入锁定键值范围内的任何数据，在某些场景下这可能会对性能造成很大的危害，影响并发度</li><li>事务 A B 同时锁住一个间隙后，A 往当前间隙插入数据时会被 B 的间隙锁阻塞，B 也执行插入间隙数据的操作时就会<strong>产生死锁</strong></li></ul><p>现场演示：</p><ul><li><p>关闭自动提交功能：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;-- C1、C2</span><br></pre></td></tr></table></figure></li><li><p>查询数据表：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM test_innodb_lock;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%97%B4%E9%9A%99%E9%94%811.png" alt=""></p></li><li><p>C1 根据 id 范围更新数据，C2 插入数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET name=&#x27;8888&#x27; WHERE id &lt; 4;-- C1</span><br><span class="line">INSERT INTO test_innodb_lock VALUES(2,&#x27;200&#x27;,&#x27;2&#x27;);-- C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%97%B4%E9%9A%99%E9%94%812.png" alt=""></p><p>出现间隙锁，C2 被阻塞，等待 C1 提交事务后才能更新</p></li></ul><hr><h5 id="意向锁">意向锁</h5><p>InnoDB 为了支持多粒度的加锁，允许行锁和表锁同时存在，支持在不同粒度上的加锁操作，InnoDB 增加了意向锁（Intention Lock）</p><p>意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁，意向锁分为两种：</p><ul><li>意向共享锁（IS）：事务有意向对表加共享锁</li><li>意向排他锁（IX）：事务有意向对表加排他锁</li></ul><p><strong>IX，IS 是表级锁</strong>，不会和行级的 X，S 锁发生冲突，意向锁是在加表级锁之前添加，为了在加表级锁时可以快速判断表中是否有记录被上锁，比如向一个表添加表级 X 锁的时：</p><ul><li>没有意向锁，则需要遍历整个表判断是否有锁定的记录</li><li>有了意向锁，首先判断是否存在意向锁，然后判断该意向锁与即将添加的表级锁是否兼容即可，因为意向锁的存在代表有表级锁的存在或者即将有表级锁的存在</li></ul><p>兼容性如下所示：</p><p><img src="../image/post/MySQL-%E6%84%8F%E5%90%91%E9%94%81%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt=""></p><p><strong>插入意向锁</strong> Insert Intention Lock 是在插入一行记录操作之前设置的一种间隙锁，是行级锁</p><p>插入意向锁释放了一种插入信号，即多个事务在相同的索引间隙插入时如果不是插入相同的间隙位置就不需要互相等待。假设某列有索引，只要两个事务插入位置不同，如事务 A 插入 3，事务 B 插入 4，那么就可以同时插入</p><hr><h5 id="自增锁">自增锁</h5><p>系统会自动给 AUTO_INCREMENT 修饰的列进行递增赋值，实现方式：</p><ul><li>AUTO_INC 锁：表级锁，执行插入语句时会自动添加，在该语句执行完成后释放，并不是事务结束</li><li>轻量级锁：为插入语句生成 AUTO_INCREMENT 修饰的列时获取该锁，生成以后释放掉，不需要等到插入语句执行完后释放</li></ul><p>系统变量 <code>innodb_autoinc_lock_mode</code> 控制采取哪种方式：</p><ul><li>0：全部采用 AUTO_INC 锁</li><li>1：全部采用轻量级锁</li><li>2：混合使用，在插入记录的数量确定是采用轻量级锁，不确定时采用 AUTO_INC 锁</li></ul><hr><h5 id="隐式锁">隐式锁</h5><p>一般情况下 INSERT 语句是不需要在内存中生成锁结构的，会进行隐式的加锁，保护的是插入后的安全</p><p>注意：如果插入的间隙被其他事务加了间隙锁，此次插入会被阻塞，并在该间隙插入一个插入意向锁</p><ul><li>聚簇索引：索引记录有 trx_id 隐藏列，表示最后改动该记录的事务 id，插入数据后事务 id 就是当前事务。其他事务想获取该记录的锁时会判断当前记录的事务 id 是否是活跃的，如果不是就可以正常加锁；如果是就创建一个 X 的锁结构，该锁的 is_waiting 是 false，为自己的事务创建一个锁结构，is_waiting 是 true（类似 Java 中的锁升级）</li><li>二级索引：获取数据页 Page Header 中的 PAGE_MAX_TRX_ID 属性，代表修改当前页面的最大的事务 ID，如果小于当前活跃的最小事务 id，就证明插入该数据的事务已经提交，否则就需要获取到主键值进行回表操作</li></ul><p>隐式锁起到了延迟生成锁的效果，如果其他事务与隐式锁没有冲突，就可以避免锁结构的生成，节省了内存资源</p><p>INSERT 在两种情况下会生成锁结构：</p><ul><li><p>重复键：在插入主键或唯一二级索引时遇到重复的键值会报错，在报错前需要对对应的聚簇索引进行加锁</p><ul><li>隔离级别 &lt;= Read Uncommitted，加 S 型 Record Lock</li><li>隔离级别 &gt;= Repeatable Read，加 S 型 next_key 锁</li></ul></li><li><p>外键检查：如果待插入的记录在父表中可以找到，会对父表的记录加 S 型 Record Lock。如果待插入的记录在父表中找不到</p><ul><li>隔离级别 &lt;= Read Committed，不加锁</li><li>隔离级别 &gt;= Repeatable Read，加间隙锁</li></ul></li></ul><hr><h4 id="锁优化">锁优化</h4><h5 id="优化锁">优化锁</h5><p>InnoDB 存储引擎实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高，但是在整体并发处理能力方面要远远优于 MyISAM 的表锁，当系统并发量较高的时候，InnoDB 的整体性能远远好于 MyISAM</p><p>但是使用不当可能会让 InnoDB 的整体性能表现不仅不能比 MyISAM 高，甚至可能会更差</p><p>优化建议：</p><ul><li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少索引条件及索引范围，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可使用低级别事务隔离（需要业务层面满足需求）</li></ul><hr><h5 id="锁升级">锁升级</h5><p>索引失效造成<strong>行锁升级为表锁</strong>，不通过索引检索数据，全局扫描的过程中 InnoDB 会将对表中的所有记录加锁，实际效果和<strong>表锁</strong>一样，实际开发过程应避免出现索引失效的状况</p><ul><li><p>查看当前表的索引：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test_innodb_lock;</span><br></pre></td></tr></table></figure></li><li><p>关闭自动提交功能：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;-- C1、C2</span><br></pre></td></tr></table></figure></li><li><p>执行更新语句：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE test_innodb_lock SET sex=&#x27;2&#x27; WHERE name=10;-- C1</span><br><span class="line">UPDATE test_innodb_lock SET sex=&#x27;2&#x27; WHERE id=3;-- C2</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%20%E9%94%81%E5%8D%87%E7%BA%A7.png" alt=""></p><p>索引失效：执行更新时 name 字段为 varchar 类型，造成索引失效，最终行锁变为表锁</p></li></ul><hr><h5 id="死锁">死锁</h5><p>不同事务由于互相持有对方需要的锁而导致事务都无法继续执行的情况称为死锁</p><p>死锁情况：线程 A 修改了 id = 1 的数据，请求修改 id = 2 的数据，线程 B 修改了 id = 2 的数据，请求修改 id = 1 的数据，产生死锁</p><p>解决策略：</p><ul><li><p>直接进入等待直到超时，超时时间可以通过参数 innodb_lock_wait_timeout 来设置，默认 50 秒，但是时间的设置不好控制，超时可能不是因为死锁，而是因为事务处理比较慢，所以一般不采取该方式</p></li><li><p>主动死锁检测，发现死锁后<strong>主动回滚死锁链条中较小的一个事务</strong>，让其他事务得以继续执行，将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启该功能（事务较小的意思就是事务执行过程中插入、删除、更新的记录条数）</p><p>死锁检测并不是每个语句都要检测，只有在加锁访问的行上已经有锁时，当前事务被阻塞了才会检测，也是从当前事务开始进行检测</p></li></ul><p>通过执行 <code>SHOW ENGINE INNODB STATUS</code> 可以查看最近发生的一次死循环，全局系统变量 <code>innodb_print_all_deadlocks</code> 设置为 on，就可以将每个死锁信息都记录在 MySQL 错误日志中</p><p>死锁一般是行级锁，当表锁发生死锁时，会在事务中访问其他表时<strong>直接报错</strong>，破坏了持有并等待的死锁条件</p><hr><h4 id="锁状态-2">锁状态</h4><p>查看锁信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW STATUS LIKE &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure><img src="../image/post/MySQL-InnoDB%20%E9%94%81%E4%BA%89%E7%94%A8.png" style="zoom: 80%;" /><p>参数说明：</p><ul><li><p>Innodb_row_lock_current_waits：当前正在等待锁定的数量</p></li><li><p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度</p></li><li><p>Innodb_row_lock_time_avg：每次等待所花平均时长</p></li><li><p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间</p></li><li><p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数</p></li></ul><p>当等待的次数很高，而且每次等待的时长也不短的时候，就需要分析系统中为什么会有如此多的等待，然后根据分析结果制定优化计划</p><p>查看锁状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.innodb_locks;#锁的概况</span><br><span class="line">SHOW ENGINE INNODB STATUS\G; #InnoDB整体状态，其中包括锁的情况</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-InnoDB%E6%9F%A5%E7%9C%8B%E9%94%81%E7%8A%B6%E6%80%81.png" alt=""></p><p>lock_id 是锁 id；lock_trx_id 为事务 id；lock_mode 为 X 代表排它锁（写锁）；lock_type 为 RECORD 代表锁为行锁（记录锁）</p><hr><h3 id="乐观锁">乐观锁</h3><p>悲观锁：在整个数据处理过程中，将数据处于锁定状态，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据，修改删除数据时也加锁，其它事务同样无法读取这些数据</p><p>悲观锁和乐观锁使用前提：</p><ul><li>对于读的操作远多于写的操作的时候，一个更新操作加锁会阻塞所有的读取操作，降低了吞吐量，最后需要释放锁，锁是需要一些开销的，这时候可以选择乐观锁</li><li>如果是读写比例差距不是非常大或者系统没有响应不及时，吞吐量瓶颈的问题，那就不要去使用乐观锁，它增加了复杂度，也带来了业务额外的风险，这时候可以选择悲观锁</li></ul><p>乐观锁的实现方式：就是 CAS，比较并交换</p><ul><li><p>版本号</p><ol><li><p>给数据表中添加一个 version 列，每次更新后都将这个列的值加 1</p></li><li><p>读取数据时，将版本号读取出来，在执行更新的时候，比较版本号</p></li><li><p>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</p></li><li><p>用户自行根据这个通知来决定怎么处理，比如重新开始一遍，或者放弃本次更新</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 创建city表</span><br><span class="line">CREATE TABLE city(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,  -- 城市id</span><br><span class="line">NAME VARCHAR(20),                   -- 城市名称</span><br><span class="line">VERSION INT                         -- 版本号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO city VALUES (NULL,&#x27;北京&#x27;,1),(NULL,&#x27;上海&#x27;,1),(NULL,&#x27;广州&#x27;,1),(NULL,&#x27;深圳&#x27;,1);</span><br><span class="line"></span><br><span class="line">-- 修改北京为北京市</span><br><span class="line">-- 1.查询北京的version</span><br><span class="line">SELECT VERSION FROM city WHERE NAME=&#x27;北京&#x27;;</span><br><span class="line">-- 2.修改北京为北京市，版本号+1。并对比版本号</span><br><span class="line">UPDATE city SET NAME=&#x27;北京市&#x27;,VERSION=VERSION+1 WHERE NAME=&#x27;北京&#x27; AND VERSION=1;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>时间戳</p><ul><li>和版本号方式基本一样，给数据表中添加一个列，名称无所谓，数据类型需要是 <strong>timestamp</strong></li><li>每次更新后都将最新时间插入到此列</li><li>读取数据时，将时间读取出来，在执行更新的时候，比较时间</li><li>如果相同则执行更新，如果不相同，说明此条数据已经发生了变化</li></ul></li></ul><p>乐观锁的异常情况：如果 version 被其他事务抢先更新，则在当前事务中更新失败，trx_id 没有变成当前事务的 ID，当前事务再次查询还是旧值，就会出现<strong>值没变但是更新不了</strong>的现象（anomaly）</p><p>解决方案：每次 CAS 更新不管成功失败，就结束当前事务；如果失败则重新起一个事务进行查询更新</p><h2 id="日志">日志</h2><h3 id="日志分类">日志分类</h3><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的过程，可以帮助数据库管理员追踪数据库曾经发生过的各种事件。</p><p>MySQL日志主要包括六种：</p><ol><li>重做日志（redo log）</li><li>回滚日志（undo log）</li><li>归档日志（binlog）（二进制日志）</li><li>错误日志（errorlog）</li><li>慢查询日志（slow query log）</li><li>一般查询日志（general log）</li><li>中继日志（relay log）</li></ol><hr><h3 id="错误日志">错误日志</h3><p>错误日志是 MySQL 中最重要的日志之一，记录了当 mysql 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志</p><p>该日志是默认开启的，默认位置是：<code>/var/log/mysql/error.log</code></p><p>查看指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;log_error%&#x27;;</span><br></pre></td></tr></table></figure><p>查看日志内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /var/log/mysql/error.log</span><br></pre></td></tr></table></figure><hr><h3 id="归档日志">归档日志</h3><h4 id="基本介绍-5">基本介绍</h4><p>归档日志（BINLOG）也叫二进制日志，是因为采用二进制进行存储，记录了所有的 DDL（数据定义语言）语句和 DML（数据操作语言）语句，但<strong>不包括数据查询语句，在事务提交前的最后阶段写入</strong></p><p>作用：<strong>灾难时的数据恢复和 MySQL 的主从复制</strong></p><p>归档日志默认情况下是没有开启的，需要在 MySQL 配置文件中开启，并配置 MySQL 日志的格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/mysql</span><br><span class="line">vim my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如: mysqlbin.000001</span></span><br><span class="line">log_bin=mysqlbin</span><br><span class="line"><span class="comment"># 配置二进制日志的格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><p>日志存放位置：配置时给定了文件名但是没有指定路径，日志默认写入MySQL 的数据目录</p><p>日志格式：</p><ul><li><p>STATEMENT：该日志格式在日志文件中记录的都是 <strong>SQL 语句</strong>，每一条对数据进行修改的 SQL 都会记录在日志文件中，通过 mysqlbinlog 工具，可以查看到每条语句的文本。主从复制时，从库会将日志解析为原语句，并在从库重新执行一遍</p><p>缺点：可能会导致主备不一致，因为记录的 SQL 在不同的环境中可能选择的索引不同，导致结果不同</p></li><li><p>ROW：该日志格式在日志文件中记录的是每一行的<strong>数据变更</strong>，而不是记录 SQL 语句。比如执行 SQL 语句 <code>update tb_book set status='1'</code>，如果是 STATEMENT，在日志中会记录一行 SQL 语句； 如果是 ROW，由于是对全表进行更新，就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更</p><p>缺点：记录的数据比较多，占用很多的存储空间</p></li><li><p>MIXED：这是 MySQL 默认的日志格式，混合了STATEMENT 和 ROW 两种格式，MIXED 格式能尽量利用两种模式的优点，而避开它们的缺点</p></li></ul><hr><h4 id="日志刷盘-2">日志刷盘</h4><p>事务执行过程中，先将日志写（write）到 binlog cache，事务提交时再把 binlog cache 写（fsync）到 binlog 文件中，一个事务的 binlog 是不能被拆开的，所以不论这个事务多大也要确保一次性写入</p><p>事务提交时执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache</p><p>write 和 fsync 的时机由参数 sync_binlog 控制的：</p><ul><li>sync_binlog=0：表示每次提交事务都只 write，不 fsync</li><li>sync_binlog=1：表示每次提交事务都会执行 fsync</li><li>sync_binlog=N(N&gt;1)：表示每次提交事务都 write，但累积 N 个事务后才 fsync，但是如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志</li></ul><hr><h4 id="日志读取">日志读取</h4><p>日志文件存储位置：/var/lib/mysql</p><p>由于日志以二进制方式存储，不能直接读取，需要用 mysqlbinlog 工具来查看，语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog log-file;</span><br></pre></td></tr></table></figure><p>查看 STATEMENT 格式日志：</p><ul><li><p>执行插入语句：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;Lucene&#x27;,&#x27;2088-05-01&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><code>cd /var/lib/mysql</code>：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r-----  1 mysql mysql      177 5月  23 21:08 mysqlbin.000001</span><br><span class="line">-rw-r-----  1 mysql mysql       18 5月  23 21:04 mysqlbin.index</span><br></pre></td></tr></table></figure><p>mysqlbin.index：该文件是日志索引文件 ， 记录日志的文件名；</p><p>mysqlbing.000001：日志文件</p></li><li><p>查看日志内容：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog mysqlbing.000001;</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%961.png" alt=""></p><p>日志结尾有 COMMIT</p></li></ul><p>查看 ROW 格式日志：</p><ul><li><p>修改配置：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置二进制日志的格式</span></span><br><span class="line">binlog_format=ROW</span><br></pre></td></tr></table></figure></li><li><p>插入数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tb_book VALUES(NULL,&#x27;SpringCloud实战&#x27;,&#x27;2088-05-05&#x27;,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>查看日志内容：日志格式 ROW，直接查看数据是乱码，可以在 mysqlbinlog 后面加上参数 -vv</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -vv mysqlbin.000002</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%962.png" alt=""></p></li></ul><hr><h4 id="日志删除">日志删除</h4><p>对于比较繁忙的系统，生成日志量大，这些日志如果长时间不清除，将会占用大量的磁盘空间，需要删除日志</p><ul><li><p>Reset Master 指令删除全部 binlog 日志，删除之后，日志编号将从 xxxx.000001重新开始</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reset Master-- MySQL指令</span><br></pre></td></tr></table></figure></li><li><p>执行指令 <code>PURGE MASTER LOGS TO 'mysqlbin.***</code>，该命令将删除 <code> ***</code> 编号之前的所有日志</p></li><li><p>执行指令 <code>PURGE MASTER LOGS BEFORE 'yyyy-mm-dd hh:mm:ss'</code> ，该命令将删除日志为 <code>yyyy-mm-dd hh:mm:ss</code> 之前产生的日志</p></li><li><p>设置参数 <code>--expire_logs_days=#</code>，此参数的含义是设置日志的过期天数，过了指定的天数后日志将会被自动删除，这样做有利于减少管理日志的工作量，配置 my.cnf 文件：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_bin=mysqlbin</span><br><span class="line">binlog_format=ROW</span><br><span class="line">--expire_logs_days=3</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="数据恢复-2">数据恢复</h4><p>误删库或者表时，需要根据 binlog 进行数据恢复，</p><p>一般情况下数据库有定时的全量备份，假如每天 0 点定时备份，12 点误删了库，恢复流程：</p><ul><li>取最近一次全量备份，用备份恢复出一个临时库</li><li>从日志文件中取出凌晨 0 点之后的日志</li><li>把除了误删除数据的语句外日志，全部应用到临时库</li></ul><p>跳过误删除语句日志的方法：</p><ul><li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用 –stop-position 参数执行到误操作之前的日志，然后再用 –start-position 从误操作之后的日志继续执行</li><li>如果实例使用了 GTID 模式，假设误操作命令的 GTID 是 gtid1，那么只需要提交一个空事务先将这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时就会自动跳过误操作的语句</li></ul><hr><h3 id="查询日志">查询日志</h3><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的 SQL 语句</p><p>默认情况下，查询日志是未开启的。如果需要开启查询日志，配置 my.cnf：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该选项用来开启查询日志，可选值0或者1，0代表关闭，1代表开启 </span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment"># 设置日志的文件名，如果没有指定，默认的文件名为host_name.log，存放在/var/lib/mysql</span></span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure><p>配置完毕之后，在数据库执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb_book;</span><br><span class="line">SELECT * FROM tb_book WHERE id = 1;</span><br><span class="line">UPDATE tb_book SET name = &#x27;lucene入门指南&#x27; WHERE id = 5;</span><br><span class="line">SELECT * FROM tb_book WHERE id &lt; 8</span><br></pre></td></tr></table></figure><p>执行完毕之后， 再次来查询日志文件：</p><p><img src="../image/post/MySQL-%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.png" alt=""></p><hr><h3 id="慢日志">慢日志</h3><p>慢查询日志记录所有执行时间超过 long_query_time 并且扫描记录数不小于 min_examined_row_limit 的所有的 SQL 语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度到微秒</p><p>慢查询日志默认是关闭的，可以通过两个参数来控制慢查询日志，配置文件 <code>/etc/mysql/my.cnf</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该参数用来控制慢查询日志是否开启，可选值0或者1，0代表关闭，1代表开启 </span></span><br><span class="line">slow_query_log=1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 该参数用来指定慢查询日志的文件名，存放在 /var/lib/mysql</span></span><br><span class="line">slow_query_log_file=slow_query.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该选项用来配置查询的时间限制，超过这个时间将认为值慢查询，将需要进行日志记录，默认10s</span></span><br><span class="line">long_query_time=10</span><br></pre></td></tr></table></figure><p>日志读取：</p><ul><li><p>直接通过 cat 指令查询该日志文件：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> slow_query.log</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E6%85%A2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%961.png" alt=""></p></li><li><p>如果慢查询日志内容很多，直接查看文件比较繁琐，可以借助 mysql 自带的 mysqldumpslow 工具对慢查询日志进行分类汇总：</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow slow_query.log</span><br></pre></td></tr></table></figure><p><img src="../image/post/MySQL-%E6%85%A2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%962.png" alt=""></p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> DataBaseing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBase </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL初级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWeb-Listener学习笔记</title>
      <link href="/posts/e902e3a2.html"/>
      <url>/posts/e902e3a2.html</url>
      
        <content type="html"><![CDATA[<h1>Listener</h1><h2 id="Listener">Listener</h2><h3 id="观察者设计者">观察者设计者</h3><p>所有的监听器都是基于观察者设计模式的。</p><p>观察者模式通常由以下三部分组成：</p><ul><li><p>事件源：触发事件的对象。</p></li><li><p>事件：触发的动作，里面封装了事件源。</p></li><li><p>监听器：当事件源触发事件后，可以完成的功能。一般是一个接口，由使用者来实现。（此处的思想还涉及了一个策略模式）</p></li></ul><hr><h3 id="监听器分类">监听器分类</h3><p>在程序当中，我们可以对：对象的创建销毁、域对象中属性的变化、会话相关内容进行监听。</p><p>Servlet规范中共计8个监听器，<strong>监听器都是以接口形式提供</strong>，具体功能需要我们自己完成</p><h4 id="监听对象">监听对象</h4><ul><li><p>ServletContextListener：用于监听ServletContext对象的创建和销毁</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void contextInitialized(ServletContextEvent sce)</td><td>对象创建时执行该方法</td></tr><tr><td>void contextDestroyed(ServletContextEvent sce)</td><td>对象销毁时执行该方法</td></tr></tbody></table><p>参数ServletContextEvent 代表事件对象，事件对象中封装了事件源ServletContext，真正的事件指的是创建或者销毁ServletContext对象的操作</p></li><li><p>HttpSessionListener：用于监听HttpSession对象的创建和销毁</p><table><thead><tr><th>方法</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td>void sessionCreated(HttpSessionEvent se)</td><td style="text-align:left">对象创建时执行该方法</td></tr><tr><td>void sessionDestroyed(HttpSessionEvent se)</td><td style="text-align:left">对象销毁时执行该方法</td></tr></tbody></table><p>参数HttpSessionEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是创建或者销毁HttpSession对象的操作</p></li><li><p>ServletRequestListener：用于监听ServletRequest对象的创建和销毁</p><table><thead><tr><th>方法</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td>void requestInitialized(ServletRequestEvent sre)</td><td style="text-align:left">对象创建时执行该方法</td></tr><tr><td>void requestDestroyed(ServletRequestEvent sre)</td><td style="text-align:left">对象销毁时执行该方法</td></tr></tbody></table><p>参数ServletRequestEvent 代表事件对象，事件对象中封装了事件源ServletRequest，真正的事件指的是创建或者销毁ServletRequest对象的操作</p></li></ul><hr><h4 id="监听域对象属性">监听域对象属性</h4><ul><li><p>ServletContextAttributeListener：用于监听ServletContext应用域中属性的变化</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void attributeAdded(ServletContextAttributeEvent event)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void attributeRemoved(ServletContextAttributeEvent event)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void attributeReplaced(ServletContextAttributeEvent event)</td><td>域中替换属性时执行该方法</td></tr></tbody></table><p>参数ServletContextAttributeEvent 代表事件对象，事件对象中封装了事件源ServletContext，真正的事件指的是添加、移除、替换应用域中属性的操作</p></li><li><p>HttpSessionAttributeListener：用于监听HttpSession会话域中属性的变化</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void attributeAdded(HttpSessionBindingEvent event)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void attributeRemoved(HttpSessionBindingEvent event)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void attributeReplaced(HttpSessionBindingEvent event)</td><td>域中替换属性时执行该方法</td></tr></tbody></table><p>参数HttpSessionBindingEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是添加、移除、替换应用域中属性的操作</p></li><li><p>ServletRequestAttributeListener：用于监听ServletRequest请求域中属性的变化</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void attributeAdded(ServletRequestAttributeEvent srae)</td><td>域中添加属性时执行该方法</td></tr><tr><td>void attributeRemoved(ServletRequestAttributeEvent srae)</td><td>域中移除属性时执行该方法</td></tr><tr><td>void attributeReplaced(ServletRequestAttributeEvent srae)</td><td>域中替换属性时执行该方法</td></tr></tbody></table><p>参数ServletRequestAttributeEvent 代表事件对象，事件对象中封装了事件源ServletRequest，真正的事件指的是添加、移除、替换应用域中属性的操作</p></li><li><p>页面域对象没有监听器</p></li></ul><hr><h4 id="感知型监听器">感知型监听器</h4><p>监听会话相关的感知型监听器，和会话域相关的两个感知型监听器是无需配置（注解）的，可以直接编写代码</p><ul><li><p>HttpSessionBindingListener：用于感知对象和会话域绑定的监听器</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void valueBound(HttpSessionBindingEvent event)</td><td>数据添加到会话域中(绑定)时执行该方法</td></tr><tr><td>void valueUnbound(HttpSessionBindingEvent event)</td><td>数据从会话域中移除(解绑)时执行该方法</td></tr></tbody></table><p>参数HttpSessionBindingEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是添加、移除、替换应用域中属性的操作</p></li><li><p>HttpSessionActivationListener：用于感知会话域中对象和钝化和活化的监听器</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void sessionWillPassivate(HttpSessionEvent se)</td><td>会话域中数据钝化时执行该方法</td></tr><tr><td>void sessionDidActivate(HttpSessionEvent se)</td><td>会话域中数据活化时执行该方法</td></tr></tbody></table></li></ul><hr><h3 id="监听器使用">监听器使用</h3><h4 id="ServletContextListener">ServletContextListener</h4><p>ServletContext对象的创建和销毁的监听器</p><p>注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextListenerDemo</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="comment">//创建时执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到对象的创建....&quot;</span>);<span class="comment">//启动服务器就创建</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        System.out.println(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁时执行的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到对象的销毁...&quot;</span>);<span class="comment">//关闭服务器就销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置监听器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>listener.ServletContextAttributeListenerDemo<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="ServletContextAttributeListener">ServletContextAttributeListener</h4><p>应用域对象中的属性变化的监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextAttributeListenerDemo</span> <span class="keyword">implements</span> <span class="title class_">ServletContextAttributeListener</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        向应用域对象中添加属性时执行此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了属性的添加...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取应用域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="comment">//获取属性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);<span class="comment">//zhangsan </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        向应用域对象中替换属性时执行此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了属性的替换...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取应用域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="comment">//获取属性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);<span class="comment">//lisi</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        向应用域对象中移除属性时执行此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了属性的移除...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取应用域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="comment">//获取属性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(value);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContextListenerDemo</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="comment">//ServletContext对象创建的时候执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了对象的创建...&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加属性</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换属性</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除属性</span></span><br><span class="line">        servletContext.removeAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ServletContext对象销毁的时候执行此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;监听到了对象的销毁...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">监听到了对象的创建...</span><br><span class="line">监听到了属性的添加...</span><br><span class="line">zhangsan</span><br><span class="line">监听到了属性的替换</span><br><span class="line">lisi</span><br><span class="line">监听到属性的移除</span><br><span class="line">null</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVAWebing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVAWeb </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWeb-Filter学习笔记</title>
      <link href="/posts/4f0925cd.html"/>
      <url>/posts/4f0925cd.html</url>
      
        <content type="html"><![CDATA[<h1>Filter</h1><h2 id="Filter">Filter</h2><h3 id="过滤器">过滤器</h3><p>Filter：过滤器，是 JavaWeb 三大组件之一，另外两个是 Servlet 和 Listener</p><p>工作流程：在程序访问服务器资源时，当一个请求到来，服务器首先判断是否有过滤器与去请求资源相关联，如果有过滤器可以将请求拦截下来，完成一些特定的功能，再由过滤器决定是否交给请求资源，如果没有就直接请求资源，响应同理</p><p>作用：过滤器一般用于完成通用的操作，例如：登录验证、统一编码处理、敏感字符过滤等</p><hr><h3 id="相关类">相关类</h3><h4 id="Filter-2">Filter</h4><p>Filter是一个接口，如果想实现过滤器的功能，必须实现该接口</p><ul><li><p>核心方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void init(FilterConfig filterConfig)</td><td>初始化，开启过滤器</td></tr><tr><td>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td><td>对请求资源和响应资源过滤</td></tr><tr><td>void destroy()</td><td>销毁过滤器</td></tr></tbody></table></li><li><p>配置方式</p><p>注解方式</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line">()内填拦截路径，<span class="comment">/*代表全部路径</span></span><br></pre></td></tr></table></figure><p>配置文件</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo01<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="FilterChain">FilterChain</h4><ul><li><p>FilterChain 是一个接口，代表过滤器对象。由Servlet容器提供实现类对象，直接使用即可。</p></li><li><p>过滤器可以定义多个，就会组成过滤器链</p></li><li><p>核心方法：<code>void doFilter(ServletRequest request, ServletResponse response)</code> 用来放行方法</p><p>如果有多个过滤器，在第一个过滤器中调用下一个过滤器，以此类推，直到到达最终访问资源。<br>如果只有一个过滤器，放行时就会直接到达最终访问资源。</p></li></ul><h4 id="FilterConfig">FilterConfig</h4><p>FilterConfig 是一个接口，代表过滤器的配置对象，可以加载一些初始化参数</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>String getFilterName()</td><td>获取过滤器对象名称</td></tr><tr><td>String getInitParameter(String name)</td><td>获取指定名称的初始化参数的值，不存在返回null</td></tr><tr><td>Enumeration<String> getInitParameterNames()</td><td>获取所有参数的名称</td></tr><tr><td>ServletContext getServletContext()</td><td>获取应用上下文对象</td></tr></tbody></table><hr><h3 id="Filter使用">Filter使用</h3><h4 id="设置页面编码">设置页面编码</h4><p>请求先被过滤器拦截进行相关操作</p><p>过滤器放行之后执行完目标资源，仍会回到过滤器中</p><ul><li><p>Filter 代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo01拦截到请求...&quot;</span>);</span><br><span class="line">        <span class="comment">//处理乱码</span></span><br><span class="line">        servletResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//过滤器放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo1放行之后，又回到了doFilter方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Servlet 代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo01执行了...&quot;</span>);</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;servletDemo01执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制台输出：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filterDem<span class="meta">o01</span>拦截到请求...</span><br><span class="line">servletDem<span class="meta">o01</span>执行了...</span><br><span class="line">filterDem<span class="meta">o1</span>放行之后，又回到了doFilter方法  </span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="多过滤器顺序">多过滤器顺序</h4><p>多个过滤器使用的顺序，取决于过滤器映射的顺序。</p><ul><li><p>两个 Filter 代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo01</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo01执行了...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo02</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo02执行了...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Servlet代码：<code>System.out.println(&quot;servletDemo02执行了...&quot;);</code></p></li><li><p>web.xml配置：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo01<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo01<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo02<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo02<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制台输出：</p>  <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filterDem<span class="meta">o01</span>执行了</span><br><span class="line">filterDem<span class="meta">o02</span>执行了</span><br><span class="line">servletDem<span class="meta">o02</span>执行了...</span><br></pre></td></tr></table></figure></li></ul><p>在过滤器的配置中，有过滤器的声明和过滤器的映射两部分，到底是声明决定顺序，还是映射决定顺序呢？</p><p>答案是：<code>&lt;filter-mapping&gt;</code>的配置前后顺序决定过滤器的调用顺序，也就是由映射配置顺序决定。</p><hr><h4 id="Filter生命周期">Filter生命周期</h4><p>**创建：**当应用加载时实例化对象并执行init()初始化方法</p><p>**服务：**对象提供服务的过程，执行doFilter()方法</p><p><strong>销毁</strong>：当应用卸载时或服务器停止时对象销毁，执行destroy()方法</p><ul><li><p>Filter代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo03</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        初始化方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象初始化成功了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        提供服务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo03执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">//过滤器放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对象销毁方法，关闭Tomcat服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象销毁了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Servlet 代码：<code>System.out.println(&quot;servletDemo03执行了...&quot;);</code></p></li><li><p>控制台输出：</p>  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象初始化成功了...</span><br><span class="line">filterDemo03执行了...</span><br><span class="line">servletDemo03执行了...</span><br><span class="line">对象销毁了</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="FilterConfig使用">FilterConfig使用</h4><p>Filter初始化函数init的参数是FilterConfig 对象</p><ul><li><p>Filter代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo04</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象初始化成功了...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取过滤器名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filterName</span> <span class="operator">=</span> filterConfig.getFilterName();</span><br><span class="line">        System.out.println(filterName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据name获取value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo04执行了...&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>web.xml配置</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo04<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo04<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filterDemo04<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制台输出：</p>  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象初始化成功了...</span><br><span class="line">filterDemo04</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="拦截行为">拦截行为</h3><p>Filter过滤器默认拦截的是请求，但是在实际开发中，我们还有请求转发和请求包含，以及由服务器触发调用的全局错误页面。默认情况下过滤器是不参与过滤的，需要配置web.xml</p><p>开启功能后，当访问页面发生相关行为后，会执行过滤器的操作</p><p>五种拦截行为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo5<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo5<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo5<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;url-pattern&gt;/index.jsp&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤请求：默认值。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>REQUEST<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤全局错误页面：开启后，当由服务器调用全局错误页面时，过滤器工作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤请求转发：开启后，当请求转发时，过滤器工作。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>FORWARD<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤请求包含：当请求包含时，过滤器工作。它只能过滤动态包含，jsp的include指令是静态包含--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>INCLUDE<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤异步类型，它要求我们在filter标签中配置开启异步支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ASYNC<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>web.xml：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo5<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.FilterDemo5<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置开启异步支持，当dispatcher配置ASYNC时，需要配置此行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDemo5<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dispatcher</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">dispatcher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>    </span><br></pre></td></tr></table></figure></li><li><p>ServletDemo03：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo03执行了...&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/ <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>FilterDemo05：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo05</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filterDemo05执行了...&quot;</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问URL：<a href="http://localhost:8080/filter/servletDemo03">http://localhost:8080/filter/servletDemo03</a></p></li><li><p>控制台输出（注意输出顺序）：</p>  <figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">servletDemo03执行了...</span><br><span class="line">filterDemo05执行了...</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="对比Servlet">对比Servlet</h3><table><thead><tr><th>方法/类型</th><th>Servlet</th><th>Filter</th><th>备注</th></tr></thead><tbody><tr><td>初始化                                        方法</td><td>void   init(ServletConfig);</td><td>void init(FilterConfig);</td><td>几乎一样，都是在web.xml中配置参数，用该对象的方法可以获取到。</td></tr><tr><td>提供服务方法</td><td>void   service(request,response);</td><td>void   dofilter(request,response,FilterChain)</td><td>Filter比Servlet多了一个FilterChain，它不仅能完成Servlet的功能，而且还可以决定程序是否能继续执行。所以过滤器比Servlet更为强大。   在Struts2中，核心控制器就是一个过滤器。</td></tr><tr><td>销毁方法</td><td>void destroy();</td><td>void destroy();</td><td>方法/类型</td></tr></tbody></table><hr><h2 id="Liste">Liste</h2>]]></content>
      
      
      <categories>
          
          <category> JAVAWebing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVAWeb </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWeb-Web相关存储技术学习笔记</title>
      <link href="/posts/a64f54ba.html"/>
      <url>/posts/a64f54ba.html</url>
      
        <content type="html"><![CDATA[<h1>Cookie &amp;&amp; Session</h1><h2 id="Cookie">Cookie</h2><h3 id="会话技术">会话技术</h3><p><strong>会话</strong>：浏览器和服务器之间的多次请求和响应</p><p>浏览器和服务器可能产生多次的请求和响应，从浏览器访问服务器开始，到访问服务器结束（关闭浏览器、到了过期时间），这期间产生的多次请求和响应加在一起称为浏览器和服务器之间的一次对话</p><p>作用：保存用户各自的数据（以浏览器为单位），在多次请求间实现数据共享</p><p><strong>常用的会话管理技术</strong>：</p><ul><li><p>Cookie：客户端会话管理技术，用户浏览的信息以键值对（key=value）的形式保存在浏览器上。如果没有关闭浏览器，再次访问服务器，会把 cookie 带到服务端，服务端就可以做相应的处理</p></li><li><p>Session：服务端会话管理技术。当客户端第一次请求 session 对象时，服务器为每一个浏览器开辟一块内存空间，并将通过特殊算法算出一个 session 的 ID，用来标识该 session 对象。由于内存空间是每一个浏览器独享的，所有用户在访问的时候，可以把信息保存在 session 对象中，同时服务器会把 sessionId 写到 cookie 中，再次访问的时候，浏览器会把 cookie(sessionId) 带过来，找到对应的 session 对象即可</p><p>tomcat 生成的 sessionID 叫做 jsessionID</p></li></ul><p>两者区别：</p><ul><li><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie，应该将 Cookie 信息加密然后使用到的时候再去服务器端解密</p></li><li><p>Cookie 一般用来保存用户信息，在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候就不需要重新登录，因为用户登录的时候可以存放一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可（为了安全考虑，重新登录一般要将 Token 重写），所以登录一次网站后访问网站其他页面不需要重新登录</p></li><li><p>Session 通过服务端记录用户的状态，服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户</p></li><li><p>Cookie 只能存储 ASCII 码，而 Session 可以存储任何类型的数据</p></li></ul><p>参考文章：<a href="https://blog.csdn.net/weixin_43625577/article/details/92393581">https://blog.csdn.net/weixin_43625577/article/details/92393581</a></p><hr><h3 id="基本介绍">基本介绍</h3><p>Cookie：客户端会话管理技术，把要共享的数据保存到了客户端（也就是浏览器端）。每次请求时，把会话信息带到服务器，从而实现多次请求的数据共享。</p><p>作用：保存客户浏览器访问网站的相关内容（需要客户端不禁用 Cookie），从而在每次访问同一个内容时，先从本地缓存获取，使资源共享，提高效率。</p><p><img src="../image/post/Cookie%E7%B1%BB%E8%AE%B2%E8%A7%A3.png" alt=""></p><hr><h3 id="基本使用">基本使用</h3><h4 id="常用API">常用API</h4><ul><li><p><strong>Cookie属性：</strong></p><table><thead><tr><th>属性名称</th><th>属性作用</th><th>是否重要</th></tr></thead><tbody><tr><td>name</td><td>cookie的名称</td><td>必要属性</td></tr><tr><td>value</td><td>cookie的值（不能是中文）</td><td>必要属性</td></tr><tr><td>path</td><td>cookie的路径</td><td>重要</td></tr><tr><td>domain</td><td>cookie的域名</td><td>重要</td></tr><tr><td>maxAge</td><td>cookie的生存时间</td><td>重要</td></tr><tr><td>version</td><td>cookie的版本号</td><td>不重要</td></tr><tr><td>comment</td><td>cookie的说明</td><td>不重要</td></tr></tbody></table><p>注意：Cookie 有大小，个数限制。每个网站最多只能存20个 Cookie，且大小不能超过 4kb。同时所有网站的 Cookie 总数不超过300个。</p></li><li><p><strong>Cookie类API：</strong></p><ul><li><p><code>Cookie(String name, String value)</code> : 构造方法创建 Cookie 对象</p></li><li><p>Cookie 属性对应的 set 和 get 方法，name 属性被 final 修饰，没有 set 方法</p></li></ul></li><li><p>HttpServletResponse 类 API：</p><ul><li><code>void addCookie(Cookie cookie)</code>：向客户端添加 Cookie，Adds cookie to the response</li></ul></li><li><p>HttpServletRequest类API：</p><ul><li><code>Cookie[] getCookies()</code>：获取所有的 Cookie 对象，client sent with this request</li></ul></li></ul><hr><h4 id="有效期">有效期</h4><p>如果不设置过期时间，表示这个 Cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口 Cookie 就消失，这种生命期为浏览会话期的 Cookie 被称为会话 Cookie，会话 Cookie 一般不保存在硬盘上而是保存在内存里。</p><p>如果设置过期时间，浏览器就会把 Cookie 保存到硬盘上，关闭后再次打开浏览器，这些 Cookie 依然有效直到超过设定的过期时间。存储在硬盘上的 Cookie 可以在<strong>不同的浏览器进程间共享</strong>，比如两个 IE 窗口，而对于保存在内存的 Cookie，不同的浏览器有不同的处理方式</p><p>设置 Cookie 存活时间 API：<code>void setMaxAge(int expiry)</code></p><ul><li>-1：默认。代表 Cookie 数据存到浏览器关闭（保存在浏览器文件中）</li><li>0：代表删除 Cookie，如果要删除 Cookie 要确保<strong>路径一致</strong>。</li><li>正整数：以秒为单位保存数据有有效时间（把缓存数据保存到磁盘中）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.通过响应对象写出提示信息</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        pw.write(<span class="string">&quot;欢迎访问本网站，您的最后访问时间为：&lt;br&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Cookie对象，用于记录最后访问时间</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;time&quot;</span>,System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.设置最大存活时间</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">3600</span>);</span><br><span class="line">        <span class="comment">//cookie.setMaxAge(0);    // 立即清除</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将cookie对象添加到客户端</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.获取cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="keyword">for</span>(Cookie c : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;time&quot;</span>.equals(c.getName())) &#123;</span><br><span class="line">                <span class="comment">//6.获取cookie对象中的value，进行写出</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> c.getValue();</span><br><span class="line">                <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">                pw.write(sdf.format(Long.parseLong(value)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="有效路径">有效路径</h4><p><code>setPath(String url)</code> : Cookie 设置有效路径</p><p>有效路径作用 :</p><ol><li>保证不会携带别的网站/项目里面的 Cookie 到我们自己的项目</li><li>路径不一样，Cookie 的 key 可以相同</li><li>保证自己的项目可以合理的利用自己项目的 Cookie</li></ol><p>判断路径是否携带 Cookie：请求资源 URI.startWith(cookie的path)，返回 true 就带</p><table><thead><tr><th>访问URL</th><th>URI部分</th><th>Cookie的Path</th><th>是否携带Cookie</th><th>能否取到Cookie</th></tr></thead><tbody><tr><td><a href="http://localhost:8080/servlet/servletDemo02">servletDemo02</a></td><td>/servlet/servletDemo02</td><td>/servlet/</td><td>带</td><td>能取到</td></tr><tr><td><a href="http://localhost:8080/servlet/servletDemo03">servletDemo03</a></td><td>/servlet/servletDemo03</td><td>/servlet/</td><td>带</td><td>能取到</td></tr><tr><td><a href="http://localhost:8080/servlet/aaa/servletDemo03">servletDemo04</a></td><td>/servlet/aaa/servletDemo04</td><td>/servlet/</td><td>带</td><td>能取到</td></tr><tr><td><a href="http://localhost:8080/bbb/servletDemo03">servletDemo05</a></td><td>/bbb/servletDemo04</td><td>/servlet/</td><td>不带</td><td>不能取到</td></tr></tbody></table><p>只有当访问资源的 url 包含此 cookie 的有效 path 的时候，才会携带这个 cookie</p><p>想要当前项目下的 Servlet 可以使用该 cookie，一般设置：<code>cookie.setPath(request.getContextPath())</code></p><hr><h4 id="安全性">安全性</h4><p>如果 Cookie 中设置了 HttpOnly 属性，通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击，窃取 cookie 内容，这样就增加了安全性，即便是这样，也不要将重要信息存入cookie。</p><p>XSS 全称 Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有 XSS 漏洞的网站中输入(传入)恶意的 HTML 代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如盗取用户 Cookie、破坏页面结构、重定向到其它网站等。</p><hr><h2 id="Session">Session</h2><h3 id="基本介绍-2">基本介绍</h3><p>Session：服务器端会话管理技术，本质也是采用客户端会话管理技术，不过在客户端保存的是一个特殊标识，共享的数据保存到了服务器的内存对象中。每次请求时，会将特殊标识带到服务器端，根据标识来找到对应的内存空间，从而实现数据共享。简单说它就是一个服务端会话对象，用于存储用户的会话数据。</p><p>Session 域（会话域）对象是 Servlet 规范中四大域对象之一，并且它也是用于实现数据共享的</p><table><thead><tr><th>域对象</th><th>功能</th><th>创建</th><th>销毁</th><th>使用场景</th></tr></thead><tbody><tr><td>ServletContext</td><td>应用域</td><td>服务器启动</td><td>服务器关闭</td><td>在整个应用之间实现数据共享<br />（记录网站访问次数，聊天室）</td></tr><tr><td>ServletRequest</td><td>请求域</td><td>请求到来</td><td>响应了这个请求</td><td>在当前请求或者请求转发之间实现数据共享</td></tr><tr><td>HttpSession</td><td>会话域</td><td>getSession()</td><td>session过期，调用invalidate()，服务器关闭</td><td>在当前会话范围中实现数据共享，可以在多次请求中实现数据共享。<br />（验证码校验, 保存用户登录状态等）</td></tr></tbody></table><hr><h3 id="基本使用-2">基本使用</h3><h4 id="获取会话">获取会话</h4><p>HttpServletRequest类获取Session：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>HttpSession getSession()</td><td>获取HttpSession对象</td></tr><tr><td>HttpSession getSession(boolean creat)</td><td>获取HttpSession对象，未获取到是否自动创建</td></tr></tbody></table><img src="../image/post/Session%E8%8E%B7%E5%8F%96%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95.png" style="zoom: 80%;" /><hr><h4 id="常用API-2">常用API</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void setAttribute(String name, Object value)</td><td>设置会话域中的数据</td></tr><tr><td>Object getAttribute(String name)</td><td>获取指定名称的会话域数据</td></tr><tr><td>Enumeration<String> getAttributeNames()</td><td>获取所有会话域所有属性的名称</td></tr><tr><td>void removeAttribute(String name)</td><td>移除会话域中指定名称的数据</td></tr><tr><td>String getId()</td><td>获取唯一标识名称，Jsessionid的值</td></tr><tr><td>void invalidate()</td><td>立即失效session</td></tr></tbody></table><hr><h4 id="实现会话">实现会话</h4><p>通过第一个Servlet设置共享的数据用户名，并在第二个Servlet获取到。</p><p>项目执行完以后，去浏览器抓包，Request Headers 中的 Cookie JSESSIONID的值是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取请求的用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取HttpSession的对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        System.out.println(session.getId());</span><br><span class="line">        <span class="comment">//3.将用户名信息添加到共享数据中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo02&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo02</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取HttpSession对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="comment">//2.获取共享数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//3.将数据响应给浏览器</span></span><br><span class="line">        resp.getWriter().write(username+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="生命周期">生命周期</h4><p>Session 的创建：一个常见的错误是以为 Session 在有客户端访问时就被创建，事实是直到某 server 端程序(如Servlet）调用 <code>HttpServletRequest.getSession(true)</code> 这样的语句时才会被创建</p><p>Session 在以下情况会被删除：</p><ul><li>程序调用 HttpSession.invalidate()</li><li>距离上一次收到客户端发送的 session id 时间间隔超过了 session 的最大有效时间</li><li>服务器进程被停止</li></ul><p>注意事项：</p><ul><li>客户端只保存 sessionID 到 cookie 中，而不会保存 session</li><li>关闭浏览器只会使存储在客户端浏览器内存中的 cookie 失效，不会使服务器端的 session 对象失效，同样也不会使已经保存到硬盘上的持久化cookie消失</li></ul><p>打开两个浏览器窗口访问应用程序会使用的是不同的session，通常 session cookie 是不能跨窗口使用，当新开了一个浏览器窗口进入相同页面时，系统会赋予一个新的 session id，实现跨窗口信息共享：</p><ul><li>先把 session id 保存在 persistent cookie 中（通过设置session的最大有效时间）</li><li>在新窗口中读出来，就可以得到上一个窗口的 session id，这样通过 session cookie 和 persistent cookie 的结合就可以实现跨窗口的会话跟踪</li></ul><hr><h3 id="会话问题">会话问题</h3><h4 id="禁用Cookie">禁用Cookie</h4><p>浏览器禁用Cookie解决办法：</p><ul><li><p>方式一：通过提示信息告知用户</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取HttpSession对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession(<span class="literal">false</span>);</span><br><span class="line">        System.out.println(session);</span><br><span class="line">        <span class="keyword">if</span>(session == <span class="literal">null</span>) &#123;</span><br><span class="line">            resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;为了不影响正常的使用，请不要禁用浏览器的Cookie~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方式二：访问时拼接 jsessionid 标识，通过 encodeURL() 方法<strong>重写地址</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">    <span class="comment">//实现url重写  相当于在地址栏后面拼接了一个jsessionid</span></span><br><span class="line">    resp.getWriter().write(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+ resp.encodeURL</span><br><span class="line">                           (<span class="string">&quot;http://localhost:8080/session/servletDemo03&quot;</span>) +</span><br><span class="line">                           <span class="string">&quot;&#x27;&gt;go servletDemo03&lt;/a&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="钝化活化">钝化活化</h4><p>Session 存放在服务器端的内存中，可以做持久化管理。</p><p>钝化：序列化，持久态。把长时间不用，但还不到过期时间的 HttpSession 进行序列化写到磁盘上。</p><p>活化：相反的状态</p><p>何时钝化：</p><ul><li>当访问量很大时，服务器会根据getLastAccessTime来进行排序，对长时间不用，但是还没到过期时间的HttpSession进行序列化（持久化）</li><li>当服务器进行重启的时候，为了保持客户HttpSession中的数据，也要对HttpSession进行序列化（持久化）</li></ul><p>注意：</p><ul><li>HttpSession的持久化由服务器来负责管理，我们不用关心</li><li>只有实现了序列化接口的类才能被序列化</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVAWebing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVAWeb </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWeb-Request、Response学习笔记</title>
      <link href="/posts/463f28e1.html"/>
      <url>/posts/463f28e1.html</url>
      
        <content type="html"><![CDATA[<h1>Request/Response</h1><h2 id="Request">Request</h2><h3 id="请求响应">请求响应</h3><p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。</p><p><img src="../image/post/Servlet%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E5%9B%BE.png" alt=""></p><hr><h3 id="请求对象">请求对象</h3><p>请求：客户机希望从服务器端索取一些资源，向服务器发出询问</p><p>请求对象：在 JavaEE 工程中，用于发送请求的对象，常用的对象是 ServletRequest 和 HttpServletRequest ，它们的区是是否与 HTTP 协议有关</p><p>Request 作用：</p><ul><li>操作请求三部分(行,头,体)</li><li>请求转发</li><li>作为域对象存数据</li></ul><p><img src="../image/post/Request%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E8%A7%86%E5%9B%BE.png" alt=""></p><hr><h3 id="请求路径">请求路径</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>String  getLocalAddr()</td><td>获取本机（服务器）地址</td></tr><tr><td>String getLocalName()</td><td>获取本机（服务器）名称</td></tr><tr><td>int getLocalPort()</td><td>获取本机（服务器）端口</td></tr><tr><td>String getRemoteAddr()</td><td>获取访问者IP</td></tr><tr><td>String getRemoteHost</td><td>获取访问者主机</td></tr><tr><td>int getRemotePort()</td><td>获取访问者端口</td></tr><tr><td>String getMethod();</td><td>获得请求方式</td></tr><tr><td>String getRequestURI()</td><td>获取统一资源标识符（/request/servletDemo01）</td></tr><tr><td>String getRequestURL()</td><td>获取统一资源定位符（<a href="http://localhost:8080/request/servletDemo01%EF%BC%89">http://localhost:8080/request/servletDemo01）</a></td></tr><tr><td>String getQueryString()</td><td>获取请求消息的数据<br />（GET方式 URL中带参字符串：username=aaa&amp;password=123）</td></tr><tr><td>String getContextPath()</td><td>获取虚拟目录名称（/request）</td></tr><tr><td>String getServletPath</td><td>获取Servlet映射路径<br />（<url-pattern>或@WebServlet值: /servletDemo01）</td></tr><tr><td>String getRealPath(String path)</td><td>根据虚拟目录获取应用部署的磁盘绝对路径</td></tr></tbody></table><p>URL = HOST + URI</p><p>URI = ContextPath + ServletPath</p><hr><h3 id="获取请求头">获取请求头</h3><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>String  getHeader(String name)</td><td>获得指定请求头的值。<br />如果没有该请求头返回null，有多个值返回第一个</td></tr><tr><td>Enumeration<String> getHeaders(String name)</td><td>获取指定请求头的多个值</td></tr><tr><td>Enumeration<String> getHeaderNames()</td><td>获取所有请求头名称的枚举</td></tr></tbody></table><hr><h3 id="请求参数">请求参数</h3><p>请求参数是正文部分<input>标签内容，<form>标签属性action=“/request/servletDemo08”，服务器URI</p><table><thead><tr><th>法名</th><th>作用</th></tr></thead><tbody><tr><td>String getParameter(String name)</td><td>获得指定参数名的值<br />如果没有该参数则返回null，如果有多个获得第一个</td></tr><tr><td>String[] getParameterValues(String name)</td><td>获得指定参数名所有的值。此方法为复选框提供的</td></tr><tr><td>Enumeration<String> getParameterNames()</td><td>获得所有参数名</td></tr><tr><td>Map&lt;String,String[]&gt; getParameterMap()</td><td>获得所有的请求参数键值对（key=value）</td></tr></tbody></table><hr><h3 id="请求域">请求域</h3><p>request 域：可以在一次请求范围内进行共享数据</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>void setAttribute(String name, Object value)</td><td>向请求域对象中存储数据</td></tr><tr><td>Object getAttribute(String name)</td><td>通过名称获取请求域对象的数据</td></tr><tr><td>void removeAttribute(String name)</td><td>通过名称移除请求域对象的数据</td></tr></tbody></table><hr><h4 id="请求转发">请求转发</h4><p>请求转发：客户端的一次请求到达后，需要借助其他 Servlet 来实现功能，进行请求转发。特点：</p><ul><li>浏览器地址栏不变</li><li>域对象中的数据不丢失</li><li>负责转发的 Servlet 转发前后响应正文会丢失</li><li>由转发目的地来响应客户端</li></ul><p>HttpServletRequest 类方法：</p><ul><li><code>RequestDispatcher getRequestDispatcher(String path) </code> : 获取任务调度对象</li></ul><p>RequestDispatcher 类方法：</p><ul><li><code>void forward(ServletRequest request, ServletResponse response)</code> : 实现转发，将请求从 Servlet 转发到服务器上的另一个资源（Servlet，JSP 文件或 HTML 文件）</li></ul><p>过程：浏览器访问 <a href="http://localhost:8080/request/servletDemo09%EF%BC%8C/servletDemo10%E4%B9%9F%E4%BC%9A%E6%89%A7%E8%A1%8C">http://localhost:8080/request/servletDemo09，/servletDemo10也会执行</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo09</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置共享数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;encoding&quot;</span>,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">//获取请求调度对象</span></span><br><span class="line">        <span class="type">RequestDispatcher</span> <span class="variable">rd</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;/servletDemo10&quot;</span>);</span><br><span class="line">        <span class="comment">//实现转发功能</span></span><br><span class="line">        rd.forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo10&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo10</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取共享数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">encoding</span> <span class="operator">=</span> req.getAttribute(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">        System.out.println(encoding);<span class="comment">//gbk</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo10执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="请求包含">请求包含</h4><p>请求包含：合并其他的 Servlet 中的功能一起响应给客户端。特点：</p><ul><li>浏览器地址栏不变</li><li>域对象中的数据不丢失</li><li>被包含的 Servlet 响应头会丢失</li></ul><p>请求转发的注意事项：负责转发的 Servlet，转发前后的响应正文丢失，由转发目的地来响应浏览器</p><p>请求包含的注意事项：被包含者的响应消息头丢失，因为它被包含者包含起来了</p><p>HttpServletRequest 类方法：</p><ul><li><code>RequestDispatcher getRequestDispatcher(String path) </code> : 获取任务调度对象</li></ul><p>RequestDispatcher 类方法：</p><ul><li><code>void include(ServletRequest request, ServletResponse response) </code> : 实现包含。包括响应中资源的内容（servlet，JSP页面，HTML文件）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo11&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo11</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo11执行了...&quot;</span>);<span class="comment">//执行了</span></span><br><span class="line">        <span class="comment">//获取请求调度对象</span></span><br><span class="line">        <span class="type">RequestDispatcher</span> <span class="variable">rd</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;/servletDemo12&quot;</span>);</span><br><span class="line">        <span class="comment">//实现包含功能</span></span><br><span class="line">        rd.include(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**********************************************************************************</span><br><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo12&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo12</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo12执行了...&quot;</span>);<span class="comment">//输出了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="乱码问题">乱码问题</h3><p>请求体</p><ul><li><p>POST：<code>void setCharacterEncoding(String env)</code>：设置请求体的编码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo08&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo08</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置编码格式</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>GET：Tomcat8.5 版本及以后，Tomcat 服务器已经帮我们解决</p></li></ul><h2 id="Response">Response</h2><h3 id="响应对象">响应对象</h3><p>响应，服务器把请求的处理结果告知客户端</p><p>响应对象：在 JavaEE 工程中，用于发送响应的对象</p><ul><li>协议无关的对象标准是：ServletResponse 接口</li><li>协议相关的对象标准是：HttpServletResponse 接口</li></ul><p>Response 的作用：</p><ul><li>操作响应的三部分(行, 头, 体)</li></ul><ul><li>请求重定向</li></ul><p><img src="../image/post/Response%E5%93%8D%E5%BA%94%E7%B1%BB%E8%A7%86%E5%9B%BE.png" alt=""></p><hr><h3 id="操作响应行">操作响应行</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getStatus()</td><td>Gets the current status code of this response</td></tr><tr><td>void setStatus(int sc)</td><td>Sets the status code for this response</td></tr></tbody></table><p>状态码：（HTTP–&gt;相应部分）</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">消息</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">重定向</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">客户端错误</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">服务器错误</td></tr></tbody></table><hr><h3 id="操作响应体">操作响应体</h3><h4 id="字节流响应">字节流响应</h4><p>响应体对应<strong>乱码问题</strong></p><p>项目中常用的编码格式是UTF-8，而浏览器默认使用的编码是gbk。导致乱码！</p><p>解决方式：<br>一：修改浏览器的编码格式(不推荐，不能让用户做修改的动作)<br>二：通过输出流写出一个标签：&lt;meta http-equiv='content-type’content=‘text/html;charset=UTF-8’&gt;<br>三：指定响应头信息：response.setHeader(“Content-Type”,“text/html;charset=UTF-8”)<br>四：response.setContentType(“text/html;charset=UTF-8”)</p><p>常用API：<br><code>ServletOutputStream getOutputStream()</code> : 获取响应字节输出流对象<br><code>void setContenType(&quot;text/html;charset=UTF-8&quot;)</code> : 设置响应内容类型，解决中文乱码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo01&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置响应内容类型</span></span><br><span class="line">resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//2.通过响应对象获取字节输出流对象</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">sos</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        <span class="comment">//3.定义消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        <span class="comment">//4.通过字节流输出对象</span></span><br><span class="line">        sos.write(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="字符流响应">字符流响应</h4><p>response得到的字符流和字节流互斥，只能选其一，response获取的流不用关闭，由服务器关闭即可。</p><p>常用API：<br><code>PrintWriter getWriter()</code> : 获取响应字节输出流对象，可以发送标签<br><code>void setContenType(&quot;text/html;charset=UTF-8&quot;)</code> : 设置响应内容类型，解决中文乱码问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">    <span class="comment">//解决中文乱码</span></span><br><span class="line">    resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">//获取字符流对象</span></span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">    pw.write(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="响应图片">响应图片</h4><p>响应图片到浏览器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo03&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.通过文件的相对路径来获取文件的绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> getServletContext().getRealPath(<span class="string">&quot;/img/hm.png&quot;</span>);</span><br><span class="line">        <span class="comment">//E:\Project\JavaEE\out\artifacts\Response_war_exploded\img\hm.png</span></span><br><span class="line">        System.out.println(realPath);</span><br><span class="line">        <span class="comment">//2.创建字节输入流对象，关联图片路径</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过响应对象获取字节输出流对象</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">sos</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.循环读写</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sos.write(arr,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="操作响应头">操作响应头</h3><h4 id="常用方法">常用方法</h4><p>响应头: 是服务器指示浏览器去做什么</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String getHeader(String name)</td><td>获取指定响应头的内容</td></tr><tr><td>Collection<String> getHeaders(String name)</td><td>获取指定响应头的多个值</td></tr><tr><td>Collection<String> getHeaderNames()</td><td>获取所有响应头名称的枚举</td></tr><tr><td>void setHeader(String name, String value)</td><td>设置响应头</td></tr><tr><td>void setDateHeader(String name, long date)</td><td>设置具有给定名称和日期值的响应消息头</td></tr><tr><td>void sendRedirect(String location)</td><td>设置重定向</td></tr></tbody></table><p>setHeader常用响应头：</p><ul><li>Expires：设置缓存时间</li><li>Refresh：定时跳转</li><li>Location：重定向地址</li><li>Content-Disposition: 告诉浏览器下载</li><li>Content-Type：设置响应内容的MIME类型(服务器告诉浏览器内容的类型)</li></ul><hr><h4 id="控制缓存">控制缓存</h4><p>缓存：对于不经常变化的数据，我们可以设置合理的缓存时间，防止浏览器频繁的请求服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo04&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo04</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">news</span> <span class="operator">=</span> <span class="string">&quot;设置缓存时间&quot;</span>;</span><br><span class="line">        <span class="comment">//设置缓存时间，缓存一小时</span></span><br><span class="line">        resp.setDateHeader(<span class="string">&quot;Expires&quot;</span>,System.currentTimeMillis()+<span class="number">1</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">//设置编码格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        resp.getWriter().write(news);</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);<span class="comment">//只输出一次，不能刷新，必须从网址直接进入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../image/post/Response%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4.png" alt=""></p><hr><h4 id="定时刷新">定时刷新</h4><p>定时刷新：过了指定时间后，页面进行自动跳转</p><p>格式：<code>setHeader(&quot;Refresh&quot;, &quot;3;URL=https://www.baidu.com&quot;&quot;);</code><br>Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo05&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo05</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">news</span> <span class="operator">=</span> <span class="string">&quot;您的用户名或密码错误，3秒后自动跳转到登录页面...&quot;</span>;</span><br><span class="line">        <span class="comment">//设置编码格式</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        resp.getWriter().write(news);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置响应消息头定时刷新</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Refresh&quot;</span>,<span class="string">&quot;3;URL=/response/login.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="下载文件">下载文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo06&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo06</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建字节输入流对象，关联读取的文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> getServletContext().getRealPath(<span class="string">&quot;/img/hm.png&quot;</span>);<span class="comment">//绝对路径</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.设置响应头支持的类型  应用支持的类型为字节流</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Content-Type 消息头名称   支持的类型</span></span><br><span class="line"><span class="comment">            application/octet-stream   消息头参数  应用类型为字节流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.设置响应头以下载方式打开  以附件形式处理内容</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Content-Disposition  消息头名称  处理的形式</span></span><br><span class="line"><span class="comment">            attachment;filename=  消息头参数  附件形式进行处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取字节输出流对象</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">sos</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.循环读写文件</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            sos.write(arr,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.释放资源</span></span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="重定向">重定向</h4><h5 id="实现重定向">实现重定向</h5><p>请求重定向：客户端的一次请求到达后，需要借助其他 Servlet 来实现功能。特点：</p><ol><li>重定向两次请求</li><li>重定向的地址栏路径改变</li><li><strong>重定向的路径写绝对路径</strong>（带域名 /ip 地址，如果是同一个项目，可以省略域名 /ip 地址）</li><li>重定向的路径可以是项目内部的,也可以是项目以外的（百度）</li><li>重定向不能重定向到 WEB-INF 下的资源</li><li>把数据存到 request 域里面，重定向不可用</li></ol><p>实现方式：</p><ul><li><p>方式一：</p><ol><li>设置响应状态码：<code>resp.setStatus(302)</code></li><li>设置重定向的路径（响应到哪里，通过响应头 location 来指定）<ul><li><code>response.setHeader(&quot;Location&quot;,&quot;http://www.baidu.com&quot;);</code></li><li><code>response.setHeader(&quot;Location&quot;,&quot;/response/servletDemo08);</code></li></ul></li></ol></li><li><p>方式二：</p><ul><li><code> resp.sendRedirect(&quot;重定向的路径&quot;);</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo07&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo07</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置请求域数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置重定向</span></span><br><span class="line">        resp.sendRedirect(req.getContextPath() + <span class="string">&quot;/servletDemo07&quot;</span>);</span><br><span class="line"><span class="comment">// resp.sendRedirect(&quot;https://www.baidu.com&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletDemo08&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo08</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servletDemo08执行了...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> req.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="重定向和转发">重定向和转发</h5><p>请求重定向跳转的特点：</p><ol><li>重定向是由<strong>浏览器发起</strong>的，在这个过程中浏览器会发起<strong>两次请求</strong></li><li>重定向可以跳转到任意服务器的资源，但是<strong>无法跳转到WEB-INF中的资源</strong></li><li>重定向不能和请求域对象共享数据，数据会丢失</li><li>重定向浏览器的地址栏中的地址会变成跳转到的路径</li></ol><p>请求转发跳转的特点：</p><ol><li>请求转发是由<strong>服务器发起</strong>的，在这个过程中浏览器只会发起<strong>一次请求</strong></li><li>请求转发只能跳转到本项目的资源，但是<strong>可以跳转到WEB-INF中的资源</strong></li><li>请求转发可以和请求域对象共享数据，数据不会丢失</li><li>请求转发浏览器地址栏不变</li></ol><p><img src="../image/post/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg" alt=""></p><hr><h3 id="路径问题">路径问题</h3><p><strong>完整URL地址：</strong></p><ol><li>协议：http://</li><li>服务器主机地址：127.0.0.1  or localhost</li><li>服务器端口号：8080</li><li>项目的虚拟路径(部署路径)：/response</li><li>具体的项目上资源路径   /login.html      or     Demo 的Servlet映射路径</li></ol><p><strong>相对路径：</strong></p><p>不以&quot;/“开头的路径写法，它是以目标路径相对当前文件的路径，其中”…&quot;表示上一级目录。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        目标资源的url: http://localhost:8080/response/demo05</span></span><br><span class="line"><span class="comment">        当前资源的url: http://localhost:8080/response/pages/demo.html</span></span><br><span class="line"><span class="comment">        相对路径的优劣:</span></span><br><span class="line"><span class="comment">            1. 优势: 无论部署的项目名怎么改变，我的路径都不需要改变</span></span><br><span class="line"><span class="comment">            2. 劣势: 如果当前资源的位置发生改变，那么相对路径就必定要发生改变--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;../demo05&quot;</span>&gt;</span>访问ServletDemo05<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>绝对路径：</strong></p><p>绝对路径就是以&quot;/&quot;开头的路径写法，项目部署的路径</p>]]></content>
      
      
      <categories>
          
          <category> JAVAWebing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVAWeb </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWeb-Serlet学习笔记</title>
      <link href="/posts/fde33443.html"/>
      <url>/posts/fde33443.html</url>
      
        <content type="html"><![CDATA[<h1>Servlet</h1><h2 id="Servlet和Tomcat的关系">Servlet和Tomcat的关系</h2><p>Tomcat 和 Servlet 的关系：Servlet 的运行环境叫做 Web 容器或 Servlet 服务器，<strong>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器</strong>。Tomcat 作为 Servlet 容器，负责处理客户请求，把请求传送给 Servlet，并将 Servlet 的响应传送回给客户。而 Servlet 是一种运行在支持 Java 语言的服务器上的组件，Servlet 用来扩展 Java Web 服务器功能，提供非常安全的、可移植的、易于使用的 CGI 替代品<br><img src="../image/post/Tomcat%E4%B8%8EServlet%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt=""></p><h2 id="执行过程">执行过程</h2><p>通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到应用。然后找到web.xml配置文件，在web.xml中找到FirstServlet的配置（<url-pattern>/<url-pattern>），找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示：</p><p><img src="../image/post/Servlet%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%9B%BE.jpg" alt=""></p><h2 id="实现方式">实现方式</h2><p>实现 Servlet 功能时，可以选择以下三种方式：</p><ul><li>第一种：实现 Servlet 接口，接口中的方法必须全部实现。<br>使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。</li><li>第二种：继承 GenericServlet，service 方法必须重写，其他方可根据需求，选择性重写。<br>使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和 HTTP 协议无关的。</li><li>第三种：继承 HttpServlet，它是 javax.servlet.http 包下的一个抽象类，是 GenericServlet 的子类。选择继承 HttpServlet 时，<strong>需要重写 doGet 和 doPost 方法</strong>，来接收 get 方式和 post 方式的请求，不要覆盖 service 方法。使用此种方式，表示我们的请求和响应需要和 HTTP 协议相关，我们是通过 HTTP 协议来访问。每次请求和响应都符合 HTTP 协议的规范。请求的方式就是 HTTP 协议所支持的方式（GET POST PUT DELETE TRACE OPTIONS HEAD )。</li></ul><h2 id="异步处理">异步处理</h2><p>Servlet 3.0 中的异步处理指的是允许Servlet重新发起一条新线程去调用 耗时业务方法，这样就可以避免等待</p><p><img src="../image/post/Servlet3.0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86.png" alt=""></p><h2 id="生命周期">生命周期</h2><p>servlet从创建到销毁的过程：</p><ul><li><p>出生：（初始化）请求第一次到达 Servlet 时，创建对象，并且初始化成功。Only one time</p></li><li><p>活着：（服务）服务器提供服务的整个过程中，该对象一直存在，每次只是执行 service 方法</p></li><li><p>死亡：（销毁）当服务停止时，或者服务器宕机时，对象删除，</p></li></ul><p>serrvlet生命周期方法:<br><code>init(ServletConfig config)</code> → <code>service(ServletRequest req, ServletResponse res)</code> → <code>destroy()</code></p><p>默认情况下, 有了第一次请求, 会调用 init() 方法进行初始化【调用一次】，任何一次请求，都会调用 service() 方法处理这个请求，服务器正常关闭或者项目从服务器移除, 调用 destory() 方法进行销毁【调用一次】</p><blockquote><p><strong>扩展</strong>：servlet 是单例多线程的，尽量不要在 servlet 里面使用全局(成员)变量，可能会导致线程不安全</p><ul><li>单例：Servlet 对象只会创建一次，销毁一次，Servlet 对象只有一个实例。</li><li>多线程：服务器会针对每次请求, 开启一个线程调用 service() 方法处理这个请求</li></ul></blockquote><h2 id="线程安全">线程安全</h2><p>Servlet运用了单例模式，整个应用中只有一个实例对象，所以需要分析这个唯一的实例中的类成员是否线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="comment">//1.定义用户名成员变量</span></span><br><span class="line">    <span class="comment">//private String username = null;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//synchronized (this) &#123;</span></span><br><span class="line">            <span class="comment">//2.获取用户名</span></span><br><span class="line">            username = req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.获取输出流对象</span></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">            <span class="comment">//4.响应给客户端浏览器</span></span><br><span class="line">            pw.print(<span class="string">&quot;Welcome:&quot;</span> + username);</span><br><span class="line">            <span class="comment">//5.关流</span></span><br><span class="line">            pw.close();</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动两个浏览器，输入不同的参数(<a href="http://localhost:8080/ServletDemo/username=aaa">http://localhost:8080/ServletDemo/username=aaa</a> 或者bbb)，访问之后发现输出的结果都是一样，所以出现线程安全问题。</p><p>在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。</p><blockquote><p>解决办法：如果类成员是共用的，只在初始化时赋值，其余时间都是获取。或者加锁synchronized</p></blockquote><h2 id="创建方式">创建方式</h2><ul><li>第一种：应用加载时创建Servlet，它的优势是在服务器启动时，就把需要的对象都创建完成了，从而在使用的时候减少了创建对象的时间，提高了首次执行的效率。它的弊端是在应用加载时就创建了Servlet对象，因此，导致内存中充斥着大量用不上的Servlet对象，造成了内存的浪费。</li><li>第二种：请求第一次访问是创建Servlet，它的优势就是减少了对服务器内存的浪费，因为一直没有被访问过的Servlet对象都没有创建，因此也提高了服务器的启动时间。而它的弊端就是要在应用加载时就做的初始化操作，它都没法完成，从而要考虑其他技术实现。</li></ul><p>在web.xml中是支持对Servlet的创建时机进行配置的，配置的方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置ServletDemo3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.itheima.web.servlet.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Servlet的创建顺序，当配置此标签时，Servlet就会改为应用加载时创建</span></span><br><span class="line"><span class="comment">        配置项的取值只能是正整数（包括0），数值越小，表明创建的优先级越高--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletDemo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ServletContext">ServletContext</h2><p>ServletContext 对象是应用上下文对象。服务器为每一个应用都创建了一个 ServletContext 对象，ServletContext 属于整个应用，不局限于某个 Servlet，可以实现让应用中所有 Servlet 间的数据共享。</p><p>上下文代表了程序当下所运行的环境，联系整个应用的生命周期与资源调用，是程序可以访问到的所有资源的总和，资源可以是一个变量，也可以是一个对象的引用</p><p>生命周期：</p><ul><li>出生：应用一加载，该对象就被创建出来。一个应用只有一个实例对象（Servlet 和 ServletContext 都是单例的）</li><li>活着：只要应用一直提供服务，该对象就一直存在。</li><li>死亡：应用被卸载（或者服务器停止），该对象消亡。</li></ul><p>域对象：指的是对象有作用域，即有作用范围，可以<strong>实现数据共享</strong>，不同作用范围的域对象，共享数据的能力不一样。</p><p>Servlet 规范中，共有4个域对象，ServletContext 是其中一个，web 应用中最大的作用域，叫 application 域，可以实现整个应用间的数据共享功能。</p><p>数据共享：</p><img src="../image/post/ServletContext%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE.png" style="zoom:50%;" /><p>获取ServletContext：</p><ul><li><p>Java 项目继承 HttpServlet，HttpServlet 继承 GenericServlet，GenericServlet 中有一个方法可以直接使用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getServletConfig().getServletContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ServletRequest 类方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletContext <span class="title function_">getServletContext</span><span class="params">()</span><span class="comment">//获取ServletContext对象</span></span><br></pre></td></tr></table></figure></li></ul><p>常用API：</p><ul><li><code>String getInitParameter(String name)</code> : 根据名称获取全局配置的参数</li><li><code>String getContextPath</code> : 获取当前应用访问的虚拟目录</li><li><code>String getRealPath(String path)</code> : 根据虚拟目录获取应用部署的磁盘绝对路径</li><li><code>void setAttribute(String name, Object object)</code> : 向应用域对象中存储数据</li><li><code>Object getAttribute(String name)</code> : 根据名称获取域对象中的数据，没有则返回null</li><li><code>void removeAttribute(String name)</code> : 根据名称移除应用域对象中的数据</li></ul><p>代码实现：</p><ul><li>web.xml配置：<br>配置的方式，需要在<code>&lt;web-app&gt;</code>标签中使用<code>&lt;context-param&gt;</code>来配置初始化参数，它的配置是针对整个应用的配置，被称为应用的初始化参数配置。</li></ul><h2 id="Servlet和Spring的Service层接口的关系">Servlet和Spring的Service层接口的关系</h2><blockquote><p>一个Service接口(方法)就是一个Servlet（实例）</p></blockquote><p>示例：设定具体 Controller，控制层 java / controller / UserController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  <span class="comment">//@Component衍生注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//设定当前方法的访问映射地址，等同于Servlet在web.xml中的配置</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="comment">//设置当前方法返回值类型为String，用于指定请求完成后跳转的页面</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user mvc controller is running ...&quot;</span>);</span><br><span class="line">        <span class="comment">//设定具体跳转的页面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 一个方法就是一个Servlet实例</p>]]></content>
      
      
      <categories>
          
          <category> JAVAWebing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVAWeb </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVAWeb-Tomcat学习笔记</title>
      <link href="/posts/b08f45c.html"/>
      <url>/posts/b08f45c.html</url>
      
        <content type="html"><![CDATA[<h1>Tomcat</h1><h2 id="服务器分类">服务器分类</h2><p>服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的<code>应用</code>。</p><blockquote><p>我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。</p></blockquote><p>常见的应用服务器：</p><table><thead><tr><th>服务器名称</th><th>说明</th></tr></thead><tbody><tr><td>weblogic</td><td>实现了 JavaEE 规范，重量级服务器，又称为 JavaEE 容器</td></tr><tr><td>websphereAS</td><td>实现了 JavaEE 规范，重量级服务器。</td></tr><tr><td>JBOSSAS</td><td>实现了 JavaEE 规范，重量级服务器，免费</td></tr><tr><td>Tomcat</td><td>实现了 jsp/servlet 规范，是一个轻量级服务器，开源免费</td></tr></tbody></table><h2 id="基本使用">基本使用</h2><ol><li>使用Tomcat自带的startup.bat，<a href="http://startup.sh">startup.sh</a>、shutdown.bat，shutdown.sh进行服务启动、停止</li><li>使用IDEA集成Run -&gt; Edit Configurations -&gt; Templates -&gt; Tomcat Server -&gt; Local</li></ol><p><img src="../image/post/image-20240622162503002.png" alt="image-20240622162503002"></p><h2 id="执行原理">执行原理</h2><h3 id="整体架构">整体架构</h3><p><img src="../image/post/image-20240622163448942.png" alt="image-20240622163448942"></p><p>组件介绍：</p><ul><li>GlobalNamingResources：实现 JNDI，指定一些资源的配置信息</li><li>Server：Tomcat 是一个 Servlet 容器，<code>一个 Tomcat 对应一个 Server，一个 Server 可以包含多个 Service</code></li><li>Service：核心服务是 Catalina，用来对请求进行处理，一个 Service 包含多个 Connector 和一个 Container</li><li>Connector：连接器，负责处理客户端请求，解析不同协议及 I/O 方式</li><li>Executor：线程池</li><li>Container：包含 Engine，Host，Context，Wrapper 等组件</li><li>Engine：服务交给引擎处理请求，Container 容器中顶层的容器对象，一个 Engine 可以包含多个 Host 主机</li><li>Host：Engine 容器的子容器，一个 Host 对应一个网络域名，一个 Host 包含多个 Context</li><li>Context：Host 容器的子容器，表示一个 Web 应用</li><li>Wrapper：Tomcat 中的最小容器单元，表示 Web 应用中的 Servlet</li></ul><p>核心类库：</p><ul><li>Coyote：Tomcat 连接器的名称，封装了底层的网络通信，为 Catalina 容器提供了统一的接口，使容器与具体的协议以及 I/O 解耦</li><li>EndPoint：Coyote 通信端点，即通信监听的接口，是 Socket 接收和发送处理器，是对传输层的抽象，用来实现 TCP/IP 协议</li><li>Processor ： Coyote 协议处理接口，用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat 的 Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象</li><li>CoyoteAdapter：适配器，连接器调用 CoyoteAdapter 的 sevice 方法，传入的是 TomcatRequest 对象，CoyoteAdapter 负责将TomcatRequest 转成 ServletRequest，再调用容器的 service 方法</li></ul><h3 id="启动过程">启动过程</h3><p>Tomcat 的启动入口是 Bootstrap#main 函数，首先通过调用 <code>bootstrap.init()</code> 初始化相关组件：</p><ul><li><code>initClassLoaders()</code>：初始化三个类加载器，commonLoader 的父类加载器是启动类加载器</li><li><code>Thread.currentThread().setContextClassLoader(catalinaLoader)</code>：自定义类加载器加载 Catalina 类，<strong>打破双亲委派</strong></li><li><code>Object startupInstance = startupClass.getConstructor().newInstance()</code>：反射创建 Catalina 对象</li><li><code>method.invoke(startupInstance, paramValues)</code>：反射调用方法，设置父类加载器是 sharedLoader</li><li><code>catalinaDaemon = startupInstance</code>：引用 Catalina 对象</li></ul><p><code>daemon.load(args)</code> 方法反射调用 Catalina 对象的 load 方法，对<strong>服务器的组件进行初始化</strong>，并绑定了 ServerSocket 的端口：</p><ul><li><p><code>parseServerXml(true)</code>：解析 XML 配置文件</p></li><li><p><code>getServer().init()</code>：服务器执行初始化，采用责任链的执行方式</p><ul><li><p><code>LifecycleBase.init()</code>：生命周期接口的初始化方法，开始链式调用</p></li><li><p><code>StandardServer.initInternal()</code>：Server 的初始化，遍历所有的 Service 进行初始化</p></li><li><p><code>StandardService.initInternal()</code>：Service 的初始化，对 Engine、Executor、listener、Connector 进行初始化</p></li><li><p><code>StandardEngine.initInternal()</code>：Engine 的初始化</p><ul><li><code>getRealm()</code>：创建一个 Realm 对象</li><li><code>ContainerBase.initInternal()</code>：容器的初始化，设置处理容器内组件的启动和停止事件的线程池</li></ul></li><li><p><code>Connector.initInternal()</code>：Connector 的初始化</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Connector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;HTTP/1.1&quot;</span>); <span class="comment">//默认无参构造方法，会创建出 Http11NioProtocol 的协议处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>adapter = new CoyoteAdapter(this)</code>：实例化 CoyoteAdapter 对象</p></li><li><p><code>protocolHandler.setAdapter(adapter)</code>：设置到 ProtocolHandler 协议处理器中</p></li><li><p><code>ProtocolHandler.init()</code>：协议处理器的初始化，底层调用 <code>AbstractProtocol#init</code> 方法</p><p><code>endpoint.init()</code>：端口的初始化，底层调用 <code>AbstractEndpoint#init</code> 方法</p><p><code>NioEndpoint.bind()</code>：绑定方法</p><ul><li><code>initServerSocket()</code>：<strong>初始化 ServerSocket</strong>，以 NIO 的方式监听端口<ul><li><code>serverSock = ServerSocketChannel.open()</code>：<strong>NIO 的方式打开通道</strong></li><li><code>serverSock.bind(addr, getAcceptCount())</code>：通道绑定连接端口</li><li><code>serverSock.configureBlocking(true)</code>：切换为阻塞模式（没懂，为什么阻塞）</li></ul></li><li><code>initialiseSsl()</code>：初始化 SSL 连接</li><li><code>selectorPool.open(getName())</code>：打开选择器，类似 NIO 的多路复用器</li></ul></li></ul></li></ul></li></ul><p>初始化完所有的组件，调用 <code>daemon.start()</code> 进行<strong>组件的启动</strong>，底层反射调用 Catalina 对象的 start 方法：</p><ul><li><p><code>getServer().start()</code>：启动组件，也是责任链的模式</p><ul><li><p><code>LifecycleBase.start()</code>：生命周期接口的初始化方法，开始链式调用</p></li><li><p><code>StandardServer.startInternal()</code>：Server 服务的启动</p><ul><li><code>globalNamingResources.start()</code>：启动 JNDI 服务</li><li><code>for (Service service : services)</code>：遍历所有的 Service 进行启动</li></ul></li><li><p><code>StandardService.startInternal()</code>：Service 的启动，对所有 Executor、listener、Connector 进行启</p></li><li><p><code>StandardEngine.startInternal()</code>：启动引擎，部署项目</p><ul><li><code>ContainerBase.startInternal()</code>：容器的启动<ul><li>启动集群、Realm 组件，并且创建子容器，提交给线程池</li><li><code>((Lifecycle) pipeline).start()</code>：遍历所有的管道进行启动<ul><li><code>Valve current = first</code>：获取第一个阀门</li><li><code>((Lifecycle) current).start()</code>：启动阀门，底层 <code>ValveBase#startInternal</code> 中设置启动的状态</li><li><code>current = current.getNext()</code>：获取下一个阀门</li></ul></li></ul></li></ul></li><li><p><code>Connector.startInternal()</code>：Connector 的初始化</p><ul><li><p><code>protocolHandler.start()</code>：协议处理器的启动</p><p><code>endpoint.start()</code>：端点启动</p><p><code>NioEndpoint.startInternal()</code>：启动 NIO 的端点</p><ul><li><code>createExecutor()</code>：创建 Worker 线程组，10 个线程，用来进行任务处理</li><li><code>initializeConnectionLatch()</code>：用来进行连接限流，<strong>最大 8*1024 条连接</strong></li><li><code>poller = new Poller()</code>：<strong>创建 Poller 对象</strong>，开启了一个多路复用器 Selector</li><li><code>Thread pollerThread = new Thread(poller, getName() + &quot;-ClientPoller&quot;)</code>：创建并启动 Poller 线程，Poller 实现了 Runnable 接口，是一个任务对象，<strong>线程 start 后进入 Poller#run 方法</strong></li><li><code>pollerThread.setDaemon(true)</code>：设置为守护线程</li><li><code>startAcceptorThread()</code>：启动接收者线程<ul><li><code>acceptor = new Acceptor&lt;&gt;(this)</code>：<strong>创建 Acceptor 对象</strong></li><li><code>Thread t = new Thread(acceptor, threadName)</code>：创建并启动 Acceptor 接受者线程</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="处理过程">处理过程</h3><ol><li>Acceptor 监听客户端套接字，每 50ms 调用一次 <strong><code>serverSocket.accept</code></strong>，获取 Socket 后把封装成 NioSocketWrapper（是 SocketWrapperBase 的子类），并设置为非阻塞模式，把 NioSocketWrapper 封装成 PollerEvent 放入同步队列中</li><li>Poller 循环判断同步队列中是否有就绪的事件，如果有则通过 <code>selector.selectedKeys()</code> 获取就绪事件，获取 SocketChannel 中携带的 attachment（NioSocketWrapper），在 processKey 方法中根据事件类型进行 processSocket，将 Wrapper 对象封装成 SocketProcessor 对象，该对象是一个任务对象，提交到 Worker 线程池进行执行</li><li><code>SocketProcessorBase.run()</code> 加锁调用 <code>SocketProcessor#doRun</code>，保证线程安全，从协议处理器 ProtocolHandler 中获取 AbstractProtocol，然后<strong>创建 Http11Processor 对象处理请求</strong></li><li><code>Http11Processor#service</code> 中调用 <code>CoyoteAdapter#service</code> ，把生成的 Tomcat 下的 Request 和 Response 对象通过方法 postParseRequest 匹配到对应的 Servlet 的请求响应，将请求传递到对应的 Engine 容器中调用 Pipeline，管道中包含若干个 Valve，执行完所有的 Valve 最后执行 StandardEngineValve，继续调用 Host 容器的 Pipeline，执行 Host 的 Valve，再传递给 Context 的 Pipeline，最后传递到 Wrapper 容器</li><li><code>StandardWrapperValve#invoke</code> 中创建了 Servlet 对象并执行初始化，并为当前请求准备一个 FilterChain 过滤器链执行 doFilter 方法，<code>ApplicationFilterChain#doFilter</code> 是一个<strong>责任链的驱动方法</strong>，通过调用 internalDoFilter 来获取过滤器链的下一个过滤器执行 doFilter，执行完所有的过滤器后执行 <code>servlet.service</code> 的方法</li><li>最后调用 HttpServlet#service()，根据请求的方法来调用 doGet、doPost 等，执行到自定义的业务方法</li></ol><blockquote><p>参考文章：<a href="https://www.jianshu.com/p/7c9401b85704">https://www.jianshu.com/p/7c9401b85704</a></p><p>参考文章：<a href="https://www.yuque.com/yinhuidong/yu877c/ktq82e">https://www.yuque.com/yinhuidong/yu877c/ktq82e</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVAWebing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVAWeb </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-位运算</title>
      <link href="/posts/24462c33.html"/>
      <url>/posts/24462c33.html</url>
      
        <content type="html"><![CDATA[<h1>位运算</h1><h2 id="原理">原理</h2><p>以下<code>0s 表示一串 0，1s 表示一串 1。</code></p><p>x ^ 1s = ~x</p><blockquote><p>将一个数的位级表示翻转</p></blockquote><p>x ^ x = 0</p><blockquote><p>将三个数中重复的两个数去除，只留下另一个数。</p></blockquote><p>x &amp; 0s = 0 和 x &amp; 1s = x</p><blockquote><p>实现掩码操作</p></blockquote><p>x | 0s = x 和 x | 1s = 1s</p><blockquote><p>设值操作</p></blockquote><p>n &amp; (n-1)和n-(n &amp; (-n))</p><blockquote><p>去除 n 的位级表示中最低的那一位 1</p></blockquote><p>n &amp; (-n)</p><blockquote><p>得到 n 的位级表示中最低的那一位 1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-约瑟夫环</title>
      <link href="/posts/a1b6ced6.html"/>
      <url>/posts/a1b6ced6.html</url>
      
        <content type="html"><![CDATA[<h1>约瑟夫环</h1><h2 id="介绍">介绍</h2><p>约瑟夫环（Josephus Problem）是一个理论计算机科学中的经典问题，也是一个著名的数学游戏问题。故事背景多种多样，但基本情节大致如下：有一群人围成一个圈，从某个人开始报数，每次数到特定数值（比如说是m）的人会被排除出圈，然后从下一个人继续开始报数，直到只剩下最后一个人为止，这个人就是游戏的胜利者。</p><p>解决约瑟夫环问题可以用递归、迭代或者数学公式等多种方法。</p><blockquote><p>题目：</p><p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">孩子们的游戏</a></p></blockquote><h2 id="递归法">递归法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> function(n - <span class="number">1</span>, m);</span><br><span class="line">        <span class="comment">//返回最后删除的那个元素</span></span><br><span class="line">        <span class="keyword">return</span> (m + x) % n; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">//没有小朋友的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> function(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简洁</p><p>缺点：会出现栈溢出</p><blockquote><p>递归法解析：</p><p><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solutions/607638/jian-zhi-offer-62-yuan-quan-zhong-zui-ho-dcow/">LCR 187. 破冰游戏 - 力扣（LeetCode）</a></p></blockquote><h2 id="迭代法">迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">//没有小朋友的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从小到大，更新x</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            x = (m + x) % i;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：效率高</p><p>缺点：有难度</p><blockquote><p>迭代法解析：</p><p><a href="https://blog.csdn.net/u011500062/article/details/72855826">https://blog.csdn.net/u011500062/article/details/72855826</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 约瑟夫环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W-vue声明周期</title>
      <link href="/posts/8d8d45c8.html"/>
      <url>/posts/8d8d45c8.html</url>
      
        <content type="html"><![CDATA[<h1>背景</h1><p>​父组件在Mounted()中存放的授权信息，在子组件的Mounted()获取不到。</p><h1>方案</h1><p>父子组件生命周期执行顺序</p><blockquote><p>父组件：beforeCreate</p><p>父组件：created</p><p>父组件：beforeMount</p><p>子组件：beforeCreate</p><p>子组件：createc</p><p>子组件：beforeMount</p><p><strong>子组件：mounted</strong></p><p><strong>父组件：mounted</strong></p></blockquote><p>子组件 <code>mounted</code> 之后父组件 <code>mounted</code></p><p>所以把业务代码放在父组件的<code>beforeMount</code>中</p>]]></content>
      
      
      <categories>
          
          <category> 工作inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-17知识产权和标准化</title>
      <link href="/posts/ce64c746.html"/>
      <url>/posts/ce64c746.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>知识产权概述</li><li>保护期限</li><li>知识产权人的确定</li><li>侵权判定</li><li>标准划分</li></ul><h1>中论</h1><h2 id="知识产权概述">知识产权概述</h2><p>知识产权是指公民、法人、非法人单位对自己的创造性智力成果和其他科技 成果依法享有的民事权。是智力成果的创造人依法享有的权利和在生产经营活 动中标记所有人依法所享有的权利的总称。包含著作权、专利权、商标权、商 商业秘密权、植物新品种权、集成电路布图设计权和地理标志权等。</p><blockquote><p>无体性：知识产权的对象是没有具体形体，是智力创造成果，是一种抽象的 财富。</p><p>专有性：指除权利人同意或法律规定外，权利人以外的任何人不得享有或使 用该项权利。</p><p>地域性：指知识产权只在授予其权利的国家或确认其权利的国家产生，并且 只能在该范围内受法律保护，而其他国家则不受保护。</p><p>时间性：仅在法律规定的期限内受到保护，一旦超过期限，权利自行消灭， 相关知识产品即成为整个社会的共同财富，为全人类所共同使用。</p></blockquote><h2 id="保护期限">保护期限</h2><p>知识产权具有地域限制，保护期限各种情况：</p><p><img src="../image/post/image-20240610171514964.png" alt="image-20240610171514964"></p><h2 id="知识产权人的确定">知识产权人的确定</h2><p>（1）职务作品</p><p><img src="../image/post/image-20240610171538564.png" alt="image-20240610171538564"></p><p>（2）委托作品</p><p>单位和委托的区别在于，当合同中未规定著作权的归属时，著作权默认归于单位，而委托创作中，著作权默认归属于创作方个人。</p><p><img src="../image/post/image-20240610171554480.png" alt="image-20240610171554480"></p><h2 id="侵权判定">侵权判定</h2><p>中国公民、法人或者其他组织的作品，不论是否发表，都享有著作权。 开发软件所用的思想、处理过程、操作方法或者数学概念不受保护。</p><blockquote><p>著作权法不适用于下列情形：</p><p>法律、法规、国家机关的决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方正式译文；时事新闻；历法、通用数表、通用表格和公式。</p></blockquote><p><img src="../image/post/image-20240610171812233.png" alt="image-20240610171812233"></p><h2 id="标准划分">标准划分</h2><p>根据标准制定机构和适用范围的不同，可分为国际标准、国家标准、行业标准、区域/地方标准和企业标准</p><p>（1）国际标准：是指国际标准化组织（ISO）、国际电工委员会（IEC）和国际电信联盟（ITU）制定的标准，以及国际标准化组织确认并公布的其他国际组织制定的标准。国际标准在世界范围内统一使用，提供各国参考。</p><p>（2）国家标准：是指由国家标准化主管机构制定或批准发布，在全国范围内统一适用的标准。比如：GB—中华人民共和国国家标准；强制性国家标准代号为GB，推荐性国家标准代号为GB/T，国家标准指导性文件代号为GB/Z，国军标代号为GJB。ANSI（American National Standards Institute）–美国国家标准协会标准；</p><p>（3）行业标准：是由某个行业机构、团体等制定的，适用于某个特定行业业务领域的标准。比如：IEEE–美国电气电子工程师学会标准；GA–公共安全标准；YD–通信行业标准；</p><p>（4）区域/地方标准：是由某一区域/地方内的标准化主管机构制定、批准发布的，适用于某个特定区域/地方的标准。比如：EN—欧洲标准；</p><p>（5）企业标准：是企业范围内根据需要协调、统一的技术要求、管理要求和工作要求所制定的标准，适用于本企业内部的标准。一般以Q字开头，比如Q/320101 RER 007–2012，其中320101代表地区，RER代表企业名称代号，001代表该企业该标准的序号，2012代表年号。</p><h1>后记</h1><blockquote><p>莫道桑榆晚，为霞尚满天。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-16未来信息综合技术</title>
      <link href="/posts/9b1fc7fd.html"/>
      <url>/posts/9b1fc7fd.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>信息物理系统</li><li>人工智能</li><li>机器人</li><li>边缘计算</li><li>数字孪生体</li><li>云计算</li><li>大数据</li></ul><h1>中论</h1><h2 id="信息物理系统">信息物理系统</h2><blockquote><p>信息物理系统（CPS）是控制系统、嵌入式系统的扩展与延伸，其涉及的相关底层理论技术源于对嵌入式技术的应用与提升。</p><p>CPS通过集成先进的感知、计算、通信、控制等信息技术和自动控制技术，构建了物理空间与信息空间中人、机、物、环境、信息等因素相互映射、适时交互、高效协同的复杂系统，实现系统内资源配置和运行的按需响应、快速迭代、动态优化。</p><p>CPS的本质就是构建一套信息空间与物理空间之间基于数据自动流动的状态感知、实时分析、科学决策、精准执行的闭环赋能体系，解决生产制造、应用服务过程中的复杂性和不确定性问题，提高资源配置效率，实现资源优化。</p></blockquote><p>CPS体系架构：</p><ol><li>单元级CPS。具有不可分割性的CPS最小单元，具备可感知、可计算、可交互、可延展、自决策功能的CPS最小单元，一个智能部件、一个工业机器人或一个智能机床都可能是一个CPS最小单元。</li><li>系统级CPS。多个最小单元（单元级）通过工业网络（如工业现场总线、工业以太网等），实现更大范围、更宽领域的数据自动流动，实现了多个单元级CPS的互联、互通和互操作，进一步提高制造资源优化配置的广度、深度和精度。包含互联互通、即插即用、边缘网关、数据互操作、协同控制、监视与诊断等功能。其中与连互联互通、边缘网关和数据互操作主要实现单元级CPS的异构集；即插即用主要在系统级CPS实现组件管理，包括组（单元级CPS）的识别，配置，更新和删除等功能：协同控制是指对多个单元级CPS的联动和协同控制等；监视与诊断主要是对单元级CPS的状态实时监控和诊断其是否具备应有的能力。</li><li>SoS级。多个系统级CPS 的有机组合构成SoS 级CPS 。例如，多个工序（系统的CPS ）形成一 个车间级的CPS 或者形成整个工厂的CPS。主要实现数据的汇聚，从而对内进行资产的优化和对外 形成运营优化服务。其主要功能包括：数据存储、数据融合、分布式计算、大数据分析、数据服 务，并在数据服务的基础上形成了资产性能管理和运营优化服务。</li></ol><hr><p>CPS技术体系：</p><p>CPS 技术体系主要分为CPS 总体技术、CPS 支撑技术、CPS 核心技术。</p><ul><li><p>CPS 总体技术主要包括系统架构、异构系统集成、安全技术、试验验证技术等，是CPS 的顶层设计 技术；</p></li><li><p>CPS 支撑技术主要包括智能感知、嵌入式软件、数据库、人机交互、中间件、SDN （软件定义 网络）、物联网、大数据等，是基于CPS 应用的支撑；</p></li><li><p>CPS 核心技术主要包括虚实融合控制、智能装备、MBD 、数字孪生技术、现场总线、工业以太网、CAX\MES\ERP\PLM\CRM\SCM 等，是CPS 的基础技术。</p></li></ul><blockquote><p>上述技术体系可以分为四大核心技术要素即 “一硬” （感知和自动控制）、“一软” （工业软 件）、“一网” （工业网络）、“一平台” （工业云和智能服务平台）。其中感知和自动控制是 CPS 实现的硬件支撑；工业软件固化了CPS 计算和数据流程的规则，是CPS的核心；工业网络是 互联互通和数据传输的网络载体；工业云和智能服务平台是CPS 数据汇聚和支撑上层解决方案的基础 ，对外提供资源管控和服务能力。</p></blockquote><hr><p>CPS典型应用场景：</p><p>（1）智能设计。在产品及工艺设计、工厂设计过程中的大部分工作都可以在虚拟空间中进行仿真，并实现迭代和改进。包括产品及工艺设计、生产线/工厂设计。</p><p>（2）智能生产。CPS 可以打破生产过程的信息孤岛现象，实现设备的互联互通，实现生产过程监控，合理管理调度各种生产资源，优化生产计划，达到资源和制造协同，实现“制造”到“智造”的升级。包块设备管理、生产管理、柔性制造。</p><p>（3）智能服务。通过 CPS 按照需要形成本地与远程云服务相互协作、个体与群体、群体与系统的相互协同一体化工业云服务体系，能够更好地服务于生产，解决装备运行日益复杂、使用难度日益增大的困扰，实现智能装备的协同优化，支持企业用户经济性、安全性和高效性经营目标落地。包括健康管理、智能维护、远程征兆性诊断、协同优化、共享服务。</p><p>（4）智能应用。将设计者、生产者和使用者的单调角色转变为新价值创造的参与者，并通过新型价值链的创建反馈到产业链的转型，从根本上调动各个参与者的积极性，实现制造业转型。包括无人装备、产业链互动、价值链共赢。</p><p>CPS建设路径：CPS体系设计、单元级CPS 建设、系统级CPS建设和SoS级CPS建设阶段。</p><hr><h2 id="人工智能">人工智能</h2><p>人工智能（AI）是利用数字计算机或者数字计算机控制的机器模拟、延伸和扩展人的智能，感知环境、获取知识并使用知识获得最佳结果的理论、方法、技术及应用系统。</p><p>人工智能的目标是了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器。该领域的研究包括机器人、自然语言处理、计算机视觉和专家系统等。</p><p>根据人工智能是否能真正实现推理、思考和解决问题，可以将人工智能分为弱人工智能和强人工智能。</p><p>人工智能关键技术</p><ol><li>自然语言处理（NLP）。研究实现人与计算机之间用自然语言进行有效通信的各种理论和方法。主要包括机器翻译（从一种自然语言到另外一种自然语言的翻译）、语义理解（利用计算机理解文本篇章内容，并回答相关问题）和问答系统（让计算机像人类一样用自然语言与人交流）等。</li><li>计算机视觉。是使用计算机模仿人类视觉系统的科学，让计算机拥有类似人类提取、处理、理解和分析图像以及图像序列的能力，将图像分析任务分解为便于管理的小块任务。</li><li>知识图谱。就是把所有不同种类的信息连接在一起而得到的一个关系网络，提供了从“关系”的角度去分析问题的能力。一般用于反欺诈、不一致性验证等问题。</li><li>人机交互（HCI）。主要研究人和计算机之间的信息交换。</li><li>虚拟现实或增强现实（VR/AR）。以计算机为核心的新型视听技术。结合相关科学技术，在一定范围内生成与真实环境在视觉、听觉等方面高度近似的数字化环境</li><li>机器学习（ML）。是以数据为基础，通过研究样本数据寻找规律，并根据所得规律对未来数据进行预测。目前，机器学习广泛应用于数据挖掘、计算机视觉、自然语言处理、生物特征识别等领域。</li></ol><p><strong>机器学习分类</strong></p><p>按照学习模式的不同，机器学习可分为监督学习、无监督学习、半监督学习、强化学习。其中，监督学习需要提供标注的样本集，无监督学习不需要提供标注的样本集，半监督学习需要提供少量标注的样本，而强化学习需要反馈机制。</p><blockquote><p>监督学习是利用已标记的有限训练数据集，通过某种学习策略 / 方法建立一个模型，从而实现对新数据 / 实例的标记 (分类) / 映射。在自然语言处理、信息检索、文本挖掘、于写体辨识、垃圾邮件侦测等领域获得了广泛应用。</p><p>无监督学习是利用无标记的有限数据描述隐藏在未标记数据中的结构 / 规律。无监督学习不需要以人工标记数据作为训练样本，这样不仅便于压缩数据存储、减少计算量、提升算法速度，还可以避免正负样本偏移引起的分类错误问题。无监督学习主要用于经济预测、异常检测、数据挖掘、图像处理、模式识别等领域。</p><p>半监督学习可以利用少量的标注样本和大量的末标识样本进行训练和分类，从而达到减少标注代价、提高学习能力的目的。半监督学习的算法首先试图对未标识数据进行建模，在此基础上再对标记的数据进行预测。例如，图论推理算法或者拉普拉斯支持向量机等。</p><p>强化学习可以学习从环境状态到行为的映射，使得智能体选择的行为能够获得环境的最大奖赏，最终目标使外部环境对学习系统在某种程度上的评价最佳。在机器人控制、无人驾驶、工业控制等领域获得成功应用。</p></blockquote><p>按照学习方法的不同，机器学习可分传统机器学习和深度学习。区别在于，传统机器学习的领域特征需要手动完成，且需要大量领域专业知识；深度学习不需要人工特征提取，但需要大量的训练数据集以及强大的GPU服务器来提供算力。</p><blockquote><p>传统机器学习从一些观测（训练）样本出发，试图发现不能通过原理分析获得的规律，实现对未来的数据行为或趋势的准确预测。在自然语言处理、语音识别、图像识别、信息检索等许多计算机领域获得了广泛应用。</p><p>深度学习是一种基于多层神经网络并以海量数据作为输入规则的自学习方法，依靠提供给它的大量实际行为数据（训练数据集），进行参数和规则调整。深度学习更注重特征学习的重要性。</p></blockquote><p>机器学习的常见算法还包括迁移学习、主动学习和演化学习。</p><blockquote><p>迁移学习是指当在某些领域无法取得足够多的数据进行模型训练时，利用另一领域数据获得的关系进行的学习。主要在变量有限的小规模应用中使用，如基于传感器网络的定位、文字分类和图像分类等。</p><p>主动学习通过一定的算法查询最有用的未标记样本，并交由专家进行标记，然后用查询到的样本训练分类模型来提高模型的精度。</p><p>演化学习基于演化算法提供的优化工具设计机器学习算法，针对机器学习任务中存在的复杂优化问题，应用于分类、聚类、规则发现、特征选择等机器学习与数据挖掘问题中。算法通常维护一个解的集合，并通过启发式算子来从现有的解产生新解，并通过挑选更好的解进入下一次循环，不断提高解的质量。</p><p>人工智能目前典型应用：chatgpt</p></blockquote><h2 id="机器人">机器人</h2><p>机器人技术已经准备进入4.0时代。所谓机器人4.0时代，就是把云端大脑分布在各个地方，充分利用边缘计算的优势，提供高性价比的服务，把要完成任务的记忆场景的知识和常识很好地组合起来，实现规模化部署。特别强调机器人除了具有感知能力实现智能协作，还应该具有一定的理解和决策能力，进行更加自主的服务。</p><p>我们目前的服务机器人大多可以做到物体识别和人脸识别。在机器人4.0时代，我们需要加上更强的自适应能力。</p><p><strong>机器人4.0的核心技术</strong></p><p>1.云-边-端的无缝协同计算。云-边-端一体的机器人系统是面向大规模机器人的服务平台，信息处理和生成主要在云-边-端上分布处理完成。通常情况下，云侧可以提供高性能的计算和知识存储，边缘侧用来进一步处理数据并实现协同和共享。机器人端只用完成实时操作的功能。</p><p>2.持续学习与协同学习。希望机器人可以通过少量数据来建立基本的识别能力，然后可以自主地去找更多的相关数据并进行自动标注。然后用这些自主得到的数据来对自己已有的模型进行重新训练来提高性能。</p><p>3.知识图谱。需要更加动态和个性化的知识；需要和机器人的感知与决策能力相结合。</p><p>4.场景自适应。主动观察场景内人和物的变化，预测可能发生的事件，从而影响之后的行为模式。这个技术的关键问题在于场景预测能力。就是机器人通过对场景内的各种人和物进行细致的观察，结合相关的知识和模型进行分析，并预测之后事件即将发生的时间，改变自己的行为模式。</p><p>5.数据安全。既要保证端到端的安全传输，也要保障服务器端的安全存储。</p><p><strong>分类</strong></p><p>如果按照要求的控制方式分类，机器人可分为操作机器人、程序机器人、示教再现机器人、智能机器人和综合机器人。</p><blockquote><ol><li>操作机器人。典型代表是在核电站处理放射性物质时远距离进行操作的机器人。</li><li>程序机器人。可以按预先给定的程序、条件、位置进行作业。</li><li>示教再现机器人。机器人可以将所教的操作过程自动地记录在磁盘、磁带等存储器中，当需要再现操作时，可重复所教过的动作过程。示教方法有直接示教与遥控示教两种。</li><li>智能机器人。既可以进行预先设定的动作，还可以按照工作环境的改变而变换动作。</li><li>综合机器人。由操纵机器人、示教再现机器人、智能机器人组合而成的机器人，如火星星机器人。整个系统可以看作是由地面指令操纵的操作机器人。</li></ol></blockquote><p>如果按照应用行业来分，机器人可分为工业机器人、服务机器人和特殊领域机器人。</p><h2 id="边缘计算">边缘计算</h2><p>边缘计算将数据的处理、应用程序的运行甚至一些功能服务的实现，由网络中心下放到网络边缘的节点上。在网络边缘侧的智能网关上就近采集并且处理数据，不需要将大量未处理的原生数据上传到远处的大数据平台。</p><p>采用边缘计算的方式，海量数据能够就近处理，大量的设备也能实现高效协同的工作，诸多问题迎刃而解。因此，边缘计算理论上可满足许多行业在敏捷性、实时性、数据优化、应用智能，以及安全与隐私保护等方面的关键需求。</p><p>边缘计算的业务本质是云计算在数据中心之外汇聚节点的延伸和演进，主要包括云边缘、边缘云和云化网关三类落地形态；以“边云协同”和“边缘智能”为核心能力发展方向；软件平台需要考虑导入云理念、云架构、云技术，提供端到端实时、协同式智能、可信赖、可动态重置等功能；硬件平台需要考虑异构计算能力。</p><blockquote><p>（1）云边缘：是云服务在边缘侧的延伸，逻辑上仍是云服务，主要的能力提供依赖于云服务或需要与云服务紧密协同。</p><p>（2）边缘云：是在边缘侧构建中小规模云服务能力，边缘服务能力主要由边缘云提供。</p><p>（3）云化网关：以云化技术与能力重构原有嵌入式网关系系统，云化网关在边缘侧提供协议／接口转换、边缘计算等能力，部署在云侧的控制器提供边缘节点的资源调度、应用管理与业务编排等能力。</p></blockquote><p><strong>边缘计算具有以下特点：</strong></p><p>（1）联接性：联接性是边缘计算的基础。所联接物理对象的多样性及应用场景的多样性，需要边缘计算具备丰富的联接功能。</p><p>（2）数据第一入口：边缘计算作为物理世界到数字世界的桥梁，是数据的第一入口，拥有大量、实时、完整的数据，可基于数据全生命周期进行管理与价值创造，将更好的支撑预测性维护、资产效率与管理等创新应用。</p><p>（3）约束性：边缘计算产品需适配工业现场相对恶劣的工作条件与运行环境，如防电磁、防尘、防爆、抗振动、抗电流／电压波动等。在工业互联系统下，对边缘计算设备的功耗、成本、空间也有较高的要求。</p><p>（4）分布性：边缘计算实际部署天然具备分布式特征。这要求边缘计算支持分布式计算与存储、实现分布式资源的动态调度与统一管理、支撑分布式智能、具备分布式安全等能力。</p><p>边云协同：边缘计算与云计算各有所长，云计算擅长全局性、非实时、长周期的大数据处理与分析，能够在长周期维护、业务决策支撑等领域发挥优势；边缘计算更适用局部性、实时、短周期数据的处理与分析，能更好地支撑本地业务的实时智能化决策与执行。</p><p>边缘计算既靠近执行单元，更是云端所需高价值数据的采集和初步处理单元，可以更好地支撑云端应用：反之，云计算通过大数据分析优化输出的业务规则或模型可以下发到边缘侧，边缘计算基于新的业务规则或模型运行。</p><p>主要包括六种协同：</p><p>（1）资源协同：边缘节点提供计算、存储、网络、虚拟化等基础设施资源、具有本地资源调度管理能力，同时可与云端协同，接受并执行云端资源调度管理策略，包括边缘节点的设备管理、资源管理以及网络连接管理。</p><p>（2）数据协同：边缘节点主要负责现场/终端数据的采集，按照规则或数据模型对数据进行初步处理与分析，并将处理结果以及相关数据上传给云端：云端提供海量数据的存储、分析与价值挖掘。</p><p>（3）智能协同：边缘节点按照AI模型执行推理，实现分布式智能；云端开展AI的集中式模型训练，并将模型下发边缘节点。</p><p>（4）应用管理协同：边缘节点提供应用部署与运行环境，并对本节点多个应用的生命周期进行管理调度：云端主要提供应用开发、测试环境，以及应用的生命周期管理能力。</p><p>（5）业务管理协同：边缘节点提供模块化、微服务化的应用/数字孪生/网络等应用实例：云端主要提供按照客户需求实现应用/数字孪生/网络等的业务编排能力。</p><p>（6）服务协同：边缘节点按照云端策略实现部分ECsaaS服务，通过ECsaaS与云端SaaS的协同实现面向客户的按需SaaS服务：云端主要提供SaaS服务在云端和边缘节点的服务分布策略，以及云端承担的SaaS服务能力。</p><p>边缘计算的应用场合：智慧园区、安卓云与云游戏、视频监控、工业互联网、Cloud VR。</p><h2 id="数字孪生体">数字孪生体</h2><p>数字孪生体技术是跨层级、跨尺度的现实世界和虚拟世界建立沟通的桥梁。</p><p>数字孪生体是现有或将有的物理实体对象的数字模型，通过实测、仿真和数据分析来实时感知、诊断、预物理实体对象的状态，通过优化和指令来调控物理实体对象的行为，通过相关数字模型间的相互学习来进化自身，同时改进利益相关方在物理实体对象生命周期内的决策。</p><p>关键技术</p><p>1.建模。建模的目的是将我们对物理世界的理解进行简化和模型化。而数字孪生体的目的或本质是通过数字化和模型化，用信息换能量，以使少的能量消除各种物理实体、特别是复杂系统的不确定性。需求指标、生存阶段和空间尺度构成了数字孪生体建模技术体系的三维空间。</p><p>2.仿真。如果说建模是模型化我们对物理世界或问题的理解，那么仿真就是验证和确认这种理解的正确性和有效性。所以，数字化模型的仿真技术是创建和运行数字孪生体、保证数字孪生体与对应物理实体实现有效闭环的核心技术。</p><p>仿真是一种将包含了确定性规律和完整机理的模型转化成软件的方式来模拟物理世界的一种技术。只要模型正确，并拥有了完整的输入信息和环境数据，就可以基本准确地反映物理世界的特性和参数。</p><p>3.其他技术。VR、AR以及MR等增强现实技术、数字线程、系统工程和MBSE、物联网、云计算、雾计算、边缘计算、大数据技术、机器学习和区块链技术。</p><p>数字孪生体主要应用于制造、产业、城市和战场。</p><h2 id="云计算">云计算</h2><p>云计算概念的内涵包含两个方面：平台和应用。平台即基础设施，其地位相当于PC上的操作系统，云计算应用程序需要构建在平台之上；云计算应用所需的计算与存储通常在“云端”完成，客户端需要通过互联网访问计算与存储能力。</p><p><strong>云计算的服务方式</strong></p><ol><li>软件即服务(SaaS)。在SaaS的服务模式下，服务提供商将应用软件统一部署在云计算平台上，客户根据需要通过互联网向服务提供商订购应用软件服务，服务提供商根据客户所订购软件的数量、时间的长短等因素收费，并且通过标准浏览器向客户提供应用服务。</li><li>平台即服务(PaaS)。在PaaS模式下，服务提供商将分布式开发环境与平台作为一种服务来提供。这是一种分布式平台服务，厂商提供开发环境、服务器平台、硬件资源等服务给客户，客户在服务提供商平台的基础上定制开发自己的应用程序，并通过其服务器和互联网传递给其他客户。</li><li>基础设施即服务(Iaas)。在Iaas模式下，服务提供商将多台服务器组成的“云端”基础设施作为计量服务提供给客户。具体来说，服务提供商将内存、I/O设备、存储和计算能力等整合为一个虚拟的资源池，为客户提供建议的存储资源、虚拟化服务器等服务。</li></ol><blockquote><p>在灵活性方面， SaaS-&gt; PaaS -&gt; Iaas 灵活性依次增强。</p><p>在方便性方面， Iaas -&gt; PaaS -&gt; SaaS 方便性依次增强。</p></blockquote><p><strong>云计算的部署模式</strong></p><ol><li>公有云。在公有云模式下，云基础设施是公开的，可以自由地分配给公众。企业、学术界与政府机构都可以拥有和管理公用云，并实现对公有云的操作。公有云能够以低廉的价格为最终用户提供有吸引力的服务，创造新的业务价值。</li><li>社区云。在社区云模式下，云基础设施分配给一些社区组织所专有，这些组织共同关注任务、安全需求、政策等信息。云基础设施被社区内的一个或多个组织所拥有、管理及操作。“社区云”是“公有云”范畴内的一个组成部分。</li><li>私有云。在私有云模式下，云基础服务设施分配给由多种用户组成的单个组织。它可以被这个组织或其他第三方组织所拥有、管理及操作。</li><li>混合云。混合云是公有云、私有云和社区云的组合。由于安全和控制原因，并非所有企业信息都能放置在公有云上，因此企业将会使用混合云模式。</li></ol><h2 id="大数据">大数据</h2><p>大数据是指其大小或复杂性无法通过现有常用的软件工具，在合理成本内对其进行捕获、管理和处理的数据集。这些困难包括数据的收入、存储、搜索、共享、分析和可视化。</p><p>大数据的特点：大规模、高速度、多样化、可变性、复杂性等。</p><p>大数据分析的分析步骤，大致分为数据获取 / 记录、信息抽取 / 清洗 / 注记、数据集成 / 聚集 / 表现、数据分析 / 建模和数据解释5个主要阶段。</p><p>大数据的应用领域：制造业、服务业、交通行业、医疗行业。</p><h1>后记</h1><blockquote><p>莫愁千里路，自有到来风。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W-线程隔离（普通用户、VIP用户）</title>
      <link href="/posts/efed3be7.html"/>
      <url>/posts/efed3be7.html</url>
      
        <content type="html"><![CDATA[<h1>需求背景</h1><p>一个非主要功能特殊时期的高并发问题。该场景用到了parallelStream并发流提高查询速度，但是Java8的并发流线程池默认是ForkJoinPool，是全局共享的，任何用到了并发流的业务操作默认都是一个线程池。</p><p>问题：所有parallelStream业务操作都使用一个线程池就有可能互相影响。比如帮助中心查询用户权限+内容过滤都用到了parallelStream，相当于这些操作都在一个池子里。在并发的时候就有可能互相影响。</p><p>特点：非主要功能且在特殊时间（平时不咋用、平时不会集中使用）</p><h1>解决方案</h1><p>特殊账号用户、普通用户在不同的线程池中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       list.parallelStream().forEach((i) -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + <span class="string">&quot;........XXX&quot;</span>);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Thread.sleep(<span class="number">500000L</span>);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testPrivate</span><span class="params">()</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           list.add(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">ForkJoinPool</span> <span class="variable">customThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">       customThreadPool.submit(</span><br><span class="line">               () -&gt; list.parallelStream().forEach((i) -&gt; &#123;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + <span class="string">&quot;........XXX&quot;</span>);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Thread.sleep(<span class="number">50000L</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;));</span><br><span class="line">       <span class="comment">// 自定义的ForkJoinPool不会使用主线程，所以需要主线程也sleep一下，方便查看控制台数据</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">500000L</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><hr><p>默认线程池输出：<img src="../image/post/image-20240610115344881.png" alt="image-20240610115344881"></p><p>自定义线程池输出：<img src="../image/post/image-20240610115356912.png" alt="image-20240610115356912"></p><hr><p>可以看到默认线程池是commonPool，自定义线程池是2，做到了同一个parallelStream线程池的隔离。</p><p><code>注意：parallelStream默认线程池主线程也参与工作，会看到main也会打印，但是自定义线程池则没有</code></p><h1>补充</h1><p>Java中的parallelStream：<a href="https://blog.csdn.net/qq_25775675/article/details/125687985">Java中的parallelStream</a></p><p>自定义parallelStream：<a href="https://developer.aliyun.com/article/898096">自定义parallelStream的threadpool -阿里云开发者社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>W-异步编排+消息队列+轮询</title>
      <link href="/posts/fb4ce95d.html"/>
      <url>/posts/fb4ce95d.html</url>
      
        <content type="html"><![CDATA[<h1>需求背景</h1><p>背景：业务需要对接中台的功能，实现根据excel文件 + 当前工程信息，得出该excel文件的相关特点，以供后续分析。</p><p>特点：高并发，中台并发量有限，需要业务端控制。</p><h1>解决方案</h1><p>采用异步编排+消息队列+轮询</p><h2 id="异步编排">异步编排</h2><blockquote><p>执行的功能主要分成三个步骤：</p><ol><li>解析excel文件，调用中台智能分析接口</li><li>进一步处理解析后的文件以及当前工程文件，处理成业务需要的形式</li><li>根据上述两步的结果，拼接返回新的结果给前端。</li></ol></blockquote><p>特点：步骤1，步骤2执行时不会相互影响，并且步骤3的结果依赖1, 2。</p><p>所以使用CompletableFuture异步编排，分别分配线程运行1 2。然后1 2 都运行完以后运行3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">代码示例：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务一</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1开始:  &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">4</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1运行结果:  &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务二</span></span><br><span class="line">CompletableFuture&lt;String&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2开始:  &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2执行结果:  &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*future01.runAfterBothAsync(future02,()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;任务3开始&quot;);</span></span><br><span class="line"><span class="comment">        &#125;,executor);*/</span>      <span class="comment">//不能获取前两者的返回值,不能更改返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* future01.thenAcceptBothAsync(future02,(f1,f2)-&gt;&#123;</span></span><br><span class="line"><span class="comment">            //void accept(T t, U u);</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;任务3开始...之前的结果:&quot;+f1 +&quot;---&gt;&quot;+f2);</span></span><br><span class="line"><span class="comment">        &#125;,executor);*/</span>      <span class="comment">//可以获取前两者的返回指,不能更改返回指</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*CompletableFuture&lt;String&gt; future = future01.thenCombineAsync(future02, (f1, f2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">            //R apply(T t, U u);</span></span><br><span class="line"><span class="comment">            return f1 + &quot;: &quot; + f2 + &quot;-&gt;HaHa&quot;;</span></span><br><span class="line"><span class="comment">        &#125;, executor);*/</span><span class="comment">//可以获取前两者的返回指,可以更改返回指</span></span><br><span class="line">System.out.println(<span class="string">&quot;结束.........&quot;</span>+future.get());</span><br></pre></td></tr></table></figure><h2 id="消息队列-轮询">消息队列 + 轮询</h2><blockquote><p>针对高并发场景，多个用户同一时间点击其功能，缓解中台的压力并且保证用户执行以后不会无效。</p><p>因为服务是集群的，所以如果用线程池，每个线程池只控制该服务器。比如线程池最大线程数10，如果集群机器数是10，发送给中台的请求可能到10*10=100条。</p></blockquote><p>消息队列：保证用户请求（消息）都能到中台，中台把解析结果存放在redis中，这边轮询查找。</p><h1>补充</h1><h2 id="AI相关概念：">AI相关概念：</h2><p>prompt：给AI的提示</p><p>Token：模型用来表示自然语言文本的基本单位，可以直观的理解为“字”或“词”；通常一个中文词语、一个英文单词、一个标点符号位一个Token。（任何大模型都有单次提问token的限制，所以题目和选项数不能太多，太多的话需要分批生成<code>不过该项目不涉及到这个问题，不是大模型问答</code>）</p>]]></content>
      
      
      <categories>
          
          <category> 工作inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 需求开发 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-15软件架构的演化和维护</title>
      <link href="/posts/e176a770.html"/>
      <url>/posts/e176a770.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>软件架构演化和定义</li><li>面向对象软件架构演化</li><li>软件架构演化方式的分类</li><li>软件架构演化原则</li><li>软件架构演化评估方法</li><li>大型网站架构演化（较重点）</li><li>软件架构维护</li></ul><h1>中论</h1><h2 id="软件架构演化和定义">软件架构演化和定义</h2><p>软件架构的演化和维护就是对架构进行修改和完善的过程，目的是为了使软件能够适应环境的变化而进行的纠错性修改和完善性修改等，是一个不断迭代的过程，直至满足用户需求。</p><p>本质讲，软件架构的演化就是软件整体结构的演化，演化过程涵盖软件架构的全生命周期，包括软件架构需求的获取、软件构架建模、软件架构文档、软件架构实现以及软件架构维护等阶段。</p><p>软件架构演化的的重要性体现在：一是架构是整个系统的骨架，是软件系统具备诸多好的特性的保障；二是软件架构作为软件蓝图为人们宏观管控软件系统的整体复杂性和变化性提供了一条有效途径。</p><p>软件架构的演化能降低软件演化的成本的原因：</p><p>（1）对系统的软件架构进行的形式化、可视化表示提高了软件的可构造性，便于软件演化。</p><p>（2）软件架构设计方案涵盖的整体结构信息、配置信息、约束信息等有助于开发人员充分考虑未来可能出现的演化问题、演化情况和演化环境。</p><p>（3）架构设计时对系统组件之间的耦合描述有助于软件系统的动态调整。</p><p>件架构的定义包含组件、连接件、约束三大要素，这类软件架构演化主要关注的就是这三者之间的添加、修改和删除等。</p><h2 id="面向对象软件架构演化">面向对象软件架构演化</h2><ul><li><p>对象演化：在顺序图中，组件的实体是对象，会对架构设计的动态行为产生影响的演化只包括AddObject (AO) 和DeleteObject (DO)两种。</p></li><li><p>AO 表示在顺序图中添加一个新的对象。这种演化一般是在系统需要添加新的对象来实现某种新的功能，或需要将现有对象的某个功能独立以增加架构灵活性的时候发生。</p></li><li><p>DO 删除顺序图中现有的一个对象。这种演化一般在系统需要移除某个现有的功能，或需要合并某些对象及其功能来降低架构的复杂度的时候发生。</p></li><li><p>消息演化：将消息演化分为AddMessage (AM)、DeleteMessage （DM）、SwapMessageOrder （SMO）、OverturnMessage（OM）、ChangeMessageModule（CMM）5种。</p></li><li><p>AM 增添一条新的消息，产生在对象之间需要增加新的交互行为的时候。DM 删除当前的一条消息，产生在需要移除某个交互行为的时候，是AM 的逆向演化。SMO 交换两条消息的时间顺序，发生在需要改变两个交互行为之间关系的时候。OM 反转消息的发送对象与接收对象，发生在需要修改某个交互行为本身的时候。CMM 改变消息的发送或接收对象，发生在需要修改某个交互行为本身的时候。</p></li><li><p>复合片段演化：复合片段是对象交互关系的控制流描述，表示可能发生在不同场合的交互，与消息同属于连接件范畴。复合片段的演化分为AddFragment（AF）、DeleteFragment（DF）、FragmentTypeChange（FTC）和FragmentConditionChange（FCC）。</p></li><li><p>FCC 改变复合片段内部执行的条件，发生在改变当前控制流的执行条件时。自动机中与控制流执行条件相对应的转移包括两个，一个是符合条件时的转移，另一个是不符合条件时的转移，因此每次发生FFC 演化时会同时修改这两个转移的触发事件。</p></li><li><p>AF 在某几条消息上新增复合片段，发生在需要增添新的控制流时。复合片段所产生的分支是不同类型。</p></li><li><p>DF 删除某个现有的复合片段，发生在需要移除当前某段控制流时。DF 与AF 互为逆向演化过程。</p></li><li><p>FTC 改变复合片段的类型，发生在需要改变某段控制流时。类型演化意味着交互流程的改变，一般伴随着条件、内部执行序列的同时演化，可以视为复合片段的删除与添加的组合。</p></li><li><p>约束演化：即直接对约束信息进行添加和删除。</p></li><li><p>AC（Add Constraint）直接添加新的约束信息，会对架构设计产生直接的影响，需要判断当前设计是否满足新添加的约束要求。</p></li><li><p>DC（Delete Constraint）直接移除某条约束信息，发生在去除某些不必要的时候，一般来说架构设计均会满足演化的约束。</p></li></ul><h2 id="软件架构演化方式的分类">软件架构演化方式的分类</h2><p>3种典型的分类方法；</p><p>（1）按照软件架构的实现方式和实施粒度分类：基于过程和函数的演化、面向对象的演化、基于组件的演化和基于架构的演化。</p><p>（2）按照研究方法将软件架构演化方式分为4类：</p><ul><li>第1类是对演化的支持，如代码模块化的准则、可维护性的指示（如内聚和耦合）、代码重构等；</li><li>第2类是版本和工程的管理工具；</li><li>第3类是架构变换的形式方法，包括系统结构和行为变换的模型，以及架构演化的重现风格等；</li><li>第4类是架构演化的成本收益分析，决定如何增加系统的弹性。</li></ul><p>（3）针对软件架构的演化过程是否处于系统运行时期，可以将软件架构演化分为静态演化和动态演化。</p><p>软件架构的演化时期包括：设计时演化、运行前演化、有限制运行时演化、运行时演化。</p><p>软件架构静态演化主要是在设计时演化以及运行前演化。与此对应的维护方法有3 类：更正性维护、适应性维护和完善性维护。</p><p>软件的静态演化一般包括如下5个步骤。</p><ul><li>软件理解：查阅软件文档，分析软件架构，识别系统组成元素及其之间的相互关系，提取系统的抽象表示形式。</li><li>需求变更分析：静态演化往往是由用户需求变化、系统运行出错和运行环境发生改等原因所引起的，需要找出新的软件需求与原有的差异。</li><li>演化计划：分析原系统，确定演化范围和成本，选择合适的演化计划。</li><li>系统重构：根据演化计划对系统进行重构，使之适应当前的需求。</li><li>系统测试：对演化后的系统进行测试，查找其中的错误和不足之处。</li></ul><hr><p>一次完整软件架构演化过程可以看作经过一系列原子演化操作组合而成。所谓原子演化操作是指基于UML 模型表示的软件架构，在逻辑语义上粒度最小的架构修改操作。每经过一次原子演化操作，架构会形成一个演化中间版本。</p><p>架构演化的可维护性度量基于组件图表示的软件架构，在较高层次上评估架构的某个原子修改操作对整个架构所产生的影响。这些原子修改操作包括增加 / 删除模块间的依赖、增加 / 删除模块间的接口、增加 / 删除模块、拆分 / 聚合模块等。</p><p>架构演化的可靠性评估基于用例图、部署图和顺序图，分析在架构模块的交互过程中某个原子演化操作对交互场景的可靠程度的影响。这些原子修改操作包括增加 / 删除消息、增加 / 删除交互对象、增加 / 删除 / 修改消息片段、增加 / 删除用例执行、增加 / 删除角色等。</p><p>动态演化是在系统运行期间的演化，需要在不停止系统功能的情况下完成演化，较之静态演化更加困难。具体发生在有限制的运行时演化和运行时演化阶段。</p><p>架构的动态演化主要来自两类需求：</p><ul><li>①软件内部执行所导致的体系结构改变，例如，许多服务器端软件会在客户请求到达时创建新的组件来响应客户需求；</li><li>②软件系统外部的请求对软件进行的重配置，例如，操作系统在升级时无须重新启动，在运行过程中就完成对体系结构的修改。</li></ul><p>软件的动态性分为3个级别：</p><ul><li>①交互动态性，要求数据在固定的结构下动态交互；</li><li>②结构动态性，允许对结构进行修改，通常的形式是组件和连接件实例的添加和删除，这种动态性是研究和应用的主流；</li><li>③架构动态性，允许软件架构的基本构造的变动，即结构可以被重定义，如新的组件类型的定义。</li></ul><p>根据所修改的内容不同，软件的动态演化主要包括以下4个方面。</p><ul><li>属性改名：目前所有的ADL都支持对非功能属性的分析和规约，而在运行过程中，用户可能会对这些指标进行重新定义（如服务响应时间）。</li><li>行为变化：在运行过程中，用户需求变化或系统自身服务质量的调节都将引发软件行为的变化。</li><li>拓扑结构改变：如增删组件，增删连接件，改变组件与连接件之间的关联关系等。</li><li>风格变化：一般软件演化后其架构风格应当保持不变，如果非要改变软件的架构风格，也只会将架构风格变为其衍生风格，如两层C/S到三层C/S。</li></ul><p>目前，实现软件架构动态演化的技术主要有两种：采用动态软件架构（DSA）和进行动态重配置（DR）。</p><ul><li>DSA 是指在运行时刻会发生变化的系统框架结构，允许在运行过程中通过框架结构的动态演化实现对架构的修改；</li><li>DR 从组件和连接件的配置入手，允许在运行过程中增删组件，增删连接件，修改连接关系等操作。</li></ul><p>实现软件架构动态演化的基本原理是使DSA 在可运行应用系统中以一类有状态、有行为、可操作的实体显式地表示出来，并且被整个运行环境共享，作为整个系统运行的依据。也就是说，运行时刻体系结构相关信息的改变可用来触发、驱动系统自身的动态调整。</p><p>系统必须提供SA动态演化的一些相关功能：保存当前软件架构信息的功能、设置监控机制监视系统有无需求变化、保证演化操作原子性。</p><p>DSA 实施动态演化大体遵循以下4 步：</p><ul><li>①捕捉并分析需求变化；</li><li>②获取或生成体系结构演化策略；</li><li>③根据步骤2 得到的演化策略，选择适当的演化策略并实施演化；</li><li>④演化后的评估与检测。</li></ul><p>基于软件动态重配置的软件架构动态演化主要是指在软件部署之后对配置信息的修改，常常用于系统动态升级时需要进行的配置信息修改。一般来说，动态重配置可能涉及的修改有：</p><ul><li>①简单任务的相关实现修改；</li><li>②工作流实例任务的添加和删除；</li><li>③组合任务流程中的个体修改；</li><li>④任务输入来源的添加和删除；</li><li>⑤任务输入来源的优先级修改；</li><li>⑥组合任务输出目标的添加和删除；</li><li>⑦组合任务输出目标的优先级修改等。</li></ul><p>动态重配置模式：主从模式、中央控制模式、客户端/服务器模式、分布式控制模式。</p><h2 id="软件架构演化原则">软件架构演化原则</h2><ol><li>演化成本控制原则</li><li>进度可控原则</li><li>风险可控原则</li><li>主体维持原则：保证软件系统主体行为稳定。</li><li>系统总体结构优化原则</li><li>平滑演化原则：演化速率趋于稳定。</li><li>目标一致原则</li><li>模块独立演化原则</li><li>影响可控原则</li><li>复杂性可控原则</li><li>有利于重构原则</li><li>有利于重用原则</li><li>设计原则遵从性原则：判断架构设计原则是否被破坏。</li><li>适应新技术原则</li><li>环境适应性原则</li><li>标准依从性原则</li><li>质量向好原则</li><li>适应新需求原则</li></ol><h2 id="软件架构演化评估方法">软件架构演化评估方法</h2><p>根据演化过程是否已知可将评估过程分为：演化过程已知的评估和演化过程未知的评估。</p><p>演化过程已知的评估其目的在于通过对架构演化过程进行度量，比较架构内部结构上的差异以及由此导致的外部质量属性上的变化，对该演化过程中相关质量属性进行评估。</p><p>架构演化评估的执行过程如图所示。图中A0和An表示一次完整演化前后的相邻版本的软件架构。每经过一次原子演化，即可得到一个架构中间演化版本Ai。对每个中间版本架构进行度量，得到架 构Ai的质量属性度量值Qi。D(i－1，i)是版本间的质量属性距离。</p><p><img src="../image/post/image-20240606210139087.png" alt="image-20240606210139087"></p><p>基于度量的架构演化评估方法，其基本思 路在于通过对演化前后的软件架构进行度量，比较架构内部结构上的差异以及由此导致的 外部质量属性上的变化。具体包括：架构修 改影响分析、监控演化过程、分析关键演化 过程。</p><p>当演化过程未知时，我们无法像演化过程 已知时那样追踪架构在演化过程中的每一步 变化，只能根据架构演化前后的度量结果逆 向推测出架构发生了哪些改变，并分析这些 改变与架构相关质量属性的关联关系。</p><p><img src="../image/post/image-20240606210221450.png" alt="image-20240606210221450"></p><h2 id="大型网站架构演化（较重点）">大型网站架构演化（较重点）</h2><p>第一阶段：单体架构。主要解决大数据和高并发的问题</p><p>第二阶段：垂直架构</p><p><img src="../image/post/image-20240606210255816.png" alt="image-20240606210255816"></p><p>第三阶段：使用缓存改善网站性能</p><p>第四阶段：使用服务集群改善网站并发处理能力</p><p>第五阶段：数据库读写分离</p><p>第六阶段：使用反向代理和CDN加速网站响应</p><p>第七阶段：使用分布式文件系统和分布式数据库系统</p><p>第八阶段：使用NoSQL和搜索引擎</p><p>第九阶段：业务拆分</p><p>第十阶段：分布式服务</p><p><img src="../image/post/image-20240606210448111.png" alt="image-20240606210448111"></p><h2 id="软件架构维护">软件架构维护</h2><p>软件架构维护过程一般涉及架构知识管理、架构修改管理和架构版本管理。</p><p>软件架构知识管理是对架构设计中所隐含的决策来源进行文档化表示，进而在架构维护过程中帮助维护人员对架构的修改进行完善的考虑，并能够为其他软件架构的相关活动提供参考。</p><p>架构知识的定义：架构知识＝架构设计＋架构设计决策。即需要说明在进行架构设计时采用此种架构的原因。</p><p>架构知识管理侧重于软件开发和实现过程所涉及的架构静态演化，从架构文档等信息来源中捕捉 架构知识，进而提供架构的质量属性及其设计依据以进行记录和评价。</p><p>在软件架构修改管理中，一个主要的做法就是建立一个隔离区域保障该区域内任何修改对其它部分的影响比较小，甚至没有影响。为此，需要明确修改规则、修改类型，以及可能的影响范围和副作用等。</p><p>软件架构版本管理为软件架构演化的版本演化控制、使用和评价等提供了可靠的依据，并为架构 演化量化度量奠定了基础。</p><h1>后记</h1><blockquote><p>人生如逆旅，我亦是行人。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-14软件可靠性基础</title>
      <link href="/posts/4f15d5b.html"/>
      <url>/posts/4f15d5b.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>软件可靠性基本概念（较重点）</li><li>软件可靠性建模</li><li>软件可靠性管理</li><li>软件可靠性设计（较重点）</li><li>软件可靠性测试与评价</li></ul><h1>中论</h1><h2 id="软件可靠性基本概念">软件可靠性基本概念</h2><p>软件可靠性是软件产品在规定的条件下和规定的时间区间完成规定功能的能力。</p><blockquote><p>软件可靠性和硬件区别</p><p>（1）复杂性：软件复杂性比硬件高，大部分失效来自软件失效。</p><p>（2）物理退化：硬件主要是物理退化，软件不存在物理退化。</p><p>（3）唯一性：软件是唯一的，每个COPY版本都一样，而两个硬件不可能完全一样。</p><p>（4）更新周期：硬件较慢，软件较快。</p></blockquote><p><strong>软件可靠性的定量描述:</strong></p><ol><li>规定时间：自然时间、运行时间、执行时间（CPU）</li><li>失效概率：初始0，单调递增，趋于1.</li><li>可靠度：不发生故障的概率。等于1-失效概率</li><li>失效强度：单位时间出现故障的概率。</li><li>MTTF：平均无故障时间，发生故障前正常运行的时间。</li><li>MTTR：平均修复时间，发生故障后修复的时间。</li><li>MTBF：平均故障间隔时间。MTBF=MTTF+MTTR。</li><li>系统可用性=MTTF/(MTTF+MTTR)*100%</li></ol><p><strong>串并联系统可靠性</strong></p><p>无论什么系统，都是由多个设备组成的，协同工作，而这多个设备的组合方式可以是串联、并联，也可以是混合模式，假设每个设备的可靠性为R1，R2……Rn，则不同的系统的可靠性公式如下：</p><ul><li>串联系统，一个设备不可靠，整个系统崩溃，<strong>整个系统可靠性R=R1 * R2 * … * Rn。</strong></li><li>并联系统，所有设备都不可靠，整个系统才崩溃，<em><em>整个系统可靠性R=1-（1-R1）</em> （1-R2）</em> … * （1-Rn）。**</li></ul><p><strong>可靠性测试的意义</strong></p><p>（1）软件失效可能造成灾难性的后果。</p><p>（2）软件的失效在整个计算机系统失效中的比例较高。</p><p>（3）软件可靠性技术很不成熟，加剧了软件可靠性问题的重要性。</p><p>（4）软件可靠性问题是造成费用增长的主要原因之一。</p><p>（5）软件对生产活动和社会生活的影响越来越大，从而增加了软件可靠性问题在软件工程领域乃至整个计算机工程领域的重要性。</p><ul><li>广义的软件可靠性测试是指为了最终评价软件系统 的可靠性而运用建模、统计、试验、分析和评价等一系列手段对软件系统实施的一种测试。</li><li>狭义的软件可靠性测试是指为了获取可靠性数据， 按预先确定的测试用例，在软件的预期使用环境中， 对软件实施的一种测试。它是面向缺陷的测试，以用户将要使用的方式来测试软件。</li></ul><p><img src="../image/post/image-20240605205035607.png" alt="image-20240605205035607"></p><h2 id="软件可靠性建模">软件可靠性建模</h2><ul><li><p>软件可靠性模型是指为预计或估算软件的可靠性所建立的可靠性框图和数学模型。</p></li><li><p>从技术的角度来看，影响软件可靠性的主要因素包括：运行环境、软件规模、软件内部结构、软件的开发方法和开发环境、软件的可靠性投入。</p></li></ul><p><strong>一个软件可靠性模型通常（但不是绝对）由以下几部分组成：</strong></p><p>（1）模型假设。模型是实际情况的简化或规范化，总要包含若干假设，例如测试的选取代表实际运行剖面，不同软件失效独立发生等。</p><p>（2）性能度量。软件可靠性模型的输出量就是性能度量，如失效强度、残留缺陷数等。在软件可靠性模型中性能度量通常以数学表达式给出。</p><p>（3）参数估计方法。某些可靠性度量的实际值无法直接获得，例如残留缺陷数，这时需通过一定的方法估计参数的值，从而间接确定可靠性度量的值。</p><p>（4）数据要求。一个软件可靠性模型要求一定的输入数据，即软件可靠性数据。</p><p><strong>绝大多数的模型包含3个共同假设：</strong></p><p>（1）代表性假设。是指可以用测试产生的软件可靠性数据预测运行阶段的软件可靠性行为。</p><p>（2）独立性假设。此假设认为软件失效是独立发生于不同时刻，一个软件失效的发生不影响另一个软件失效的发生。</p><p>（3）同质性假设。此假设认为所有软件失效的后果（等级）相同，即建模过程只考虑软件失效的具体发生时刻，不区分软件的失效严重等级。</p><p><strong>软件的可靠性模型分类</strong></p><ol><li>种子法模型。利用捕获一再捕获抽样技术估计程序中的错误数，在程序中预先有意“播种”一些设定的错误“种子”，然后根据测试出的原始错误数和发现的诱导错误的比例，来估计程序中残留的错误数。</li><li>失效率类模型。用来研究程序的失效率。</li><li>曲线拟合类模型。用回归分析的方法研究软件复杂性、程序中的缺陷数、失效率、失效间隔时间。</li><li>可靠性增长模型。这类模型预测软件在检错过程中的可靠性改进，用增长函数来描述软件的改进过程。</li><li>程序结构分析模型。是根据程序、子程序及其相互间的调用关系，形成一个可靠性分析网络。</li><li>输入域分类模型。选取软件输入域中的某些样本“点”运行程序，根据这些样本点在“实际”使用环境中的使用概率的测试运行时的成功 / 失效率，推断软件的使用可靠性。</li><li>执行路径分析方法模型。分析方法与上面的模型相似，先计算程序各逻辑路径的执行概率和程序中错误路径的执行概率，再综合出该软件的使用可靠性。</li><li>非齐次泊松过程模型。是以软件测试过程中单位时间的失效率为独立泊松随机变量，来预测在今后软件的某使用时间点的累计失效率。</li><li>马尔可夫过程模型。是以失效数为独立泊松随机变量，来预测在今后软件的某使用时间点的累计失效率。</li><li>贝叶斯模型。是利用失效率的试验前分布和当前的测试失效信息，来评估软件的可靠性。</li></ol><h2 id="软件可靠性管理">软件可靠性管理</h2><p>软件可靠性管理是软件工程管理的一部分，它以全面提高和保证软件可靠性为目标，以软件可靠性活动为主要对象，是把现代管理理论用于软件生命周期中的可靠性保障活动的一种管理形式。</p><p>软件可靠性管理的内容包括软件工程各个阶段的可靠性活动的目标、计划、进度、任务和修正措施等。</p><blockquote><p>可靠性各阶段设计任务如下：</p><p>需求分析阶段：确定可靠性目标、分析影响因素、确定验收标准、制定框架、制定文档编写规范、制定初步计划、确定数据收集规范。</p><p>概要设计阶段：确定可靠性度量、制定详细验收方案、可靠性设计、收集数据、调整计划、明确后续阶段详细计划、编制文档。 详细设计阶段：可靠性设计、预测、调整计划、收集数据、明确后续阶段详细计划、编制文档。</p><p>编码阶段：可靠性测试（单元）、排错、调整计划、收集数据、明确后续阶段详细计划、编制文档。</p><p>测试阶段：可靠性测试（集成和系统）、排错、可靠性建模、评价、调整计划、收集数据、明确后续阶段详细计划、编制文档。</p><p>实施阶段：可靠性测试（验收）、排错、收集数据、调整模型、评价、编制文档。</p></blockquote><h2 id="软件可靠性设计">软件可靠性设计</h2><p>实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制。</p><p>可靠性设计其实就是在常规的软件设计中，应用各种方法和技术，使程序设计在兼顾用户的功 能性和性能需求的同时，全面满足软件的可靠性要求。</p><blockquote><p>软件可靠性设计原则：</p><p>（1）软件可靠性设计是软件设计的一部分，必须在软件的总体设计框架中使用，并且不能与其他设计原则相冲突。</p><p>（2）软件可靠性设计在满足提高软件质量要求的前提下，以提高和保障软件可靠性为最终目标。</p><p>（3）软件可靠性设计应确定软件的可靠性目标，不能无限扩大化，并且排在功能度、用户需求和开发费用之后考虑。</p></blockquote><p>软件可靠性设计技术主要有容错设计、检错设计和降低复杂度设计等技术。</p><ul><li><p>提高系统可靠性技术可以分为避错（排错）技术和容错技术。避错是通过技术评审、系统测试和正确性证明等技术，在系统正式运行之前避免、发现和改正错误。</p></li><li><p>容错是指系统在运行过程中发生一定的硬件故障或软件错误时，仍能保持正常工作而不影响正确结果的一种性能或措施。容错技术主要是采用冗余方法来消除故障的影响。</p></li><li><p>冗余是指在正常系统运行的基础上加上一定数量的资源，包括信息、时间、硬件和软件。冗余是容错技术的基础，通过冗余资源的加入，可以使系统的可靠性得到较大的提高。主要的冗余技术有结构冗余（静态、动态、混合）、信息冗余、时间冗余和冗余附加4种。</p></li><li><p>软件容错的主要方法是提供足够的冗余信息和算法程序，使系统在实际运行时能够及时发现程序设计错误，采取补救措施，以提高系统可靠性，保证整个系统的正常运行。</p></li><li><p>软件容错技术主要有N版本程序设计、恢复块方法和防卫式程序设计等。</p></li></ul><h3 id="N版本程序设计">N版本程序设计</h3><p>设计思想是用N个具有相同功能的程序同时执行一项计算，结果通过多数表决来选择。其中N个版本的程序必须由不同的人独立设计，使用不同的方法、设计语言、开发环境和工具来实现，目的是减少N个版本的程序在表决点上相关错误的概率。</p><p><img src="../image/post/image-20240605210012365.png" alt="image-20240605210012365"></p><h3 id="恢复块设计（动态冗余）">恢复块设计（动态冗余）</h3><p>动态冗余又称为主动冗余，主要通过故障检测、故障定位及故障恢复等手段达到容错的目的。主要方式是多重模块待机储备，当系统检测到某工作模块出现错误时，就用一个备用的模块来代替它并重新运行。各备用模块在其待机时，可与主模块一样工作，也可以不工作。前者叫热备份系统（双重系统），后者叫冷备份系统（双工系统、双份系统）</p><p><img src="../image/post/image-20240605210244978.png" alt="image-20240605210244978"></p><h3 id="N版本与恢复块对比">N版本与恢复块对比</h3><p><img src="../image/post/image-20240605210330105.png" alt="image-20240605210330105"></p><h3 id="防卫式程序设计">防卫式程序设计</h3><p>防卫式程序设计：是一种不采用任何传统的容错技术就能实现软件容错的方法，对于程序中存在的错误和不一致性，防卫式程序设计的基本思想是通过在程序中包含错误检查代码和错误恢复代码，使得一旦发生错误，程序就能撤销错误状态，恢复到一个已知的正确状态中去。其实现策略包括错误检测、破坏估计和错误恢复三个方面。</p><h3 id="双容错技术">双容错技术</h3><p>双机容错技术：是一种软硬件结合的容错应用方案。该方案是由两台服务器和一个外接共享磁盘阵列及相应的双机软件组成。</p><p>双机容错系统采用“心跳”方法保证主系统与备用系统的联系。所谓心跳，是指主从系统之间相互按照一定的时间间隔发送通信信号，表明各自系统当前的运行状态。一旦心跳信号表明主机系统发生故障，或者备用系统无法收到主系统的信号，则系统高可用性管理软件认为主系统发生故障，立即将系统资源转移到备用系统上，备用系统替代主系统工作，以保证系统正常运行和网络服务不间断。</p><p>工作模式：双机热备模式；双机互备模式；双机双工模式。</p><h3 id="集群技术">集群技术</h3><p>集群技术就是将多台计算机组织起来进行协同工作，它是提高系统可用性和可靠性的一种技术。在集群系统中，每台计算机均承担部分计算任务和容错任务，当其中一台计算机出现故障时，系统使用集群软件将这台计算机从系统中隔离开去，通过各计算机之间的负载转嫁机制完成新的负载分担，同时向系统管理人员发出警报。集群系统通过功能整合和故障过渡，实现了系统的高可用性和可靠性。</p><p>特点：可伸缩性、高可用性、可管理性、高性价比、高透明性。</p><p>分类：高性能计算集群、负载均衡集群、高可用性集群</p><h3 id="负载均衡">负载均衡</h3><p>负载均衡是集群系统中的一项重要技术，可以提高集群系统的整体处理能力，也提高了系统的可靠性，最终目的是加快集群系统的响应速度，提高客户端访问的成功概率。集群的最大特征是多个节点的并行和共同工作，如何让所有节点承受的负荷平均，不出现局部过大负载或过轻负载的情况，是负载均衡的重要目的。</p><blockquote><p>比较常用的负载均衡实现技术主要有以下几种：</p><p>（1）基于特定软件的负载均衡（应用层）。很多网络协议都支持重定向功能，例如，基于HTTP重定向服务，其主要原理是服务器使用HTTP重定向指令，将一个客户端重新定位到另一个位置。服务器返回一个重定向响应，而不是返回请求的对象。客户端确认新地址然后重发请求，从而达到负载均衡的目的。</p><p>（2）基于DNS的负载均衡属于传输层负载均衡技术，其主要原理是在DNS服务器中为同一个主机名配置多个地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的节点上去，使得不同的客户端访问不同的节点，从而达到负载均衡的目的。将一个外部IP 地址映射为多个内部 IP 地址，对每次连接需求动态地转换为一个内部节点的地址，将外部连接请求引到转换来得地址的那个节点上，从而达到负载均衡的目的。</p><p>（3）基于NAT的负载均衡。将一个外部IP 地址映射为多个内部 IP 地址，对每次连接需求动态地转换为一个内部节点的地址，将外部连接请求引到转换来得地址的那个节点上，从而达到负载均衡的目的。</p><p>（4）反向代理负载均衡。将来自Internet上的连接请求以反向代理的方式动态地转发给内部网络上的多个节点进行处理，从而达到负载均衡的目的。</p><p>（5）混合型负载均衡。</p></blockquote><h2 id="软件可靠性测试与评价">软件可靠性测试与评价</h2><p>软件可靠性测试由<strong>可靠性目标的确定、运行剖面的开发、测试用例的设计、测试实施、测试结果的分析</strong>等活动组成。</p><p>测试步骤：<strong>定义软件运行剖面（为软件的使用行为建模）——设计可靠性测试用例——实施可靠性测试</strong>。</p><p>软件可靠性评价3个过程：<strong>选择可靠性模型、收集可靠性数据、可靠性评估和预测</strong>。</p><p>选择可靠性模型考虑因素：模型假设的适用性、预测的能力与质量、模型输出值能否满足可靠性评价需求、模型使用的简便性。</p><p>可靠性数据的收集：<strong>可靠性数据是指软件失效数据</strong>，是软件可靠性评价的基础，主要是在软件测试、实施阶段收集的。应采用的解决办法：及早确定所采用的的可靠性模型、制订可实施性较强的可靠性数据收集计划、重视软件测试数据的整理和分析、充分利用数据库来完成可靠性数据的存储和统计分析。</p><p>可靠性评估和预测：<strong>判断是否达到了可靠性目标</strong>；如未能达到要再投入多少；在软件系统投入实际运行一年或若干时间后，经过维护、升级和修改，软件能否达到交付或部分交付用户使用的可靠性水平。辅助方法：失效数据的图形分析法、试探性数据分析技术。</p><h1>后记</h1><blockquote><p>花繁不怕寻香客，榜到应倾贺喜杯。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-13.6中间件</title>
      <link href="/posts/1afaf6f1.html"/>
      <url>/posts/1afaf6f1.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>中间件</li></ul><h1>中论</h1><h2 id="中间件">中间件</h2><p><strong>中间件：在一个分布式系统环境中处于操作系统和应用程序之间的软件，可以在不同的技术之间共享资源，将不同的操作系统、数据库、异构的网络环境以及若干应用结合成一个有机的协同工作整体。</strong> 中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通信，有如下特点</p><ul><li>中间件是一类软件，而非一种软件；</li><li>中间件不仅仅实现互连，还要实现应用之间的互操作；</li><li>中间件是基于分布式处理的软件，最突出的特点是其网络通信功能。</li></ul><p>中间件的任务是使应用程序开发变得更容易，通过提供统一的程序抽象，隐藏异构系统和分布式系统下低级别编程的复杂度。</p><h3 id="中间件分类">中间件分类</h3><ul><li><p>**数据库访问中间件：**通过一个抽象层访问数据库，从而允许使用相同或相似的代码访问不同的数据库资源。典型的技术如Windows平台的ODBC和Java平台的JDBC等。</p></li><li><p>**远程过程调用（RPC）：**是一种广泛的使用的分布式应用程序处理方法。一个应用程序使用RPC来“远程”执行一个位于不同地址空间内的过程，从效果上看和执行本地调用相同。</p></li><li><p><strong>面向消息中间件(MOM):</strong> 利用高效可靠的消 息传递机制进行平台无关的数据交流，并可基于数据通信进行分布系统的集成。通过提供消息传递和消息排队模型，可在分布环境下扩展进程间的通信，并支持多种通信协议、语言、应用程序、硬件和软件平台。典型的产品如IBM的MQSeries。</p></li><li><p>**分布式对象中间件：**随着对象技术与分布式计算技术的发展，两者相互结合形成了分布式对象技术，并发展成为当今软件技术的主流方向。典型的产品如OMG的CORBA、Sun的RMI/EJB、Microsoft的DCOM等。</p></li><li><p>**事务中间件：**也称事务处理监控器（TPM）最早出现在大型机上。事务处理监控程序位于客户和服务器之间，完成事务管理和协调、负载平衡、失效恢复等任务，提高系统的整体性能。</p></li></ul><h3 id="J2EE">J2EE</h3><p><strong>J2EE 平台采用了多层分布式应用程序模型，实现不同逻辑功能的应用程序被封装到不同的构件中，处于不同层次的构件被分别部署到不同的机器中。</strong></p><p>四层结构：</p><ul><li><p>客户层组件：J2EE应用程序可以是基于web方式的，也可以是基于传统方式的静态的HTML（标准通用标记语言下的一个应用）页面和Applets是客户端组件</p></li><li><p>web 层组件：J2EE web层组件可以是JSP 页面或 Servlet。</p></li><li><p>业务层组件：业务层代码的逻辑用来满足特定领域 的业务逻辑处理。</p></li><li><p>信息系统层：企业信息系统层处理企业信息系统 软件包括企业基础设施系统例如企业资源计划 (ERP)， 大型机事务处理，数据库系统，和其他的 遗留信息系统. 例如，J2EE 应用组件可能为了数据库 连接需要访问企业信息系统。</p><p><img src="../image/post/image-20240604200825917.png" alt="image-20240604200825917"></p></li></ul><h3 id="JSP-Servlet-JavaBean-DAO">JSP+Servlet+JavaBean+DAO</h3><ul><li>JSP：用于显示、收集数据的部分。作为MVC中的视图V。</li><li>Servlet：作为业务逻辑层，用于处理复杂的业务逻辑，如验证数据、实例化JavaBean、调用DAO连接数据库等。作为MVC中的控制器C。在其会调用Service方法处理服务。</li><li>JavaBean：用于数据的封装，方便将查询结果在servlet与jsp页面之间进行传递等。</li><li>DAO：用于连接数据库及进行数据库的操作如：查询、删除、更改等。DAO与JavaBean合在一起为MVC中的模型M。 基本流程：JSP发一个数据到servlet，servlet收到后做解析再根据数据调用相应的service去服务，service如果有要调用数据库就通过DAO跟数据库交互，使用javaBean完成封装，返回结果给servlet，servlet再返回给JSP。</li></ul><blockquote><p>重量级与轻量级之争</p><ul><li>重量级框架占用资源过多，在开发的过程中效率很低；大部分时间花在配置、运行的过程上，修改复杂；单元测试也比较麻烦。但在大量运行过程中会表现出优异的效果，也即开发麻烦，运行性能高。</li><li>轻量级框架提高了开发的速度；立即可以看到结果；做单元测试非常简单；大量线程可供参考的开源代码。开发简单，但运行性能高。</li></ul></blockquote><h3 id="NET">.NET</h3><p>.NET框架处于操作系统和.NET应用语言之间，<strong>只适用于微软系统</strong>，而J2EE支持跨平台，任何安装了JVM的平台。</p><blockquote><p>.NET和J2EE之争HUA</p><ol><li>JVM（将所有JAVA代码都编译为字节码，由JVM解释执行）和CLR（.NET核心技术，类似于JVM，生成中间代码CLR，编译执行）。</li><li>对多层分布式应用的支持，二者都支持多层分布式应用程序的开发：在表示层的平台支持上，J2EE客户端支持多个平台，.NET只能在微软系统上运行，也正是因此，.NET会对微软系统上的应用进行优化；在业务层，J2EE占优势，因为有许多开源的项目和代码供参考，开发就变得简单；在数据层，二者都支持多种数据库，都非常优秀。</li><li>安全性，由于JAVA在.NET之后出来，借鉴了.NET优点，JAVA在运行时动态验证，.NET是静态全面验证，二者都非常优秀，不分上下。</li><li>应用程序的部署，J2EE的部署相对来说较复杂，针对不同的系统要特别布置。</li><li>可移植性，显然J2EE占优势，一次开发，到处运行。</li><li>外部支持：J2EE占优势，得到了很多厂家的支持，.NET只是微软一家。</li></ol></blockquote><h1>后记</h1><blockquote><p>画凌烟，上甘泉，自古功名属少年。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-13.5质量属性-架构评估</title>
      <link href="/posts/557ac9ad.html"/>
      <url>/posts/557ac9ad.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>质量属性</li><li>架构评估（重重点，选择题5分左右，论文5-10分）</li></ul><h1>中论</h1><h2 id="质量属性">质量属性</h2><p><strong>开发期质量属性和运行期质量属性（了解）</strong></p><p>软件系统的质量属性主要分为开发期质量属性和运行期质量属性</p><ol><li><p>开发期质量主要指在软件开发阶段所关注的质量，主要包括6个方面：</p><p>（1）易理解性：设计被开发人员理解的难易程度。</p><p>（2）可扩展性：软件因适应新需求或需求变化而增加新功能的能力，也称为灵活性。</p><p>（3）可重用性：重用软件系统或某一部分的难易程度。</p><p>（4）可测试性：对软件测试以证明其满足需求规范的难易程度。</p><p>（5）可维护性：当需要修改缺陷、增加功能、提高质量时，识别修改点并实施修改的难易程度。</p><p>（6）可移植性：将软件系统从一个运行环境转移到另一个不同的运行环境的难易程度。</p></li><li><p>运行期质量主要指在软件运行阶段所关注的质量，主要包括7个方面：</p><p>（1）性能：是指软件系统及时提供相应服务的能力，如速度、吞吐量和容量等的要求。</p><p>（2）安全性：指软件系统同时兼顾向合法用户提供服务，以及阻止非授权使用的能力。</p><p>（3）可伸缩性：指当用户数和数据量增加时，软件系统维持高质量服务的能力。例如，通过增加服务器来提高能力。</p><p>（4）互操作性：指本软件系统与其他系统交换数据和相互调用服务的难易程度。</p><p>（5）可靠性：软件系统在一定的时间内持续无故障运行的能力。</p><p>（6）可用性：指系统在一定时间内正常工作的时间所占的比例。可用性会受到系统错误，恶意攻击，高负载等问题的影响。</p><p>（7）鲁棒性：是指软件系统在非正常情况（如用户进行了非法操作、相关的软硬件系统发生了故障等）仍能够正常运行的能力，也称健壮性或容错性。</p></li></ol><h2 id="架构评估">架构评估</h2><h3 id="质量属性（较重要）"><strong>质量属性（较重要）</strong></h3><ol><li>性能：指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理的事件的个数。如响应时间、吞吐量。 设计策略：优先级队列、增加计算资源、减少计算开销、引入并发机制、采用资源调度等。</li><li>可靠性：是软件系统在应用或系统错误面前，在意外或错误使用的情况下维持软件系统的功能特性的基本能力。如MTTF、MTBF、MTTR。 设计策略：心跳、Ping/Echo、冗余、选举。</li><li>可用性：是系统能够正常运行的时间比例，经常用两次故障之间的时间长度或在出现故障时系统能够恢复正常的速度来表示。如故障间隔时间。 设计策略：心跳、Ping/Echo、冗余、选举。</li><li>安全性：是指系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力。如保密性、完整性、不可抵赖性、可控性。 设计策略：入侵检测、用户认证、用户授权、追踪审计。</li><li>可修改性：指能够快速的以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量。 设计策略：接口-实现分类、抽象、信息隐藏。</li><li>功能性：是系统所能完成所期望的工作的能力。一项任务的完成需要系统中许多或大多数构件的相互协作。</li><li>可变性：指体系结构经扩充或变更而成为新体系结构的能力。这种新体系结构应该符合预先定义的规则，在某些具体方面不同于原有的体系结构。当要将某个体系结构作为一系列相关产品的基础时，可变性是很重要的。</li><li>互操作性：作为系统组成部分的软件不是独立存在的，经常与其他系统或自身环境相互作用。为了支持互操作性，软件体系结构必须为外部可视的功能特性和数据结构提供精心设计的软件入口。程序和其他编程语言编写的软件系统的交互作用就是互操作性的问题，也影响应用的软件体系结构。</li></ol><h3 id="质量属性场景">质量属性场景</h3><p>质量属性场景是一种面向特定质量属性的需求。</p><p>它由6部分组成：</p><ul><li>刺激源（Source）：这是某个生成该刺激的实体（人、计算机系统或者任何其他刺激器）。</li><li>刺激（Stimulus）：该刺激是当刺激到达系统时需要考虑的条件。</li><li>环境（Environment）：该刺激在某些条件下发生。当激励发生时，系统可能处于过载、运行或者其他情况。</li><li>制品（Artifact)：某个制品被激励。这可能是整个系统，也可能是系统的一部分。</li><li>响应（Response）：该响应是在激励到达后所采取的行动。</li><li>响应度量（Measurement）：当响应发生时，应当能够以某种方式对其进行度量，以对需求进行测试。 可修改性质量属性场景描述实例：</li></ul><p><img src="../image/post/image-20240603202900387.png" alt="image-20240603202900387"></p><p>敏感点：是指为了实现某种特定的质量属性，一个或多个组件所具有的特性。</p><p>权衡点：是影响多个质量属性的特性，是多个质量属性的敏感点。</p><p>风险点与非风险点不是以标准专业术语形式出现的，只是一个常规概念，即可能导致风险的因素，可称为风险点；如果某个做法有隐患，有可能导致一些问题，则为风险点；而如果某个做法是可行的可接受的，则为非风险点。</p><p>软件架构评估在架构设计之后，系统设计之前，因此与设计、实现、测试都没有关系。评估的目的是为了评估所采用的架构是否能解决软件系统需求，而不是单纯的确定是否满足需求。</p><h3 id="评估方式（重点）">评估方式（重点）</h3><ul><li>基于调查问卷（检查表）的方式：类似于需求获取中的问卷调查方式，只不过是架构方面的问卷，要求评估人员对领域熟悉。</li><li>基于度量的方式：制定一些定量指标来度量架构，如代码行数等。要制定质量属性和度量结果之间的映射，要求评估人员对架构熟悉。</li><li>基于场景的方式：主要方法。首先要确定应用领域的功能和软件架构的结构之间的映射，然后要设计用于体现待评估质量属性的场景（即4+1视图中的场景），最后分析软件架构对场景的支持程度。要求评估人员既对领域熟悉，也对架构熟悉。从三个方面对场景进行设计：刺激（事件）；环境（事件发生的环境）；响应（架构响应刺激的过程）。</li></ul><p><img src="../image/post/image-20240603203123896.png" alt="image-20240603203123896"></p><h4 id="基于场景的架构分析方法SAAM">基于场景的架构分析方法SAAM</h4><p>SAAM是一种非功能性质量属性的架构分析方法，是最早形成文档并得到广泛应用的软件架构分析方法。</p><ul><li><p>特定目标：SAAM的目标是对描述应用程序属性的文档，验证基本的架构假设和原则。</p></li><li><p>质量属性：这一方法的基本特点是把任何形式的质量属性都具体化为场景，但可修改性是SAAM分析的主要质量属性。</p></li><li><p>架构描述：SAAM用于架构的最后一个版本，但早于详细设计。架构的描述形式应当被所有参与者理解。</p></li></ul><p>功能、结构和分配被定义为描述架构的3个主要方面。</p><ul><li>方法活动：SAAM的主要输入是问题描述、需求声明和架构描述。下图描绘了SAAM分析活动的相关输入及评估过程。包括5个步骤，即场景开发、架构描述、单个场景评估、场景交互和总体评估。</li></ul><p><img src="../image/post/image-20240603203247532.png" alt="image-20240603203247532"></p><h4 id="架构权衡分析法ATAM（十分重要）">架构权衡分析法ATAM（十分重要）</h4><p>架构权衡分析法ATAM，让架构师明确如何权衡多个质量目标，参与者有评估小组、项目决策者和其他项目相关人员。</p><p>ATAM被分为四个主要的活动领域，分别是</p><ul><li>场景和需求收集、</li><li>体系结构视图和场景实现、</li><li>属性模型构造和分析、</li><li>折中。</li></ul><p>整个评估过程强调以属性作为架构评估的核心概念。主要针对性能、可用性、安全性和可修改性，在系统开发之前，对这些质量属性进行评价和折中。</p><p><img src="../image/post/image-20240603203535763.png" alt="image-20240603203535763"></p><h4 id="成本效益分析法CBAM">成本效益分析法CBAM</h4><p>成本效益分析法CBAM，用来对架构建立的成本来进行设计和建模，让决策者根据投资收益率来选择合适的架构，可以看做对ATAM的补充，在ATAM确定质量合理的基础上，再对效益进行分析。有以下步骤：</p><ul><li>整理场景（确定场景，并确定优先级，选择三分之一优先级最高的场景进行分析）；</li><li>对场景进行细化（对每个场景详细分析，确定最好、最坏的情况）；</li><li>确定场景的优先级（项目干系人对场景投票，根据投票结果确定优先级）；</li><li>分配效用（对场景响应级别确定效用表，建立策略、场景、响应级别的表格）；</li><li>形成“策略-场景-响应级别的对应关系”；</li><li>确定期望的质量属性响应级别的效用（根据效用表确定所对应的的具体场景的效用表）；</li><li>计算各架构策略的总收益；</li><li>根据受成本限制影响的投资报酬率选择架构策略（估算成本，用上一步的收益减去成本，得出收益，并选择收益最高的架构策略）。</li></ul><h4 id="其他评估方法（了解）">其他评估方法（了解）</h4><ol><li><p>SAEM方法。将软件架构视为最终产品以及设计过程中的一种中间产品，从外部质量和内部质量两个角度阐述其评估模型，旨在为软件架构的质量评估创建一个框架。<strong>外部属性指用户定义的质量属性，而内部属性指开发者决定的质量属性。</strong></p><p>该软件架构评估模型包含以下几个流程。</p><ul><li><p>对待评估的质量属性进行规约建模。</p></li><li><p>为外部和内部的质量属性创建度量准则，先从评估目的（如软件架构比较、最终产品的质量预测），评估角度（如开发者、用户、维护者），评估环境（架构作为最终产品或设计中间产品）出发来定义架构评估的目标，再根据目标相关的属性来提出问题，然后回答每个问题并提出相应的度量准则。</p></li><li><p>评估质量属性，包括数据收集、度量和结果分析3个活动。</p></li></ul></li><li><p>SAABNet方法。是一种用来表达和使用定性知识以辅助架构的定性评估的方法。该方法来源于人工智能，允许不确定、不完整知识的推理。该方法使用BBN来表示和使用开发过程中的知识，包含定性和定量的描述，其中定性的描述是所有节点的图，定量的描述是每个节点状态相关的条件概率。</p></li><li><p>SACMM方法。是一种软件架构修改的度量方法。</p></li><li><p>SASAM方法。通过对预期架构（架构设计阶段的相关描述材料）和实际架构（源代码中执行的人工智能）进行映射和比较来静态地评估软件架构。</p></li><li><p>ALRRA方法。是一种软件架构可靠性风险评估方法，利用动态复杂度准则和动态耦合度准则来定义组件和连接件的复杂性因素。</p></li><li><p>AHP（层次分析法）方法。是对定性问题进行定量分析的一种简便、灵活而又实用的多准则决策方法。</p></li><li><p>COSMIC+UML方法。基于度量模型来评估软件架构可维护性，主要是为了辅助分析软件架构的演化方案是否可行，并在开源软件DCMMS的软件架构UML组件图上得以验证。</p></li></ol><h1>后记</h1><blockquote><p>桃花直透三层浪，桂子高攀第一枝。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-13.4架构复用-DSSA-ABSD</title>
      <link href="/posts/daa927b2.html"/>
      <url>/posts/daa927b2.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>软件架构复用</li><li>DSSA</li><li>ABSD</li></ul><h1>中论</h1><h2 id="软件架构复用">软件架构复用</h2><ul><li>软件产品线是指一组软件密集型系统，它们共享一个公共的、可管理的特性集，满足某个特定市场或任务的具体需要，是以规定的方式用公共的核心资产集成开发出来的。软件产品线围绕核心资产库进行管理、复用、集成新的系统。</li><li>软件复用分为机会复用和系统复用。机会复用是在开发过程中发现有可复用的资产就进行复用，而系统复用则是在开发之前就规划好哪些需要复用。</li><li>可复用的资产包括需求、架构设计、元素、建模与分析、测试、项目规划、过程方法和工具、人员、样本系统、缺陷消除。</li><li>复用的过程主要包括获取可复用的软件资产、管理这些资产（例如通过构件库）以及根据特定需求从这些资产中选择可复用的部分来开发满足需求的应用系统。</li></ul><h2 id="DSSA">DSSA</h2><ul><li><p>DSSA是一个特定问题领域的软件构件集合，这些软件构件专门用于一类特定类型的任务（领域），在整个领域中都能有效地使用，并且成功构造应用系统时限定了标准的组合结构。</p></li><li><p>DSSA是一个特定的问题领域中支持一组应用的领域模型、参考需求、参考架构等组成的开发基础，其目标是支持在一个特定领域中多个应用的生成。</p></li><li><p>垂直域是在一个特定领域中的通用的软件架构，是一个完整的架构。</p></li><li><p>水平域是在多个不同的特定领域之间的相同的部分的小工具，如购物和教育都有收费系统，收费系统就是水平域。</p></li></ul><h3 id="DSSA（特定领域软件体系结构）的三个基本活动"><strong>DSSA（特定领域软件体系结构）的三个基本活动</strong></h3><ol><li>领域分析阶段的主要目标是获得领域模型（领域需求）。识别信息源，可能的信息源包括现存系统、技术文献、问题域和系统开发的专家、用户调查和市场分析、领域演化的历史记录等。在此基础上分析领域中系统的需要，确定哪些需求是领域中的系统广泛共享的，建立领域模型。</li><li>领域设计阶段的目标是获得DSSA。DSSA描述在领域模型中表示的需求的解决方案，不是单个系统的表示，而是能够适应领域中多个系统的需求的一个高层次的设计。建立了领域模型之后，就可以派生出满足这些被建模的领域需求的DSSA。</li><li>领域实现阶段的主要目标是依据领域模型和DSSA开发和组织可重用信息。这些可重用信息可能是从现有系统中提取得到，也可能是通过新的开发得到。</li></ol><h3 id="DSSA的四种角色人员的介绍："><strong>DSSA的四种角色人员的介绍：</strong></h3><ol><li>领域专家：包括该领域中系统的有经验的用户、从事该领域中系统的需求分析、设计、实现以及项目管理的有经验的软件工程师等。他们的职责包括提供关于领域中系统的需求规约和实现的知识，帮助组织规范的一致的领域字典，选择样本系统作为领域工程的依据，复审领域模型、DSSA等领域的工程产品等。</li><li>领域分析人员：通常由具有知识工程背景的经验丰富的系统分析师担任。负责整个领域分析过程，进行知识获取并将获取的知识组织到领域模型中。</li><li>领域设计人员：由有经验的软件设计师担任。根据领域模型和现有系统开发出DSSA，并验证DSSA的准确性和一致性。</li><li>领域实现人员：由有经验的程序员担任。根据领域模型和DSSA开发构件。</li></ol><h3 id="建立DSSA（特定领域软件体系结构）的过程"><strong>建立DSSA（特定领域软件体系结构）的过程</strong></h3><ol><li>定义领域范围：明确领域内的应用要满足用户一系列的需求。</li><li>定义领域元素：构建领域传统，归纳领域术语，识别领域内共同和不共同的元素。</li><li>定义领域特定的设计和实现需求约束：识别所有领域约束及其对设计和实现的影响。</li><li>定义领域模型和架构：创建一般架构并描述其组件说明。</li><li>产生、搜集可复用的产品单元：增加复用组件，使其可用于新系统。</li></ol><p>以上过程是并发的、递归的、反复的、螺旋型的。</p><h3 id="三层次模型"><strong>三层次模型</strong></h3><ul><li>领域开发环境：领域架构师决定核心架构，产出参考结构、参考需求、架构、领域模型、开发工具。</li><li>领域特定的应用开发环境：应用工程师根据具体环境来将核心架构实例化。</li><li>应用执行环境：操作员实现实例化的架构。</li></ul><h2 id="ABSD">ABSD</h2><ul><li>ABSD方法是架构驱动，强调由业务、质量和功能需求的组合驱动架构设计。它强调采用视角和图表来描述软件架构，采用用例和质量属性场景来描述需求。进一步来说，用例描述的是功能需求，质量属性场景描述的是质量需求（或侧重于非功能需求）。</li><li>使用ABSD方法，设计活动可以从项目总体功能框架明确就开始，这意味着需求获取和分析还没有完成，就已经开始了软件设计。</li><li>ABSD方法有三个基础。第一个基础是功能分解，使用已有的基于模块的内聚和耦合技术；第二个基础是通过选择架构风格来实现质量和业务需求；第三个基础是软件模板的使用，软件模板利用了一些软件系统的结构。</li><li>ABSD方法是递归的，且迭代的每一个步骤都是清晰定义的。因此，不管设计是否完成，架构总是清晰的，有助于降低架构设计的随意性。</li></ul><h3 id="开发过程">开发过程</h3><p><img src="../image/post/image-20240530202510133.png" alt="image-20240530202510133"></p><ol><li><p>架构需求：重在掌握标识构件的三步，如下左图所示。</p></li><li><p>架构设计：将需求阶段的标识构件映射成构件，进行分析，如下右图所示。</p></li><li><p>架构（体系结构）文档化：主要产出两种文档，即架构（体系结构）规格说明书，测试架构（体系结构）需求的质量设计说明书。文档是至关重要的，是所有人员沟通的手段，关系开发的成败。</p></li><li><p>架构审核：由外部人员（独立于开发组织之外的人，如用户代表和领域专家等）参加的审核，审核架构是否满足需求、质量问题、构件划分合理性等。</p><p><img src="../image/post/image-20240530202625712.png" alt="image-20240530202625712"></p></li><li><p>若审核不过，则返回架构设计阶段进行重新设计、文档化，再审核。</p></li><li><p>架构实现：用实体来显示架构。实现构件，组装成系统，如下左图：</p></li><li><p>架构演进：按需增删构件，使架构可复用，如下右图：</p></li></ol><p><img src="../image/post/image-20240530202722298.png" alt="image-20240530202722298"></p><h1>后记</h1><blockquote><p>须信百年俱是梦，天地阔，且徜徉。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-13.3层次架构风格-SOA</title>
      <link href="/posts/80d66d02.html"/>
      <url>/posts/80d66d02.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>层次架构风格</li><li>面向服务的架构风格（SOA）</li></ul><h1>中论</h1><h2 id="层次架构风格">层次架构风格</h2><h3 id="两层C-S架构：">两层C/S架构：</h3><p>客户端和服务器都有处理功能，现在已经不常用。</p><p>缺点：开发成本高，客户端程序设计复杂、信息内容和形式单一、用户界面风格不一、软件移植困难、维护和升级困难、服务端压力大难以复用等。</p><p><img src="../image/post/image-20240529200038523.png" alt="image-20240529200038523"></p><h3 id="三层C-S架构">三层C/S架构</h3><p>将处理功能独立出来，表示层和数据层都变得简单。表示层在客户机上，功能层在应用服务器上，数据层在数据库服务器上。</p><p>优点：</p><ul><li>各层逻辑上保持相对独立，整个系统的逻辑结构更为清晰；</li><li>允许灵活有效的选用相应的平台和硬件系统，具有良好的可升级性和开放性</li><li>各层可以并行开发，各层也可以选择各自合适的开发语言</li><li>功能层有效的隔离表示层和数据层，整个系统的管理层次也更加合理和可控制</li></ul><p>缺点：三层C/S架构设计关键在于各层之间的通信效率。</p><h3 id="三层B-S架构">三层B/S架构</h3><p>三层C/S架构的变种，将客户端变为用户客户端上的浏览器，将应用服务器变为网络上的WEB服务器，又称为0客户端架构。</p><p>虽然不用开发客户端，但是有很多缺点：</p><ul><li>B/S架构缺乏对动态页面的支持能力，没有集成有效的数据库处理功能</li><li>安全性难以控制</li><li>在数据查询等响应速度上远远低于C/S架构</li><li>数据提交一般以页面为单位，数据的动态交互性不强，不利于OLTP应用</li></ul><h3 id="混合架构风格">混合架构风格</h3><p>内外有别模型：企业内部使用C/S，外部人员访问使用B/S</p><p>查改混合模型：采用B/S查询。C/S修改</p><p>混合架构实现困难，且成本高</p><h3 id="富互联网应用RIA">富互联网应用RIA</h3><p>RIA是一种用户接口，比用HTML实现的接口更加健壮，且有可视化内容，本质还是网站模式</p><p>优点：</p><ul><li>RIA结合了C/S架构反应速度快、交互性强的优点与B/S架构传播范围广及容易传播的特性；</li><li>RIA简化并改进了B/S架构的用户交互；</li><li>数据能够被缓存在客户端，从而可以实现一个比基于HTML的响应速度更快且数据往返于服务器的次数更少的用户界面。</li><li>本质还是0客户端，借助于高速网速实现必要插件在本地的快速缓存，增强页面对动态页面的支持能力，典型的如小程序。</li></ul><h3 id="MVC架构">MVC架构</h3><p><img src="../image/post/image-20240529201715923.png" alt="image-20240529201715923"></p><p>(1)控制器（Controller）： 是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p><p>(2)模型（Model）： 是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。模型表示业务数据和业务逻辑。</p><p>(3)视图（View）： 是应用程序中处理数据显示的部分。通常视图是依据模型数 据创建的。是用户看到并与之交互的界面。视图向用户显示相关 的数据，并能接收用户的输入数据，但是它并不进行任何实际的业务处理。</p><h3 id="MVP架构">MVP架构</h3><p>MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。</p><p><img src="../image/post/image-20240529201817612.png" alt="image-20240529201817612"></p><p>特点：</p><ul><li>M、V、P之间双向通信。</li><li>View与Model不通信，都通过Presenter传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。</li><li>View非常薄，不部署任何业务逻辑，称为“被动视图”（Passive View），即没有任何主动性，而Presenter非常厚，所有逻辑都部署在那里。</li><li>Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。</li></ul><h3 id="MVVC架构">MVVC架构</h3><p>MVVM：MVVM模式和MVC模式类似，主要目的是分离视图（View）和模型（Model）</p><p><img src="../image/post/image-20240529202034675.png" alt="image-20240529202034675"></p><p>优点：</p><ul><li>低耦合，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View“上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li><li>可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li><li>独立开发，开发人员可以专注于页面设计（ViewModel），设计人员可以专注于业务逻辑和数据的开发。</li><li>可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</li></ul><h2 id="面向服务的架构风格（SOA）">面向服务的架构风格（SOA）</h2><p>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通信，不涉及底层编程接口和通信模型。</p><p>在SOA中，服务是一种为了满足某项业务需求的操作、规则等的逻辑组合，它包含一系列有序活动的交互，为实现用户目标提供支持。</p><p>SOA并不仅仅是一种开发方法，还具有管理上的优点，管理员可直接管理开发人员所构建相同的服务。多个服务通过企业服务总线提出服务请求，由应用管理来进行处理，如下：</p><p><img src="../image/post/image-20240529202027916.png" alt="image-20240529202027916"></p><ul><li><p>实施SOA的关键目标是实现企业IT资产重用的最大化，在实施SOA过程中要牢记以下特征：</p><ul><li>可以从企业外部访问、随时可用（服务请求能被及时响应）、</li><li>粗粒度接口（粗粒度提供一项特定的业务功能，而细粒度服务代表了技术组件方法）、</li><li>服务分级、</li><li>松散耦合（服务提供商和服务使用者分离）、</li><li>可重用的服务及服务接口设计管理、</li><li>标准化的接口（WSDL、SOAP、XML是核心）、</li><li>支持各种消息模式、精确定义的服务接口。</li></ul></li><li><p>从基于对象到基于组件再到基于服务，架构越来越松散耦合，粒度越来越大，接口越来越标准。</p></li><li><p>基于服务的构件与传统构件的区别有四点：</p><ul><li>服务构件粗粒度，传统构件细粒度居多；</li><li>服务构件的接口是标准的，主要是WSDL接口，而传统构件常以具体API形式出现；</li><li>服务构件的实现与语言是无关的，而传统构件常绑定某种特定的语言；</li><li>服务构件可以通过构件容器提供QoS的服务，而传统构件完全由程序代码直接控制。</li></ul></li></ul><h3 id="关键技术">关键技术</h3><p>SOA中的关键技术</p><p><img src="../image/post/image-20240529202310883.png" alt="image-20240529202310883"></p><ul><li>UDDI（Universal Description, Discovery and Integration）是一套基于WEB的、分布式的、为WebService提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的WebService注册，以便别的企业能够发现的访问协议的标准规范。</li><li>WSDL（Web Service Description Language）将Web服务描述定义为一组服务访问点，客户端可以通过这些服务访问点对包含面向文档信息或面向过程调用的服务进行访问（类似于远程调用），用于描述服务。</li><li>SOAP（Simple Object Access Protocol）是用于交换XML编码信息的轻量级协议，用于传输信息。</li><li>XML（eXtensible Markup Language）是WebService平台中表示数据的基本格式，用于数据交换。</li></ul><h3 id="Web-Service">Web Service</h3><p>WEB Service包括服务提供者、服务注册中心（中介，提供交易平台，可有可无）、服务请求者。服务提供者将服务描述发布到服务注册中心，供服务请求者查找，查找到后，服务请求者将绑定查找结果。</p><p><img src="../image/post/image-20240529202504137.png" alt="image-20240529202504137"></p><h3 id="服务注册表">服务注册表</h3><p>服务注册表包括三个部分：</p><ul><li><p>服务注册：应用开发者（服务提供者）在注册表中公布服务的功能。</p></li><li><p>服务位置：服务使用者（服务应用开发者），帮助他们查询注册服务，寻找符合自身要求的服务。</p></li><li><p>服务绑定：服务使用者利用搜索到的服务接口来编写代码，所编写的代码与注册的服务绑定，调用注册的服务，以及与它们实现互动。</p></li></ul><h3 id="企业服务总线ESB">企业服务总线ESB</h3><p>企业服务总线ESB是一种用来连接各个服务节点的管道，它的存在是为了集成不同协议的不同服务，做了消息的转化、解释以及路由的工作，以此来让不同的服务互连互通。</p><p>ESB包括客户端（服务请求者）、基础架构服务（中间件）、核心集成服务（提供服务）。</p><p>特点：</p><ul><li>作为SOA的一种实现方式，ESB在面向服务的架构中起到的是总线作用，将各种服务进行连接与整合；</li><li>提供服务的元数据和服务描述数据的管理；</li><li>在服务请求者和提供者之间传递数据，以及对这些数据进行转换的能力，同时支持同步和异步模式；</li><li>具备发现、路由、匹配和选择的能力，以支持服务之间的动态交互，解耦服务请求者和提供者。高级一些的能力还包括安全支持、服务质量保证、可管理和负载平衡等。</li></ul><p><img src="../image/post/image-20240529202644356.png" alt="image-20240529202644356"></p><h1>后记</h1><blockquote><p>笙歌不见故人散，十里长欢难再寻。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-13.2软件架构风格</title>
      <link href="/posts/1fe5a574.html"/>
      <url>/posts/1fe5a574.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>软件架构风格</li></ul><h1>中论</h1><h2 id="软件架构风格">软件架构风格</h2><p>描述某一特定应用领域中系统组织方式的惯用模式。</p><p>架构风格定义一个系统家族，即一个架构定义、一个词汇表、一组约束。</p><ul><li><p>定义：用于描述系统的术语表和一组指导构建系统的规则</p></li><li><p>词汇表：包含一些构件和连接件类型</p></li><li><p>约束：系统如何将这些构件和连接件组合起来</p></li></ul><p>架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。</p><p>软件设计的核心问题：能否达到架构级的软件复用。</p><h3 id="风格分类">风格分类</h3><p><strong>数据流风格</strong>：面向数据流，按照一定的顺序从前向后执行程序。代表的风格：批处理序列、管道-过滤器。</p><p><strong>调用/返回风格</strong>：构件之间存在互相调用的关系，一般是显示的调用。代表风格：主程序/子程序、面向对象、层次结构。</p><p><strong>独立构件风格</strong>：构件之间是相互独立的，不存在显式的调用关系，而是通过某个事件触发、异步的方式来执行。代表风格：进程通信、事件驱动系统（隐式调用）。</p><p><strong>虚拟机风格</strong>：自定义一套规则供使用者使用，使用者基于这个规则来开发构件，能够跨平台适配，代表风格：解释器，基于规则的系统。</p><p><strong>仓库风格</strong>：以数据为中心，所有的操作系统都是围绕建立的数据中心进行的，代表风格：数据库系统、超文本系统、黑板系统。</p><p><strong>数据流风格</strong></p><ul><li>批处理序列：构件为一系列固定顺序的计算单元，构件之间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在其前一步结束后才能开始，数据必须是完整的，以整体的方式传递。</li><li>管道-过滤器：每个构件都有一组输入和输出，构件读取输入的数据流，经过内部处理，产生输出数据流。前一个构件的输出作为后一个构件的输入，前后数据流关联。过滤器就是构件，连接件就是管道。</li></ul><blockquote><p>早期编译器就是采用的这种架构，要一步一步处理的，均可考虑此架构风格。</p><p>二者区别在于批处理前后构件不一定有关联，并且是作为整体传递，即必须前一个执行完才能执行下一个。管道-过滤器是前一个输出作为后一个输入，前面执行到部分可以开始下一个的执行。</p></blockquote><p><strong>调用/返回风格</strong></p><ul><li><p>主程序/子程序：单线程控制，把问题划分为若干个处理步骤，构件即为主程序和子程序，子程序通常可合成为模块。过程调用作为交互机制，充当连接件的角色。</p></li><li><p>面向对象：构件是对象，对象是抽象数据类型的实例。连接件即使对象间交互的方式，对象是通过函数和过程的调用来交互的。</p></li><li><p>层次结构：构件组成一个层次结构，连接件通过决定层间如何交互的协议来定义。每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。修改某一层，最多影响其相邻的两层（通常只能影响上层）。</p><ul><li><p>层次结构优点：</p><p>1、支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。</p><p>2、不同的层次处于不同的抽象级别，越靠近底层，抽象级别越高。</p><p>3、由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件复用提供了强大的支持。</p></li><li><p>层次结构缺点：</p><p>1、并不是每个系统都可以很容易的划分为分层的模式。</p><p>2、很难找到一个合适的、正确的层次抽象方法。</p></li></ul></li></ul><p><strong>独立构件风格</strong></p><ul><li>进程通信：构件是独立的进程，连接件是消息传递。构件通常是命名过程，消息传递的方式可以是点对点、异步或同步方式，以及远程过程（方法）调用等</li><li>事件驱动系统（隐式调用）：构件不直接调用一个过程，而是触发或广播一一个或多个事件。构件中的过程在一个或多个事件中注册，当某个事件被触发时，系统自动调用在这个事件中注册的所有过程。一个事件的触发就导致了另一个模块中的过程调用。这种风格中的构件是匿名的过程，它们之间交互的连接件往往是以为过程之间的隐式调用来实现的。</li></ul><blockquote><p>主要优点是为软件复用提供了强大的支持，为构件的维护和演化带来了方便；缺点是构件放弃了对系统计算的控制。</p></blockquote><p><strong>虚拟机风格</strong></p><ul><li>解释器：通常包括一个完成解释工作的解释引擎、一个包含将被解释的代码的存储区、一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行的进度的数据结构。具有解释器风格的软件中含有一个虚拟机，可以仿真硬件的执行过程和一些关键应用，缺点是执行效率低。</li><li>基于规则的系统：包括规则集、规则解释器、规则/数据选择器和工作内存,一般用在人工智能领域和DSS中。</li></ul><p><strong>仓库（数据共享）风格</strong></p><ul><li>数据库系统：构件主要有两大类，一类是中央共享数据源，保存当前系统的 数据状态；另一类是多个独立处理单元，处理单元对数据元素进行操作。</li><li>黑板系统：包括知识源、黑板和控制三部分。知识源包括若干独立计算的不同单元，提供解决问题的知识。知识源响应黑板的变化，也只修改黑板；黑板是一个全局数据库，包含问题域空间的全部状态，是知识源相互作用的唯一 媒介；知识源响应是通过黑板状态的变化来控制的。黑板系统通常应用在对于解决问题没有确定性算法的软件中（信号处理、问题规划和编译器优化等）。</li><li>超文本系统：构件以网状链接方式相互连接，用户可以在构件之间进行按照人类的联想思维方式进行任意跳转到相关构件。是一种非线性的网状信息组织方法，它以节点为基本单位，链作为节点之间的联想式关联。通常应用在互联网领域。</li><li>现代编译器的集成开发环境一般采用数据仓库（即以数据为中心的架构风格） 架构风格进行开发，其中心数据就是程序的语法树。</li></ul><p><strong>闭环控制</strong></p><p>当软件被用来操作一个物理系统时，软件与硬件之间可以粗略的表示为一个反馈循环，这个反馈循环通过接受一定的输入，确定一系列的输出，最终使环境达到一个新的状态，适用于嵌入式系统，涉及连续的动作与状态。</p><p><img src="../image/post/image-20240528202759723.png" alt="image-20240528202759723"></p><p><strong>C2体系结构</strong></p><p>C2体系结构风格可以概括为：通过连接件绑定在一起的并行构件网络。</p><p>C2风格中的系统组织规则如下：</p><ol><li>系统中的构件和连接件都有一个顶部和一个底部；</li><li>构件的顶部应连接到某连接件的底部，构件的底部则应连接到某连接件的顶部，而构件与构件之间的直接连接是不允许的；</li><li>一个连接件可以和任意数目的其它构件和连接件连接；</li><li>当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部。</li></ol><p><img src="../image/post/image-20240528203200091.png" alt="image-20240528203200091"></p><h3 id="记忆表格">记忆表格</h3><p><img src="../image/post/image-20240528203231528.png" alt="image-20240528203231528"></p><h1>后记</h1><blockquote><p>我来问道无馀说，云在青霄水在瓶。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-13.1软件架构概述-构件技术</title>
      <link href="/posts/8c224547.html"/>
      <url>/posts/8c224547.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>软件架构概述</li><li>构件技术</li></ul><h1>中论</h1><h2 id="软件架构概述">软件架构概述</h2><p>软件架构：从需求分析到软件设计之间的过渡过程。</p><p>架构设计：需求分配，将满足需求的职责分配到组件上。</p><p>软件架构为软件系统提供了一个结构、行为和属性的高级抽象，由构件的描述、构件的相互作用（连接件）、指导构件集成的模式以及这些模式的约束组成。</p><p>软件架构不仅指定了系统的组织结构和拓扑结构，并显示了系统需求和构件之间的对应关系，提供了一些设计决策的基本原理。</p><p>研究软件架构的根本目的：解决好软件的复用、质量和维护问题。</p><p>软件架构设计：包括提出架构模型、产生架构设计和进行设计评审等活动。</p><p>架构设计主要关注：软件组件的结构、属性和交互作用，并通过多种视图全面描述特定系统的架构。</p><p>软件建构能够在设计变更相关容易的阶段考虑系统结构的可选方案，便于技术人员与非技术人员就软件设计进行交互，能够展现软件的结构、属性和内部交互关系。</p><p>软件架构是项目干系人进行交流的手段，明确了对系统实现的约束条件，决定了开发和维护组织的组织结构，制约着系统的质量属性。</p><p>软件架构使推理和控制的更改更加简单，有助于循序渐进的原型设计，可以作为培训的基础。</p><p>软件架构是可传递和可复用的模型，通过研究软件架构可以预测软件的质量。</p><h2 id="软件架构生命周期">软件架构生命周期</h2><ol><li><p>需求分析阶段</p><p>需求分析和SA设计面临的是不同对象，一个是问题空间，一个是解空间。从软件需求模型向SA模型的转换主要关注两个问题：如何根据需求模型构建SA模型；如何保证模型转换的可追踪性。</p></li><li><p>设计阶段</p><p>SA研究关注的最早和最多的阶段。这一阶段的SA主要研究：SA模型的描述、SA模型的设计与分析方法、对SA设计经验的总结和复用。（有关SA模型描述的研究主要分为三个层次：SA的基本概念；体系结构描述语言ADL、SA模型的多视图表示）</p></li><li><p>实现阶段</p><p>为了有效实现SA设计向实现的转换，实现阶段的研究主要表现在以下方面：</p><ul><li>研究基于SA的开发过程支持</li><li>寻求从SA向实现过渡的途径</li><li>研究基于SA的测试技术</li></ul></li><li><p>构件组装阶段</p><p>在SA设计模型的指导下，可复用构建的组装可以在较高层次上实现系统，并能够提高系统实现的效率。研究内容主要包括两方面</p><ul><li>如何支持可复用构件的互联</li><li>在组装过程中，如何检测并消除体系结构适配的问题。</li></ul></li><li><p>部署阶段</p><ul><li>提供高层的体系结构视图来描述部署阶段的软硬件模型</li><li>基于SA模型可以分析部署方案的质量属性，从而选择合理的部署方案</li></ul></li><li><p>后开发阶段</p><p>软件部署安装之后的阶段。这一阶段SA研究主要围绕维、演化、复用等方面。</p><ul><li>动态软件体系结构。</li><li>体系结构恢复与重建。</li></ul></li></ol><h2 id="构件">构件</h2><p>基本概念：</p><ul><li>构件是一个独立可交付的功能单元，外界通过接口访问其提供的服务</li><li>构件由一组通常需要同时部署的原子构件组成。<ul><li>一个原子构件就是一个模块儿和一组资源。</li><li>原子构件是部署、版本控制和替换的基本单位。</li></ul></li><li>构件和原子构件的区别：大多数原子构件永远都不会被单独部署，尽管可以被单独部署。大多数原子构件都属于一个构件家族，一次部署往往涉及到整个家族。</li><li>一个模块是不带单独资源的原子构件</li><li>一个单独的包被编译成多个单独的类的文件</li><li>模块是一组类和可能的非面向对象的结构体</li></ul><p>特点：</p><ul><li>独立部署单元</li><li>可作为第三方的组装单元</li><li>没有（外部的）可见状态</li></ul><p>一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。</p><p>构件接口：</p><p>接口标准化是对接口中的消息的格式、模式和协议的标准化。不是将接口格式化为参数化操作的集合，而是关注输入输出的消息的标准化。</p><p>面向构件的编程（COP）</p><ul><li>多态性（可替代性）</li><li>模块封装性（高层次信息的隐藏）</li><li>后期的绑定和装载（部署的独立性）</li><li>安全性（类型和模块安全性）</li></ul><p>构件技术</p><p>利用某种编程手段，将人们关心的但又不便于让最终用户直接操作的细节进行封装，同时对各种业务逻辑规则进行了实现。国际上常用构件标准的三大流派：</p><ol><li><p>EJB：实现应用中关键的业务逻辑，创建基于构件的企业级应用程序。</p><p>分别是：</p><ul><li>会话Bean</li><li>实体Bean</li><li>消息驱动Bean</li></ul></li><li><p>COM、DCOM、COM+</p></li><li><p>CORBA标准：主要分成三个层次</p><ul><li>对象请求代理：最底层的对象请求代理ORB，规定了分布对象的定义（接口）和语言映射，实现了对象间的通信和互操作，是分布对象系统中的“软总线”。</li><li>公共对象服务：在ORB之上定义了很多公共服务。</li><li>公共设施：最上层的公共设施则定义了组件框架，提供可直接为业务对象使用的服务，规定业务对象有效协作所需的协定规则。</li></ul></li></ol><h1>后记</h1><blockquote><p>俱怀逸兴壮思飞，欲上青天揽明月。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-12项目管理</title>
      <link href="/posts/1d301166.html"/>
      <url>/posts/1d301166.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>进度管理</li></ul><h1>中论</h1><p>略。改版以后不是重点，看看PPT看看定义、概念即可，计算不需要掌握。</p><h1>后记</h1><blockquote><p>世间浮云何足问，不如高卧且加餐。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-11.3设计模式</title>
      <link href="/posts/ebb747fb.html"/>
      <url>/posts/ebb747fb.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>设计模式</li></ul><h1>中论</h1><h2 id="设计模式">设计模式</h2><p>架构模式：软件设计中的高层决策，比如C/S架构、B/S架构就属于架构模式</p><p>设计模式：每一个设计模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。四个基本要素：模式名称、问题（应该在何时使用模式）、解决方案（设计的内容）、效果（模式应用的效果）</p><p>惯用法：最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。</p><h3 id="创建型设计模式">创建型设计模式</h3><p><img src="../image/post/image-20240522201130341.png" alt="image-20240522201130341"></p><h3 id="结构型设计模式">结构型设计模式</h3><p><img src="../image/post/image-20240522201146286.png" alt="image-20240522201146286"></p><h3 id="行为型设计模式">行为型设计模式</h3><p><img src="../image/post/image-20240522201204398.png" alt="image-20240522201204398"></p><p><img src="../image/post/image-20240522201213274.png" alt="image-20240522201213274"></p><h1>后记</h1><blockquote><p>欲买桂花同载酒，终不似，少年游。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-11.2统一建模语言UML</title>
      <link href="/posts/8f16b042.html"/>
      <url>/posts/8f16b042.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>统一建模语言UML</li></ul><h1>中论</h1><h2 id="统一建模语言UML">统一建模语言UML</h2><p>UML：一种可视化的建模语言，而非程序设计语言，支持从需求分析开始的软件开发的全过程。</p><p>UML主要包括三个部分</p><ul><li>构造块：UML有三种基本的构造块，事物、关系、图<ul><li>事物：重要组成部分</li><li>关系：把事物紧密联系在一起</li><li>图：多个互相关联的事物的集合</li></ul></li><li>公共机制：达到特定目标的公共UML方法</li><li>规则：构造块如何放在一起的规定</li></ul><hr><p><img src="../image/post/image-20240521201517664.png" alt="image-20240521201517664"></p><p>事物：</p><ul><li>结构事物：模型的静态部分，如接口、类、用例、构件等</li><li>行为事物：模型的动态部分，如交互、活动、状态机</li><li>分组事物：模型的组织部分，如包</li><li>注释事物：模型的解释部分，依附于一个元素或一个元素之上对其进行约束或解释的简单符号</li></ul><hr><p><img src="../image/post/image-20240521201749997.png" alt="image-20240521201749997"></p><p>关系：</p><ul><li>依赖：一个事物的语义依赖于另一个事物的语义的变化而变化</li><li>关联：一种结构关系，描述了一组链，链是对象之间的连接。分为组合和聚合，都是部分和整体的关系，其中组合事物之间关系更强。</li><li>泛化：一般/特殊的关系，子类和父类之间的关系</li><li>实现：一个类元指定了另一个类元保证执行的契约</li></ul><h3 id="UML2-0（了解即可）">UML2.0（了解即可）</h3><p><img src="../image/post/image-20240521202006298.png" alt="image-20240521202006298"></p><h3 id="类图">类图</h3><p>静态图，为系统的静态设计视图，展现一组对象、接口、协作和他们之间的关系</p><p><img src="../image/post/image-20240521202049719.png" alt="image-20240521202049719"></p><h3 id="对象图">对象图</h3><p>静态图，展现某一时刻一组对象及它们之间的关系，为类图的某一快照。</p><p><img src="../image/post/image-20240521202151965.png" alt="image-20240521202151965"></p><h3 id="用例图">用例图</h3><p>静态图，展现一组用例、参与者以及它们之间的关系。</p><p>用例之间的关系：扩展、包含、泛化</p><p><img src="../image/post/image-20240521202248969.png" alt="image-20240521202248969"></p><h3 id="序列图">序列图</h3><p>顺序图、动态图。是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。</p><p>有同步消息（实心三角箭头表示【阻塞调用、调用者中止执行、等待控制权返回、需要等待返回消息】）、异步消息（空心三角箭头表示【发出消息后继续执行、不引起调用者阻塞、不等待返回消息】）、返回消息（从右到左的虚线箭头表示）三种</p><p><img src="../image/post/image-20240521202438503.png" alt="image-20240521202438503"></p><h3 id="通信图">通信图</h3><p>动态图。即协作图，强调参加交互的对象的组织</p><p><img src="../image/post/image-20240521202618986.png" alt="image-20240521202618986"></p><h3 id="状态图">状态图</h3><p>动态图。以一个状态机的形式展现，描述单个对象在多个用例中的行为，包括简单状态和组合状态。转换可以通过事件触发器触发，事件触发后相应的监护条件会进行检查。</p><p>状态图中的转换和状态是两个独立的概念</p><p><img src="../image/post/image-20240521202746283.png" alt="image-20240521202746283"></p><h3 id="活动图">活动图</h3><p>动态图。特殊的状态图，展现一个系统内从一个活动到另一个活动的流程。活动的分岔和汇合线是一条水平粗线，每个分岔的分支数代表了可同时运行的线程数。</p><p>（牢记下图中并发分叉、并发汇合、监护表达式、分支、流等名词）</p><p><img src="../image/post/image-20240521202955588.png" alt="image-20240521202955588"></p><h3 id="构件图（组件图）">构件图（组件图）</h3><p>静态图。为系统静态实现视图，展现一组构件之间的组织和依赖</p><p><img src="../image/post/image-20240521203037125.png" alt="image-20240521203037125"></p><h3 id="部署图">部署图</h3><p>静态图。系统静态部署视图，部署图物理模块的节点分布。</p><p><img src="../image/post/image-20240521203118873.png" alt="image-20240521203118873"></p><h3 id="UML-4-1视图">UML 4+1视图</h3><ol><li>逻辑视图。逻辑视图也称为设计视图，它表示了设计模型在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。</li><li>进程视图。进程视图是可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。</li><li>实现视图。实现视图对组成基于系统的物理代码的文件和构件进行建模。</li><li>部署视图。部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。</li><li>用例视图。用例视图是最基本的需求分析模型。</li></ol><p><img src="../image/post/image-20240521203509262.png" alt="image-20240521203509262"></p><h1>后记</h1><blockquote><p>海到无边天作岸，山登绝顶我为峰。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-11.1面向对象基本概念-分析设计测试</title>
      <link href="/posts/70fa93ac.html"/>
      <url>/posts/70fa93ac.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>面向对象开发</li></ul><h1>中论</h1><h2 id="面向对象开发">面向对象开发</h2><p>对象：由数据以及操作所构成的封装体，系统中用来描述客观事物的一个实体。通常由对象名、属性和方法三部分组成。</p><p>类：实体的形式化描述。主要有三大类</p><ul><li>实体类：实体类对象表示现实世界中真实的实体</li><li>接口类（边界类）：为用户提供一种与系统合作交互的方式</li><li>控制类：用来控制活动流，充当协调者</li></ul><p>抽象：通过特定的实例抽取共同特征以后形成概念的过程，强调主要特征，忽略次要特征</p><p>封装：一种信息隐蔽技术</p><p>继承：类之间的层次关系</p><p>多态：不同对象收到同一个消息时产生完全不同的结果</p><p>接口：不同于接口类。描述对操作规范的说明，不定义操作如何做</p><p>消息：对象间的交互</p><p>覆盖：子类在原有父类的接口基础上，用适用于自己要求的实现去置换父类中相应实现</p><p>函数重载：无所谓子类父类，函数同名且参数不同</p><p>绑定：把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行，为静态绑定。在运行时进行，为动态绑定。</p><p><strong>面向对象的分析</strong></p><p>为了确定问题域，理解问题。</p><p>包含五个活动：认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息。</p><p><strong>面向对象需求建模</strong></p><p><img src="../image/post/image-20240520201029442.png" alt="image-20240520201029442"></p><p><strong>面向对象的设计</strong></p><p>设计分析模型和实现相应源代码</p><ul><li>面向对象的分析模型：顶层架构图、用例与用例图、领域概念模型</li><li>面向对象的设计模型：以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等</li></ul><p><img src="../image/post/image-20240520201258834.png" alt="image-20240520201258834"></p><p><strong>面向对象的设计原则</strong></p><ul><li>单一责任原则：一个类而言，有且仅有一个引起它变化的原因</li><li>开放-封闭原则：软件实体应该是可以扩展，但是不可修改的。</li><li>里式替换原则：子类必须能够替换掉他们的基类</li><li>依赖倒置原则：抽象不应该依赖于细节，细节应该依赖于抽象</li><li>接口分离原则：依赖于抽象，不依赖于具体。</li></ul><p><strong>面向对象软件的测试</strong></p><ul><li>算法层：测试类中定义的每个方法</li><li>类层：测试封装在同一个类中的所有方法与属性之间的相互作用</li><li>模板层：测试一组协同工作的类之间的相互作用</li><li>系统层：各个子系统组装成完整的面向对象设计软件，在组装的过程中进行测试</li></ul><h1>后记</h1><blockquote><p>是非入耳君须忍，半作痴呆半作聋。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-10.5系统转换-系统维护-净室软件工程-基于构件</title>
      <link href="/posts/11ed8ae4.html"/>
      <url>/posts/11ed8ae4.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>系统转换</li><li>系统维护</li><li>净室软件工程（CSE）</li><li>基于构件的软件工程（CBSE）</li></ul><h1>中论</h1><h2 id="系统转换">系统转换</h2><p><strong>遗留系统</strong></p><p>基本上不能进行修改和演化以满足新的变化的业务需求系统</p><p>特定：</p><ol><li>不能完全满足要求</li><li>技术过时</li><li>维护工作十分困难</li><li>基本上没有文档，很难理解</li></ol><p><strong>系统转换</strong></p><p>新系统开发完毕，投入运行，取代现有系统的过程，有以下三种转换计划：</p><ul><li>直接转换：现有系统被新系统直接取代了，风险很大，适用于新系统不复杂或者现有系统已经不能使用的情况</li><li>并行转换：新系统和老系统并行工作一段时间。缺点是耗费人力和时间资源，难以控制两个系统间的数据转换</li><li>分段转换：分期分批逐步转换，是直接和并行转换的集合，将大型系统分为多个子系统</li><li>数据转换与迁移：将数据从旧数据库迁移到新数据库中<ul><li>方法：系统切换前通过工具迁移、系统切换前采用手工录入、系统切换后通过新系统生成</li></ul></li></ul><h2 id="系统维护">系统维护</h2><p>系统的可维护性：维护人员理解、改正、改动和改进这个软件的难易程度</p><p>评价指标：</p><ul><li>易分析性</li><li>易改变性</li><li>稳定性</li><li>易测试性</li><li>维护性的依从性</li></ul><p>种类：</p><ul><li>硬件维护</li><li>软件维护<ul><li>正确性维护</li><li>适应性维护</li><li>完善性维护</li><li>预防性维护</li></ul></li><li>数据维护</li></ul><h2 id="净室软件工程（CSE）">净室软件工程（CSE）</h2><p>一种应用数据和统计学理论以经济的方式生产高质量软件的工程技术，力图通过严格的工程化的软件过程达到开发中的零缺陷或接近零缺陷。净室方法不是先制作一个产品，再去消除缺陷，而是要求在规约和设计中消除错误，然后以“净”的方式制作。</p><p>背后哲学：在第一次正确等书写代码增量，并在测试前验证正确性。提倡开发者不需要进行单元测试</p><p>理论基础：函数理论、抽样理论</p><p>应用技术手段：</p><ul><li>统计过程控制下的增量式开发</li><li>基于函数的规范与设计</li><li>正确性验证</li><li>统计测试和软件认证</li></ul><p>缺点：</p><ul><li>太过理论化</li><li>不进行传统的模块测试</li><li>有传统软件工程的弊端</li></ul><h2 id="基于构件的软件工程（CBSE）">基于构件的软件工程（CBSE）</h2><p>一种基于分布对象技术、强调通过可复用构件设计与构造软件系统的软件复用途径。</p><p>背后哲学：购买而不是重新构造，将软件开发的重点从程序编写转移到了基于已有构件的组装</p><p>特征：</p><ul><li>可组装性</li><li>可部署性</li><li>文档化</li><li>独立性</li><li>标准化</li></ul><p>模型要素：</p><ul><li>接口</li><li>使用信息</li><li>部署</li></ul><p>构建模型提供了一组被构件使用的通用服务，主要有两种</p><ul><li>平台服务，允许构件在分布式环境下通信和互操作</li><li>支持服务，构件需要的共性服务</li></ul><p><strong>CBSE过程</strong>：支持基于构件组装的软件开发过程。主要活动：系统需求概览；识别后选购件；根据发现的构件修改需求；体系结构设计；构件定制与适配；组装构件创建系统。</p><p>CBSE过程与传统软件开发过程的不同：</p><ul><li>CBSE早期需要完整的需求</li><li>CBSE早期阶段可以根据可利用的构件来细化和修改需求</li><li>在系统体系结构设计完成后，会有一个进一步的对构件搜索及设计精化的活动</li><li>CBSE开发就是将已经找到的构件集成在一起组装的过程</li></ul><p><strong>构建组装</strong></p><p>指构建相互直接集成或用专门编写的“胶水代码”整合在一起的过程</p><p>组装方式：</p><ul><li>顺序组装：按顺序调用已经存在的构件</li><li>层次组装：一个构件直接调用自另一个构件所提供的服务</li><li>叠加组装：两个或两个以上构件放在一起来创建一个新构建</li></ul><p>构件组装不兼容的情况（可以通过编写适配器解决）：</p><ul><li>参数不兼容</li><li>操作不兼容</li><li>操作不完备</li></ul><h1>后记</h1><blockquote><p>方生方死，方死方生。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-10.4测试原则-阶段-测试用例设计-调试</title>
      <link href="/posts/dfda8d83.html"/>
      <url>/posts/dfda8d83.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>测试原则和方法</li><li>测试阶段</li><li>测试用例的设计</li><li>调试</li><li>软件度量</li></ul><h1>中论</h1><h2 id="测试原则和方法">测试原则和方法</h2><p>系统测试：为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试</p><p><strong>测试原则：</strong></p><ul><li>尽早不断地测试</li><li>测试工作应避免由原开发软件的人或小组承担</li><li>设计测试方案时，不仅要确认输入数据，而且要根据系统功能确定预期的输出结果</li><li>即包含有效、合理的测试用例，也包含不合理、失效的用例</li><li>检验程序是否做了该做的事，且是否做了不该做的事</li><li>严格按照测试计划进行</li><li>妥善保存测试计划和测试用例</li><li>测试用户可以重复使用或追加测试</li></ul><p><strong>测试方法：</strong></p><ul><li><p>静态测试</p><ul><li>测试程序不在机器上运行，采用人工检测和计算机辅助静态分析的手段对程序进行检测。包括对文档的静态测试和对代码的静态测试；对文档的静态测试主要以检查单的形式进行，而对代码的静态测试：主要包括桌面检查、代码审查、代码审查的方法。</li></ul></li><li><p>动态测试</p><ul><li>黑盒测试：功能性测试，不了解代码软件结构，根据功能设计用例测试软件功能</li><li>白盒测试：结构性测试，明确代码流程，根据代码逻辑设计用例，进行用例覆盖</li></ul></li></ul><h2 id="测试阶段">测试阶段</h2><ul><li>单元测试：也叫模块测试，测试的对象是可独立编译或汇编的程序模块、软件构件或OO软件中的类，测试依据是软件详细设计说明书。</li><li>集成测试：检查模块之间，以及模块和已集成的软件之间的接口关系，并验证是否符合设计要求。测试依据是软件概要设计文档</li><li>确认测试：用于验证软件的功能、性能和其他特性是否与用户需求一致。<ul><li>内部确认测试：主要由软件开发组织内部按照SRS进行测试</li><li>阿尔法测试：用户在开发环境下测试</li><li>贝塔测试：用户在实际使用环境下测试</li><li>验收测试：针对SRS，在交付前以用户为主进行测试</li></ul></li><li>系统测试：测试对象是完整的、集成的计算机系统，测试依据是用户需求或开发合同</li><li>配置项测试：测试对象是软件配置项，测试依据是SRS</li><li>回归测试：测试目的：测试软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性。</li></ul><h2 id="测试用例的设计">测试用例的设计</h2><p>黑盒测试用例：</p><ul><li>等价类划分：把所有的数据按照某种特性分类，在每一类的数据里选取一个即可，等价类测试用例的设计原则：设计一个新的测试用例，使其尽可能多得覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其尽可能多得覆盖尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。</li><li>边界值划分：将每一类的边界值作为测试用例，边界值一般为范围的两端值以及在此范围之外的与此范围间隔最小的两个值。</li><li>错误推测：没有固定方法，全凭经验而言</li><li>因果图：由一个结果反推原因，没有固定方法</li></ul><p><strong>白盒测试用例</strong></p><p>覆盖级别从低到高：</p><ul><li>语句覆盖SC：逻辑代码中的所有语句都要被执行一遍，覆盖层级最低，执行了所有语句但并不代表执行了所有的条件判断</li><li>判定覆盖DC：逻辑代码中所有判断语句的条件的真假分支都要覆盖一次</li><li>条件覆盖CC：针对每一个判断条件内的每一个独立条件都要执行一遍真和假</li><li>条件判定组合覆盖CDC：同时满足判定覆盖和条件覆盖</li><li>路径覆盖：逻辑代码中的所有可行路径都被覆盖，覆盖层级最高</li></ul><h2 id="调试">调试</h2><p>测试：发现错误；调试：找出错误的代码和原因</p><p>调试需要确定错误的准确位置；确定问题的原因并设法改正；改正后要进行回归测试</p><p>调试的方法：蛮力法、回溯法、原因排除法</p><h2 id="软件度量">软件度量</h2><p>软件的两种属性</p><ul><li><p>外部属性：面向管理者和用户的属性，可直接测量，一般为性能指标</p></li><li><p>内部属性：软件产品本身的属性，如可靠性，只能间接测量</p></li><li><p>McCabe度量法：又称为环路复杂度。假设有向图中有向边数为m，节点数为n，则有向图的环路复杂度为<code>m+n-2</code></p><blockquote><p>对一个流程图来说，每一个分支边（连线）就是一条有向边，每一条语句（语句框）就是一个顶点/节点</p></blockquote></li></ul><h1>后记</h1><blockquote><p>不拟人间更求事，些些疏懒亦何妨。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-10.3处理流程设计-系统设计-人机界面设计</title>
      <link href="/posts/c7058d69.html"/>
      <url>/posts/c7058d69.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>处理流程设计</li><li>系统设计</li><li>人机界面设计</li></ul><h1>中论</h1><h2 id="处理流程设计">处理流程设计</h2><h3 id="流程表示工具">流程表示工具</h3><p><strong>程序流程图（PFD）</strong></p><p>用框图表示各种操作，独立于任何一张程序设计语言。</p><p><strong>IPO图</strong></p><p>流程描述工具，用来描述构成软件系统的每个模块的输入、输出和数据加工</p><p><strong>N-S图</strong></p><p>具有强烈的结构化特征，容易表示嵌套和层次关系。当问题很复杂时，N-S图会很大，不适合复杂程序设计</p><p><img src="../image/post/image-20240514203241531.png" alt="image-20240514203241531"></p><p><strong>问题分析图（PAD）</strong></p><p>一种支持结构化程序设计的图形工具。PAD具有清晰的逻辑结构、标准化的图形等优点，可以引导设计人员使用结构化程序的设计方法，从而提高程序的质量。</p><p><img src="../image/post/image-20240514203249915.png" alt="image-20240514203249915"></p><h3 id="业务流程重组BPR">业务流程重组BPR</h3><p>BPR是对企业的业务流程进行根本性的再思考和彻底性的再设计，从而获得可以用诸如成本、质量、服务和速度等方面的业绩来衡量的显著性成就。</p><p>基本原则：以流程为中心的原则；团队管理原则（以人为本）；以客户对导向的原则</p><h3 id="业务流程管理BPM">业务流程管理BPM</h3><p>BPM是一种以规范化的构造端到端的卓越业务流程为中心，以持续的提高组织业务绩效为目的的系统化方法。</p><blockquote><p>BPM和BPR的根本不同：BPM流程管理并不要求对所有的流程进行再造，而是根据现有流程的具体情况，对流程进行规范化的设计。</p></blockquote><p>流程管理包含三个方面：流程规范、优化流程和再造流程。</p><h2 id="系统设计">系统设计</h2><p>目的：最终勾画出新系统的详细设计方法</p><p>系统设计方法：结构化设计方法，面向对象设计方法</p><p>系统设计的主要内容：概要设计、详细设计</p><p>概要设计基本任务：形成软件的模块结构图（系统结构图）</p><p>详细设计基本任务：模块内详细算法设计、模块内数据结构设计、数据库的物理设计、其他设计、详细设计说明书</p><p><strong>系统设计基本原理</strong></p><ul><li>抽象化</li><li>自顶向下，逐步求精</li><li>信息隐蔽</li><li>模块独立（高内聚、低耦合）</li></ul><p><strong>系统设计原则</strong></p><ul><li><p>保持模块的大小适中</p></li><li><p>尽可能减少调用深度</p></li><li><p>多扇入，少扇出（扇入多/大，表示模块的复用程度高）</p><blockquote><p>扇入：直接调用该模块的上级模块的个数</p><p>扇出：该模块直接调用的下级模块的个数</p></blockquote></li><li><p>单入口，单出口</p></li><li><p>模块的作用域应该在模块之内</p></li><li><p>功能应该是可预测的</p></li></ul><p><strong>系统设计基本原理</strong></p><p>基本原理：抽象、模块化、信息隐蔽、模块独立</p><ul><li><p>高内聚（从低到高）</p><p><img src="../image/post/image-20240514204130558.png" alt="image-20240514204130558"></p></li><li><p>低耦合（从低到高）</p><p><img src="../image/post/image-20240514204144505.png" alt="image-20240514204144505"></p></li></ul><h2 id="人际界面设计三大黄金原则">人际界面设计三大黄金原则</h2><ul><li>置于用户控制之下</li><li>减少用户的记忆负担</li><li>保持界面的一致性</li></ul><h1>后记</h1><blockquote><p>世界上只要百分之一的人明白真相，剩下百分之九十九的人三观是被塑造的，他们只负责站队。————利弗莫尔</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-10.2需求工程-分析-获取-定义-验证-管理</title>
      <link href="/posts/1c8b6cf0.html"/>
      <url>/posts/1c8b6cf0.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>需求工程</li></ul><h1>中论</h1><h2 id="软件需求">软件需求</h2><p>软件需求：指用户在功能、行为、性能、设计约束等方面的期望。是用户解决问题或达到目标所需的条件或能力；是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力。</p><p><strong>分为需求开发和需求管理两大过程</strong></p><p><img src="../image/post/image-20240513210319424.png" alt="image-20240513210319424"></p><p>业务需求：反映企业或客户对系统高层次的目标要求</p><p>用户需求：用户的具体目标，或用户要求系统必须能完成的任务，描述了用户能使用系统来做什么</p><p>系统需求：从系统的角度来说明软件的需求</p><ul><li>功能需求：规定了开发人员必须在系统中实现的软件功能</li><li>非功能需求：系统必须具备的属性或品质</li><li>设计约束：对系统的一些约束说明</li></ul><h2 id="需求获取">需求获取</h2><p>需求获取：一个确定和理解不同的项目干系人的需求和约束的过程</p><p>常见的需求获取法</p><ul><li>用户访谈：</li><li>用户调查：</li><li>采样：</li><li>情节串联板：一系列图片，通过这些图片来讲故事</li><li>联合需求计划：联合各个关键用户代表、系统分析师、开发团队代表一起，通过有组织的会议来讨论需求</li><li>需求记录技术：任务卡片、场景说明、用户故事、Volere白卡</li></ul><h2 id="需求分析">需求分析</h2><p>一个好的需求必须具备无二义性、完整性、一致性、可测试性、确定性、可跟踪性、正确性、必要性等特征，因此需要分析人员把杂乱无章的用户要求和期望转化为用户需求。</p><p>需求分析的任务</p><ul><li>位置系统上下文范围关系图</li><li>创建用户界面原型</li><li>分析需求的可行性</li><li>确定需求的优先级</li><li>为需求建立模型</li><li>创建数据字典</li><li>使用QFD（质量功能部署）</li></ul><p><strong>结构化的需求分析</strong></p><p>结构化特点：自顶向下、逐步分解、面向数据</p><p>三大模型：功能模型（数据流图）、行为模型（状态转换图）、数据模型（E-R图）以及数据字典</p><p><img src="../image/post/image-20240513212528906.png" alt="image-20240513212528906"></p><p><strong>数据流图DFD</strong></p><p>基本图形元素：外部实体、加工、数据存储、数据流</p><p><img src="../image/post/image-20240513212624095.png" alt="image-20240513212624095"></p><ul><li>数据流：有一组固定成分的数据组成，表示数据的流向，在DFD中，数据流的流向必须经过加工</li><li>加工：描述了输入数据流到输出数据流之间的变换，数据流图中常见的三种错误：<ul><li>有输入但是没有输出：黑洞</li><li>有输出但是没有输入：奇迹</li><li>输入不足以产生输出：灰洞</li></ul></li><li>数据存储：存储数据</li><li>外部实体（外部主体）：存在于软件系统之外的人员或组织</li></ul><p><strong>数据字典DD</strong></p><p>数据流图描述了系统的分解，但没有对图中各成分进行说明。数据字典就是为数据流图中的每个数据流、文件、加工以及组成数据流或文件的数据项做出说明。</p><p>数据字典有四类条目：数据流、数据项、数据存储和基本加工</p><p><img src="../image/post/image-20240513213102189.png" alt="image-20240513213102189"></p><p>加工逻辑也被称为“小说明”，常用的加工逻辑：结构化语言、判定表和判定树</p><h2 id="需求定义">需求定义</h2><p>需求定义（软件需求规格说明书SRS）：是需求开发活动的产物，目的是使项目干系人和开发团队对系统的初始规定有一个共同的理解，使之成为整个开发工作的基础。</p><p><strong>需求定义方法</strong></p><ol><li>严格定义（预先定义）：需求的严格定义建立在以下的基本假设之上：所有的需求都能够被预先定义</li><li>原型方法：迭代的循环型开发方式，原型提供了克服该困难的一个手段</li></ol><h2 id="需求验证">需求验证</h2><p>也称为需求确认，目的是与用户一起确认需求无误</p><p>步骤：</p><ul><li>需求评审</li><li>需求测试</li></ul><p>需求验证通过后，要请用户签字确认，作为验收标准之一</p><h2 id="需求管理">需求管理</h2><p>定义需求基线：通过了评审的需求说明书就是需求基线，如果下次需要变更需求，就需要按照流程一步步执行。需求的流程及状态如下：</p><p><img src="../image/post/image-20240513213819438.png" alt="image-20240513213819438"></p><p>需求变更和风险：主要关心需求变更过程中的需求风险管理，带有风险的做法：无足够用户参与、忽略了用户分类、用户需求的不断增加、模棱两可的需求、不必要的特性、过于精简的SRS、不准确的估算。</p><p>变更产生的原因：外部环境的变化、需求和设计做的不够完整、新技术的出现、公司机构重组造成业务流程的变化</p><p>变更控制委员会CCB：也称为配置控制委员会。</p><p><strong>双向追踪，两个层次</strong></p><p><img src="../image/post/image-20240513214406193.png" alt="image-20240513214406193"></p><ul><li>正向追踪：表示用户原始需求是否都实现了</li><li>反向追踪：软件实现的是否都是用户要求的</li><li>若原始需求和用例有对应，则在对应栏中打对号，若某行都没有对号，表明原始需求未实现，正向追踪发现问题；若某列都没有对号，表明有多余功能用例，软件实现了多余功能，反向追踪发现问题</li></ul><h1>后记</h1><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-10.1软件工程-逆向工程</title>
      <link href="/posts/591e0511.html"/>
      <url>/posts/591e0511.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>软件工程概述</li><li>能力成熟度模型(CMM)</li><li>能力成熟度模型集成(CMMI)</li><li>软件过程模型</li><li>逆向工程</li></ul><h1>中论</h1><h2 id="软件工程概述">软件工程概述</h2><p><strong>软件开发生命周期</strong></p><p>软件定义时期：包括可行性研究和详细需求分析过程，任务是确定软件开发工程必须完成的总目标</p><p>软件开发时期：就是软件的设计和实现，分成概要设计、详细设计、编码、测试</p><p>软件运行和维护：把软件产品移交给用户使用</p><p><strong>软件系统的文档</strong></p><p>分为用户文档和系统文档</p><p>用户文档：描述系统功能和使用方法</p><p>系统文档：描述系统设计、实现和测试等各方面内容</p><p><strong>软件工程过程</strong></p><ol><li>P(Plan)————软件规格说明。规定软件的功能及其运行时的限制</li><li>D(Do)————软件开发。开发出满足规则说明的软件</li><li>C(Check)————软件确认。确认开发的软件能够满足用户的需求</li><li>A(Action)————软件演进。软件在运行过程中不断改进以满足客户新的需求</li></ol><p><strong>软件系统工具</strong></p><p>软件开发工具：需求分析工具、设计文档、编码与排错工具、测试工具</p><p>软件维护工具：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具</p><p>软件管理和软件支持工具：软件管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择</p><p><strong>软件设计的四个活动</strong></p><p>数据设计、架构（体系结构）设计、人机界面（接口）设计和过程设计</p><h2 id="能力成熟度模型-CMM">能力成熟度模型(CMM)</h2><p><img src="../image/post/image-20240509213702047.png" alt="image-20240509213702047"></p><h2 id="能力成熟度模型集成-CMMI">能力成熟度模型集成(CMMI)</h2><p>CMMI两种表示方法</p><ol><li>阶段性模型：</li></ol><p><img src="../image/post/image-20240509213822971.png" alt="image-20240509213822971"></p><ol start="2"><li>连续式模型：</li></ol><ul><li><p>瀑布模型（SDLC）：</p><p><img src="../image/post/image-20240509213947911.png" alt="image-20240509213947911"></p><p>特点：从上一项开发活动接受该项活动的工作对象作为输入；开发费用小的开发软件</p></li><li><p>螺旋模型：</p><p><img src="../image/post/image-20240509214107114.png" alt="image-20240509214107114"></p><p>特点：开发过程具有周期性重复的螺旋线状；四个象限分别标志每个周期所划分的四个阶段：指定计划、风险分析、实施工程和客户评估。螺旋模型强调<code>风险分析</code>，适用于庞大而复杂的、高风险系统。</p></li><li><p>原型化模型：</p><p>特点：实际可行；具有最终系统的基本特征；构造方便、快速、造价低；对用户的需求是动态响应、逐步纳入的。</p></li><li><p>增量模型：</p><p>特点：不是从系统整体角度规划各个模块，不利于模块划分；难点在于如何将客户需求划分为多个增量；增量模型的每一次增量版本都可以作为独立可操作的作品</p></li><li><p>喷泉模型：</p><p>特点：以用户需求为动力，以对象作为驱动的模型，适合面向对象的开发方法；开发过程具有迭代性和无间隙性</p></li><li><p>基于构件的开发模型CBSD：利用预先包装的构件来构造应用系统。增强了复用性</p></li><li><p>形式化方法模型：建立在严格的数学基础上的一种软件开发方法</p></li></ul><h2 id="软件过程模型">软件过程模型</h2><p><strong>敏捷模型</strong></p><p>开发宣言：个体和交互胜过过程和工具、可以工作的软件胜过面面俱到的文档、客户合作胜过合作谈判、响应变化胜过遵循计划</p><p>特点：适应性；面向人</p><p>核心思想：适应型而非可预测型；以人为本而非以过程为本；迭代增量式（以原型开发思想为基础，增量式开发，发行版本小型化）</p><p>主要敏捷方法：</p><ol><li>极限编程（XP）：交流、朴素、反馈和勇气。<ul><li>近螺旋式的开发方法，将复杂的开发过程分解为一个个相对比较简单的小周期</li><li>测试先行</li></ul></li><li>水晶系列方法：以人为中心；每个都包含独特的角色、过程模式、工作产品和时间</li><li>并列争球法：增量化过程；吧每段时间的一次迭代称为一个冲刺（Sprint），按需求的优先级别实现产品</li><li>特性驱动开发方法：要素：人、过程和技术。核心过程：开发整体对象模型、构造特征列表、计划特征开发、特征设计和特征构建。</li></ol><p><strong>统一过程模型(RUP)</strong></p><p>RUP主要描述了如何有效地利用商业的、可靠的方法开发和部署软件，是一种重量级过程。为所有方面和层次的程序开发提供指导方针、模板和实例支持。</p><p>RUP生命周期是一个二维的软件开发模型，有九个核心工作流</p><ul><li>业务建模</li><li>需求</li><li>分析与设计</li><li>实现</li><li>测试</li><li>部署</li><li>配置与变更管理</li><li>项目管理</li><li>环境</li></ul><p>RUP把软件开发生命周期划分为多个循环，每个循环生成产品的一个新版本，每个循环依次由四个连续的阶段组成</p><ul><li>初试阶段：定义最终产品视图和业务模型，并确定系统范围</li><li>细化阶段：设计及确定系统的体系结构，制订工作计划及资源要求</li><li>构造阶段：构造产品并继续演进需求、体系结构、计划直至产品提交</li><li>移交阶段：把产品提交给用户使用</li></ul><p>RUP定义了如下一些核心概念</p><ul><li>角色WHO</li><li>活动HOW</li><li>制品WHAT</li><li>工作流WHEN</li></ul><p>特点：</p><ul><li>用例驱动</li><li>以体系结构为中心。采用多个视图来描述<ul><li><img src="../image/post/image-20240509220548812.png" alt="image-20240509220548812"></li><li>分析人员和测试人员关心系统的行为，侧重用例视图</li><li>最终用户关心的是系统的功能，侧重逻辑视图</li><li>程序员关心系统配置、装配，侧重实现视图</li><li>系统集成人员关心系统的性能、可伸缩性、吞吐率等问题，侧重进程视图</li><li>系统工程师关心系统的发布、安装、拓扑结构等问题，侧重部署视图</li></ul></li><li>迭代与增量。把整个项目分为多个迭代过程。</li></ul><h2 id="逆向工程">逆向工程</h2><p><strong>软件复用</strong></p><p>将已有软件的各种有关知识用于建立新的软件，以缩减软件开发和维护的花费。早期的软件复用主要是代码级复用，后续扩大到包括领域知识、开发经验、设计决定、体系结构、需求、设计、代码和文档等一切有关方面。</p><p><strong>逆向工程</strong></p><p>软件的逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程，逆向工程是设计的恢复过程。</p><p>逆向工程的级别：</p><ul><li>实现级</li><li>结构级</li><li>功能级</li><li>领域级</li></ul><blockquote><p>领域级抽象级别最高，完备性最低，实现级抽象级别最低，完备性最高。</p></blockquote><p>相关概念：重构、设计恢复、再工程和正向工程</p><ul><li>重构：在同一抽象级别上转换系统描述形式</li><li>设计恢复：借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面信息</li><li>再工程：在逆向工程所获得信息的基础上，修改或重构已有的系统，产生一个新的版本。再工程是对现有系统的重新开发：包括逆向工程、新需求的考虑过程和正向工程三个步骤</li><li>正向工程：不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统，以改善其整体质量</li></ul><h1>后记</h1><blockquote><p>凭君莫话封侯事，一将功成万骨枯。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-9.3端口扫描-安全体系-网络安全技术和协议</title>
      <link href="/posts/9d8a9b00.html"/>
      <url>/posts/9d8a9b00.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li><p>信息摘要</p></li><li><p>数字签名</p></li><li><p>公钥基础设施PKI</p></li><li><p>访问控制</p></li><li><p>信息安全的抗攻击技术</p></li></ul><h1>中论</h1><h2 id="信息摘要">信息摘要</h2><p>信息摘要就是一段数据的特征信息，当数据发生了改变，信息摘要也会发生改变。</p><p>特点：无论数据多长，都会产生固定长度的信息摘要；不同内容的数据产生不同的信息摘要；只能由数据生成信息摘要，但是不能由信息摘要还原数据。</p><p>算法：MD5、SHA-1</p><h2 id="数字签名">数字签名</h2><p>唯一标识一个发送方。</p><p>过程：发送者发送数据时，使用发送者的私钥进行加密，接受者使用发送者的公钥解密，这样就能唯一确定发送方，也是数字签名的过程，但无法保证机密性。</p><h2 id="公钥基础设施PKI">公钥基础设施PKI</h2><p>以不对称密钥加密技术为基础，以数据机密性、完整性、身份认证、行为不可抵赖为安全目的，来实施和提供安全服务的具有普适性的安全基础设施。</p><ol><li>数字证书：有一个可信任的权威机构签署的信息集合</li><li>签证机构CA：负责签发证书、管理、撤销证书。任何机构可以用CA的公钥验证该证书的合法性。</li></ol><h2 id="访问控制">访问控制</h2><p>主体依据某些控制策略或权限对客体本身或是其资源进行的不同授权访问。包括三个要素：主体、客体和控制策略</p><p>方法：</p><ol><li>访问控制矩阵：通过矩阵形式表示访问控制规则和授权用户权限的方法</li><li>访问控制表：即访问控制矩阵的列（去掉空的单元格）</li><li>能力表：即访问控制矩阵的行（去掉空的单元格）</li><li>授权关系表：即去掉空单元格的访问控制矩阵</li></ol><h2 id="信息安全的抗攻击技术">信息安全的抗攻击技术</h2><p><strong>拒绝服务攻击（DOS攻击）：</strong></p><ul><li>内部用户：长时间占用系统内存、CPU处理时间，从而引起服务器无法接受其他请求服务</li><li>外部黑客：占用网络连接</li></ul><p>攻击模式：消耗资源、破坏或更改配置信息、物理破坏或改变网络部件、利用服务程序中的处理错误使服务失效</p><p>分布式拒绝服务DDOS：攻击者首先入侵并控制一些计算机，然后控制这些计算机同时向一个特定的目标发起拒绝服务攻击，这种攻击克服了传统DOS攻击受网络资源的限制和隐蔽性两大缺点。</p><p>防御方式：</p><ul><li>加强对数据包的特征识别</li><li>设置防火墙监视本地主机端口的使用情况</li><li>对通信数据量进行统计也可获得有关攻击系统的位置和数量信息</li><li>尽可能的修正已经发现的问题和系统漏洞</li></ul><p><strong>ARP欺骗</strong></p><p>正常ARP：主机A想知道局域网内主机B的MAC地址，就会广播发送ARP请求分组，局域网内主机都会收到，但只有B解析后知道是请求自己的MAC地址，所以B会响应A的广播。A收到响应分组以后，建立一个B的IP地址和MAC地址映射。</p><p>欺骗原理：攻击者C模拟返回格式，将自己的MAC地址发送给A，A将C的MAC和IP对应，这样A实际上给C发的消息</p><p>防范措施：</p><ul><li>固化ARP表</li><li>使用ARP服务器</li><li>采用双向绑定的方式</li><li>ARP防护软件–ARPGuard</li></ul><p><strong>DNS欺骗</strong></p><p>冒充域名解析服务器，把查询的IP地址设置为攻击者的IP地址，即用户访问的是攻击者的地址。</p><p>防范措施：</p><ul><li>被动监听检测：通过旁路监听的方式，如果一定的时间间隔内，一个请求对应两个或两个以上结果不同的应答包，则怀疑收到的了DOS欺骗</li><li>虚假报文探测：采用主动发送探测包的手段来检测，即像一个非DNS服务器发送请求包，正常不会收到应答包</li></ul><p><strong>IP欺骗</strong></p><p>原理：</p><ol><li>攻击者首先使主机B的网络暂时瘫痪，以免对攻击造成干扰</li><li>连接目标机A的某个端口猜测ISN基值以及增加规律</li><li>把源址地址伪装成被冒充主机B，发送带有SYN标志的数据段请求连接</li><li>等待目标机A发送SYN+ACK包给瘫痪主机</li><li>再次冒充主机B向主机A发送ACK，此时发送的数据段带有预测的目标机的ISN+1</li><li>攻击者和A建立连接，发送命令请求</li></ol><p>防范：</p><ul><li>删除UNIX中所有/etc/hosts.equiv、$HOME/.rhosts文件，修改/etc/inetd.conf文件</li><li>设置防火墙过滤来自外部但是信源地址却是内部IP的报文</li></ul><h1>后记</h1><blockquote><p>有勇气断舍离，就会匹配更好的人和事。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-9.2信息摘要-PKI-访问控制-DOS-欺骗技术</title>
      <link href="/posts/16c48eed.html"/>
      <url>/posts/16c48eed.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li><p>信息摘要</p></li><li><p>数字签名</p></li><li><p>公钥基础设施PKI</p></li><li><p>访问控制</p></li><li><p>信息安全的抗攻击技术</p></li></ul><h1>中论</h1><h2 id="信息摘要">信息摘要</h2><p>信息摘要就是一段数据的特征信息，当数据发生了改变，信息摘要也会发生改变。</p><p>特点：无论数据多长，都会产生固定长度的信息摘要；不同内容的数据产生不同的信息摘要；只能由数据生成信息摘要，但是不能由信息摘要还原数据。</p><p>算法：MD5、SHA-1</p><h2 id="数字签名">数字签名</h2><p>唯一标识一个发送方。</p><p>过程：发送者发送数据时，使用发送者的私钥进行加密，接受者使用发送者的公钥解密，这样就能唯一确定发送方，也是数字签名的过程，但无法保证机密性。</p><h2 id="公钥基础设施PKI">公钥基础设施PKI</h2><p>以不对称密钥加密技术为基础，以数据机密性、完整性、身份认证、行为不可抵赖为安全目的，来实施和提供安全服务的具有普适性的安全基础设施。</p><ol><li>数字证书：有一个可信任的权威机构签署的信息集合</li><li>签证机构CA：负责签发证书、管理、撤销证书。任何机构可以用CA的公钥验证该证书的合法性。</li></ol><h2 id="访问控制">访问控制</h2><p>主体依据某些控制策略或权限对客体本身或是其资源进行的不同授权访问。包括三个要素：主体、客体和控制策略</p><p>方法：</p><ol><li>访问控制矩阵：通过矩阵形式表示访问控制规则和授权用户权限的方法</li><li>访问控制表：即访问控制矩阵的列（去掉空的单元格）</li><li>能力表：即访问控制矩阵的行（去掉空的单元格）</li><li>授权关系表：即去掉空单元格的访问控制矩阵</li></ol><h2 id="信息安全的抗攻击技术">信息安全的抗攻击技术</h2><p><strong>拒绝服务攻击（DOS攻击）：</strong></p><ul><li>内部用户：长时间占用系统内存、CPU处理时间，从而引起服务器无法接受其他请求服务</li><li>外部黑客：占用网络连接</li></ul><p>攻击模式：消耗资源、破坏或更改配置信息、物理破坏或改变网络部件、利用服务程序中的处理错误使服务失效</p><p>分布式拒绝服务DDOS：攻击者首先入侵并控制一些计算机，然后控制这些计算机同时向一个特定的目标发起拒绝服务攻击，这种攻击克服了传统DOS攻击受网络资源的限制和隐蔽性两大缺点。</p><p>防御方式：</p><ul><li>加强对数据包的特征识别</li><li>设置防火墙监视本地主机端口的使用情况</li><li>对通信数据量进行统计也可获得有关攻击系统的位置和数量信息</li><li>尽可能的修正已经发现的问题和系统漏洞</li></ul><hr><p><strong>基于TCP/IP的拒绝服务攻击模式</strong></p><ul><li>同步包风暴（SYN Flooding）：利用TCP协议发送大量伪造的TCP连接请求，但不建立连接。消耗目标主机的资源</li><li>ICMP攻击：比如“Ping of Death”攻击利用操作系统规定的ICMP数据包的最大尺寸不超过64KB这一规定，使目标主机TCP/IP堆栈崩溃</li><li>SNMP攻击：重定向通信流，改变通信流数据包的优先级甚至断开通信。</li></ul><p>防御方法：</p><ul><li>同步包风暴（SYN Flooding）：修改注册表</li><li>ICMP攻击：修改注册表</li><li>SNMP攻击：基于网络的漏洞扫描、基于主机的漏洞扫描</li></ul><hr><p><strong>ARP欺骗</strong></p><p>正常ARP：主机A想知道局域网内主机B的MAC地址，就会广播发送ARP请求分组，局域网内主机都会收到，但只有B解析后知道是请求自己的MAC地址，所以B会响应A的广播。A收到响应分组以后，建立一个B的IP地址和MAC地址映射。</p><p>欺骗原理：攻击者C模拟返回格式，将自己的MAC地址发送给A，A将C的MAC和IP对应，这样A实际上给C发的消息</p><p>防范措施：</p><ul><li>固化ARP表</li><li>使用ARP服务器</li><li>采用双向绑定的方式</li><li>ARP防护软件–ARPGuard</li></ul><p><strong>DNS欺骗</strong></p><p>冒充域名解析服务器，把查询的IP地址设置为攻击者的IP地址，即用户访问的是攻击者的地址。</p><p>防范措施：</p><ul><li>被动监听检测：通过旁路监听的方式，如果一定的时间间隔内，一个请求对应两个或两个以上结果不同的应答包，则怀疑收到的了DOS欺骗</li><li>虚假报文探测：采用主动发送探测包的手段来检测，即像一个非DNS服务器发送请求包，正常不会收到应答包</li></ul><p><strong>IP欺骗</strong></p><p>原理：</p><ol><li>攻击者首先使主机B的网络暂时瘫痪，以免对攻击造成干扰</li><li>连接目标机A的某个端口猜测ISN基值以及增加规律</li><li>把源址地址伪装成被冒充主机B，发送带有SYN标志的数据段请求连接</li><li>等待目标机A发送SYN+ACK包给瘫痪主机</li><li>再次冒充主机B向主机A发送ACK，此时发送的数据段带有预测的目标机的ISN+1</li><li>攻击者和A建立连接，发送命令请求</li></ol><p>防范：</p><ul><li>删除UNIX中所有/etc/hosts.equiv、$HOME/.rhosts文件，修改/etc/inetd.conf文件</li><li>设置防火墙过滤来自外部但是信源地址却是内部IP的报文</li></ul><h2 id="端口扫描">端口扫描</h2><p>端口扫描就是尝试与目标主机的某些端口建立连接，如果目标端口有回复，则说明该端口开放。（为活动端口）</p><p>扫描原理种类</p><ul><li>全TCP连接：与目标计算机建立标准的TCP连接</li><li>半打开式扫描（SYN扫描）：向目标端口发送SYN数据段，如果目标计算机回应SYN=1 ACK=1，这说明端口是活动的；如果回应RST，则是死端口</li><li>FIN扫描：依靠发送FIN来判断。发送一个FIN=1的报文到一个关闭的端口时，端口会被丢掉并返回一个RST报文；如果发送到一个活动的端口，则不会返回报文。</li><li>第三方扫描：“代理扫描”。利用第三方主机代替入侵者进行扫描。</li></ul><p><strong>强化TCP/IP堆栈以抵御拒绝服务攻击</strong></p><p>见信息安全的抗攻击技术。</p><h2 id="信息安全的保证体系和评估方法">信息安全的保证体系和评估方法</h2><p>计算机系统安全保护能力的五个等级</p><ul><li>第一级 用户自主保护级。自主访问控制</li><li>第二级 系统审计保护级。自主访问控制的基础上控制访问权限扩散</li><li>第三级 安全标记保护级。强制访问控制</li><li>第四级 结构化保护级。强制访问控制，将第三级中的访问控制扩散到所有主体和客体</li><li>第五级 访问验证保护级。访问控制的粒度是单个用户</li></ul><p><strong>评估方法</strong></p><p>风险评估的基本要素：脆弱性、资产、威胁、风险和安全措施</p><h2 id="网络安全技术">网络安全技术</h2><p>**防火墙：**内网和外网之间增加的一道安全防护措施</p><ul><li><p>网络级防火墙：层次低，但效率高</p></li><li><p>应用级防火墙：层次高，但效率低</p></li></ul><p><strong>入侵检测系统IDS</strong></p><p>原理：监控当前系统/用户行为，使用入侵检测系统分析引擎进行分析</p><p>特点：是一个监听设备，没有跨接在任何链路上，无须网络流量流经就可以工作。但是需要挂接在所关注流量的必经的链路上。</p><ul><li>尽可能靠近攻击源</li><li>尽可能靠近受保护资源</li></ul><p><strong>入侵防御系统IPS</strong></p><p>特点：能够提前发现入侵行为，在其还没有进入安全网络之前就进行防御</p><p><strong>杀毒软件</strong></p><p>用于检测和解决计算机病毒</p><p><strong>蜜罐系统</strong></p><p>伪造一个蜜罐网络引用黑客攻击</p><h2 id="网络攻击和威胁（重点）">网络攻击和威胁（重点）</h2><p><img src="../image/post/image-20240508220046019.png" alt="image-20240508220046019"></p><h2 id="网络安全协议">网络安全协议</h2><p><img src="../image/post/image-20240508220215992.png" alt="image-20240508220215992"></p><p>SSL协议：安全套接字协议；HTTPS中的S，端口号为443</p><p>SSH协议：安全外壳协议，加强Telnet/FTP安全的传输协议</p><p>SET协议：安全电子交易协议，应用于B2C模型保障支付的信息安全，协议复杂；安全性高</p><p>Kerberos协议：网络身份认证协议。基于信任的第三方，提供开放型网络中进行身份认证的方法。</p><p>PGP协议：使用RSA公钥证书进行身份认证，使用IDEA进行数据加密，使用MD5进行数据完整性校验。</p><h1>后记</h1><blockquote><p>有勇气断舍离，就会匹配更好的人和事。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-9.1信息安全基础-加密技术</title>
      <link href="/posts/25d1f602.html"/>
      <url>/posts/25d1f602.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li><p>信息安全基础知识（重点）</p></li><li><p>信息安全系统的组成框架（了解）</p></li><li><p>信息安全技术-加密技术（了解）</p></li></ul><h1>中论</h1><h2 id="信息安全基础知识">信息安全基础知识</h2><p><strong>信息安全的基本要素</strong></p><ul><li>机密性：确保信息不暴露给未授权的实体或进程</li><li>完整性：只有得到许可才能修改数据，并且能够判别出数据是否已被篡改</li><li>可用性：得到授权的实体在需要时可访问数据，攻击者不能占用所有资源而阻碍授权者的工作</li><li>可控性：可以控制授权范围内的信息流向以及行为方式</li><li>可审查性：对出现的信息安全问题提供调查的依据和手段</li></ul><p><strong>信息安全的范围</strong></p><ul><li>设备安全：首要问题，是信息安全的物质基础，包括3个方面：设备的稳定性、可靠性、可用性</li><li>数据安全：采取措施确保数据免受未授权的泄露、篡改和毁坏，包括3个方面：数据的秘密性、完整性、可用性</li><li>内容安全：是信息安全在政治、法律、道德层次上的要求，包括3个方面：信息内容政治上的健康、符合国家法律法规、符合道德规范</li><li>行为安全：最终通过安全的行为提供给用户，包括3个方面：行为的秘密性、完整性、可控性</li></ul><p><strong>信息的存储安全</strong></p><ul><li>信息使用的安全</li><li>系统安装监控</li><li>计算机病毒防治</li><li>数据的加密</li><li>防止非法的攻击</li></ul><h2 id="信息安全系统的组成框架">信息安全系统的组成框架</h2><p>从实现技术上看：</p><ol><li>基础安全设备：包括密码芯片、加密卡、身份识别卡</li><li>计算机网络安全：信息在网络传输中的安全防范。包括防火墙及访问控制、加密传输、认证、数字签名、摘要、VPN等</li><li>操作系统安全：操作系统的无错误配置、无漏洞、无后门、无特洛伊木马</li><li>数据库安全：分为数据库管理系统安全和数据库应用系统安全。包括物理数据库的完整性、逻辑数据库的完整性、元素安全性、身份认证等</li><li>终端安全设备：包括电话密码机、传真密码机、异步数据密码机</li></ol><h2 id="信息安全技术-加密技术">信息安全技术-加密技术</h2><p><strong>加密技术</strong></p><ul><li>对称加密技术：数据的加密、解密的密钥是相同的，属于不公开密钥加密算法。<ul><li>缺点：加密强度不高，密钥分发困难。</li><li>优点：加密速度快，适合大数据加密。一般只有56位</li><li>常见算法：DES、3DES、AES、RC-5、IDEA</li></ul></li><li>非对称加密技术：数据的加密、解密的密钥不同，分为公钥和私钥。是公开密钥加密算法。公钥、私钥均为接受者配置，发送者使用公钥加密，接受者使用私钥解密，公钥可以明文发送给任何人，私钥不可。<ul><li>缺点：加密速度慢，无法保证数据完整性</li><li>优点：安全性高，不易破解。一般有1024位</li><li>常见算法：RSA、ECC、Elgamal、Rabin、D-H</li></ul></li><li>数字信封：对称加密技术和非对称加密技术的组合。使用<code>对称加密技术</code>加密<code>信息内容</code>，使用<code>非对称加密技术</code>加密<code>对称加密的密钥</code>。</li></ul><h1>后记</h1><blockquote><p>有趣的事物，不应该分享给敷衍的人。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-信息系统基础知识（下）</title>
      <link href="/posts/1904500e.html"/>
      <url>/posts/1904500e.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li><p>信息系统开发方法</p></li><li><p>各种信息系统（TPS、MIS等）</p></li><li><p>典型信息系统架构模型</p></li><li><p>信息化战略体系（重要）</p></li><li><p>信息化战略规划</p></li></ul><h1>中论</h1><h2 id="信息系统开发方法">信息系统开发方法</h2><ol><li><p>结构化方法</p><p>一种传统的信息系统开发方法。由结构化分析、结构化设计、结构化程序设计三部分组合而成，其精髓是自顶向下、逐步求精和模块化设计。</p><p>特点：</p><ul><li>开发目标清晰化</li><li>开发工作阶段化</li><li>开发文档规范化</li><li>设计方法结构化</li></ul><p>不足：</p><ul><li>开发周期长</li><li>难以适应需求变化：</li><li>很少考虑数据结构：主要面向数据流开发</li></ul><p>常用工具：</p><ul><li>数据流图、数据字典、结构化语言、判定表、判定树</li></ul></li><li><p>原型化方法</p><p>根据用户初步需求，利用系统开发工具，快速地建立一个系统模型展示给用户，并在此基础上与用户交流，最后实现系统</p><p>优点：</p><ul><li>系统开发周期短、成本和风险降低、速度加快、开发效益高</li><li>增加用户满意度、提高了系统开发的成功率</li><li>有利于系统移交、运行和维护</li></ul><p>不足：</p><ul><li>开发环境要求高</li><li>管理水平要求高</li></ul></li><li><p>面向对象法（OO）</p><p>优点：</p><ul><li>更好的复用性</li><li>普遍适用于各类信息系统的开发</li></ul><p>不足：</p><ul><li>必须依靠一定的面向对象技术的支持</li></ul><blockquote><p>当前一些大型信息系统的开发，通常将结构化方法和OO方法结合起来。首先使用结构化方法进行自顶向下的整体划分；然后自底向下地采用OO方法进行开发。</p></blockquote></li><li><p>面向服务法（SO）</p><p>进一步将接口的定义与实现进行及解耦的开发方法</p><p>优点：快速响应需求和环境变化、提高系统可复用性、信息资源共享和系统之间的互操作性</p></li></ol><h2 id="业务处理系统TPS">业务处理系统TPS</h2><p>即电子数据处理系统（EDP）。针对管理中的具体的事务来辅助管理人员将所发生的数据进行记录、传票、记账、统计和分类，并制成报表。</p><p>主要功能：对企业管理中的日常事务所发生的数据进行输入、处理和输出。</p><p>数据处理周期：数据输入–&gt;数据处理–&gt;数据库的维护–&gt;文件报表的生成–&gt;查询处理</p><ul><li>数据输入：大量原始数据准确、迅速的输入到计算机系统中并存储起来</li><li>数据处理：两种处理方式：批处理（定期处理）、联机事务处理（实时处理）</li><li>数据库维护：保证数据库中的数据是最新的</li><li>文件报表的产生：为终端用户提供所需的有关文件和报表</li><li>查询处理：支持终端用户的批次查询或联机实时查询</li></ul><p>特点：</p><p>TPS是其他类型信息系统的信息产生器，企业在推进全面信息化的过程中往往从开发TPS入手；处理企业系统的边界。</p><h2 id="管理信息系统MIS">管理信息系统MIS</h2><p>在TPS的基础上引进大量管理方法和对企业整体信息进行处理，并利用信息进行预测、控制、计划、辅助企业全面管理的信息系统</p><p>四大组成部件：</p><ul><li>信息源</li><li>信息处理器</li><li>信息用户</li><li>信息管理者</li></ul><p>结构：</p><ul><li>战略计划</li><li>管理控制</li><li>运行控制</li></ul><p>功能：</p><ul><li><p>用功能-过程结构表示</p><p><img src="../image/post/image-20240505095452699.png" alt="image-20240505095452699"></p></li><li><p>用功能-层次矩阵表示</p><p><img src="../image/post/image-20240505095629143.png" alt="image-20240505095629143"></p></li></ul><h2 id="客户关系管理CRM">客户关系管理CRM</h2><p>主要模块：</p><ul><li>销售自动化</li><li>营销自动化</li><li>客户服务与支持</li><li>商业智能</li></ul><p>功能：</p><ul><li>客户服务：CRM的关键内容</li><li>市场营销</li><li>共享的客户资料库</li><li>分析能力</li></ul><blockquote><p>市场营销和客户服务是CRM的支柱性功能</p></blockquote><p>具备要素：</p><ul><li>畅通有效的客户交流渠道</li><li>对所获信息进行有效分析</li></ul><p>实现过程：</p><ul><li>客户服务与支持</li><li>客户群维系</li><li>商机管理</li></ul><h2 id="供应链管理SCM">供应链管理SCM</h2><p>在满足服务水平要求的同时，为了使系统成本达到最低而采用的将供应商、制造商、仓库、商店有效地结合在一起来生产商品，有效地控制和管理各种信息流、资金流和物流，并把正确数量的商品在正确的时间配送到正确的地点的一套管理方法</p><p>特点：</p><ol><li>以客户为中心</li><li>集成化管理</li><li>扩展性管理</li><li>合作管理</li><li>多层次管理</li></ol><p>供应链节点：</p><ul><li>供应商</li><li>制造商</li><li>分销商</li><li>零售商</li><li>仓库</li><li>配送中心</li><li>客户</li></ul><p>基本内容：</p><ul><li>计划</li><li>采购</li><li>制造</li><li>配送</li><li>退货</li></ul><h2 id="决策支持系统DSS">决策支持系统DSS</h2><p>功能：能够为解决非结构化管理问题提供支持。</p><p>DDS的基本模式反映DSS的形式及其与“真实系统”、人和外部环境的关系，其中管理者处于核心地位</p><p>基本结构形式：（1）两库结构、（2）基于知识的结构。其中两库结构由数据库子系统、模型库子系统和对话子系统组成</p><p>特点：</p><ul><li>面向决策者</li><li>支持对半结构化问题的决策</li><li>辅助决策者、支持决策者</li><li>体现决策过程的动态性</li><li>提倡交互式处理方式</li></ul><p>组成：</p><ol><li>数据的重组和确认：获得正确地数据井并且可用理想的形式操作这些数据</li><li>数据字典的确立</li><li>数据挖掘和智能体：用户运用工具进行数据存取和查询，其中工具就是智能体</li><li>模型建立：目的就是帮助决策者理解与选择有关的现象</li></ol><h2 id="专家系统ES">专家系统ES</h2><p>即基于知识的专家系统</p><p>特点：</p><ul><li>人工智能范畴，求解半结构化或非结构化问题</li><li>模拟人类专家在问题领域的推理，而不是模拟问题领域本身</li><li>组成三要素：描述问题状态的综合数据库，存放启发式经验知识的知识库、对知识库的知识进行推理的推理机</li><li>专家系统处理的问题是实际问题</li><li>专用性强，通用性差</li></ul><blockquote><p>ES是人工智能的一个分支</p><p>AI的研究重点放在开发具有智能行为的计算机系统上</p><p>特点：</p><ul><li>从过去的事件或情形中汲取经验，并应用于新的环境和场景</li><li>具有在缺乏重要信息时的解决问题的能力</li><li>处理和操纵各种符号、理解形象化图片的能力</li><li>想象力和创造力</li><li>善于启发</li></ul></blockquote><p>专家系统的组成：</p><ul><li>综合数据库：1.执行与推理过程中存放所需要和产生的各种信息的工作存储器（动态知识库）2.专家系统的知识库（静态知识库）</li><li>知识库：用来存放系统求解实际问题的领域知识。1.事实性知识；2.启发性知识</li><li>推理机：包括推理机制和控制策略</li><li>知识获取：主要包含两方面：1.知识的编辑和求精；2.知识的自学习</li><li>解释程序：负责回答用户提出的各种问题</li><li>人机接口：主要包含两部分：1.专家系统和用户的接口；2.专家系统、领域专家和知识工程师的接口</li></ul><h2 id="办公自动化系统OAS">办公自动化系统OAS</h2><p>办公信息处理手段的自动化。</p><p>办公自动化系统的支柱：</p><ul><li>行为科学：主导</li><li>系统科学：理论基础</li><li>计算机技术：运用方法</li><li>通信技术：运用方法</li></ul><p>组成：</p><ul><li>计算机设备</li><li>办公设备</li><li>数据通信</li><li>网络设备</li><li>软件系统</li></ul><h2 id="企业资源规划ERP">企业资源规划ERP</h2><p>指建立在信息技术基础上，以系统化的管理思想，为企业提供决策和运营手段的管理平台。</p><blockquote><p>演变过程：</p><p>物料需求计划–&gt;制造资源计划–&gt;企业资源计划</p></blockquote><p>企业三大（四大）资源：</p><ul><li>物流：物理管理</li><li>资金流：财务管理</li><li>信息流：生产控制管理</li><li>（人力资源）</li></ul><p>结构：</p><ol><li>生产预测</li><li>销售管理</li><li>经营计划</li><li>主生产计划</li><li>物种需求计划</li><li>能力需求计划</li><li>车间作业计划</li><li>采购与库存管理</li><li>质量与设备管理</li><li>财务管理</li><li>ERP有关的扩展应用模块</li></ol><h2 id="典型信息系统架构模型">典型信息系统架构模型</h2><h3 id="政府信息化和政务">政府信息化和政务</h3><p>电子政务的内容：G2G、G2C、C2G、G2B、B2G</p><h3 id="企业信息化和电子商务">企业信息化和电子商务</h3><p>企业信息化就是技术和业务相融合，从三个层面实现</p><ul><li>企业战略层面。必须对企业目前的业务策略和未来的发展方向作深度分析</li><li>业务运作层面。针对企业战略，分析获得实现这些目标的关键驱动力和关键流程</li><li>管理运作层面。</li></ul><p>企业战略数据模型：</p><ul><li>数据库模型</li><li>数据仓库模型</li></ul><p>企业信息化方法：</p><ol><li>业务流程重构法</li><li>核心业务应用法</li><li>信息系统建设法</li><li>主题数据库法</li><li>资源管理法</li><li>人力资本投资法</li></ol><h2 id="信息化战略体系（重要）">信息化战略体系（重要）</h2><p><img src="../image/post/image-20240505103351615.png" alt="image-20240505103351615"></p><p>企业战略规划：利用机会和威胁评价现在和未来的环境，用优势和劣势评价企业的现状，进而选择和确定企业的总体和长远目标。</p><p>信息系统战略规划：如何通过信息系统来支撑业务流程的运作，进而实现企业的关键业务目标，重点在于对信息系统远景、组成架构、各部分逻辑关系进行规划。</p><p>信息计划战略规划：即IT战略规划，在信息系统规划的基础上，对支撑信息系统运行的硬件、软件、支撑环境等进行具体的规划，更关心技术层面的问题。</p><p>系统规划：单个项目的立项分析，是信息系统声明周期的第一个阶段。</p><h2 id="信息系统战略规划">信息系统战略规划</h2><p><img src="../image/post/image-20240505103829988.png" alt="image-20240505103829988"></p><p>一个企业信息系统的战略规划可分为上面三个阶段。</p><ul><li>第一阶段：以数据处理为核心，围绕职能部门需求<ul><li>企业系统规划法BSP</li><li>关键成功因素法CSF</li><li>战略集合转化法SST</li></ul></li><li>第二阶段：以企业内部MIS（管理信息系统）为核心，围绕企业整体需求<ul><li>战略数据规划法SDP</li><li>信息工程法IE</li><li>战略栅格法SG</li></ul></li><li>第三阶段：综合考虑企业内外环境，以集成为核心，围绕企业战略需求<ul><li>价值链分析法VCA</li><li>战略一致性模型SAM</li></ul></li></ul><h2 id="企业应用集成EAI">企业应用集成EAI</h2><p>特点：</p><ol><li>表示集成：即界面集成，是一种黑盒集成，将多个信息系统的界面集成在一起</li><li>数据集成：一种白盒集成，把不同来源、格式、特点性质的数据在逻辑上或者物理上有机的集中，从而为企业提供全面的数据共享</li><li>控制集成：一种黑盒集成，业务逻辑层次的集成</li><li>业务流程集成：一种过程集成，最彻底的、综合的集成</li></ol><p>应用集成的交换方式：</p><ul><li>共享数据库：让多个应用系统通过直接共享数据库的方式进行数据交换</li><li>消息传递：适用于数据量小，但要求频繁、立即、可靠、异步地数据交换</li><li>文件传输：一次性的传送大量信息，即时性低、交换频度小</li></ul><p>企业集成平台：</p><p>支持企业集成的支撑环境，包括硬件、软件、软件工具和系统。</p><p>基本功能：</p><ol><li>通信服务：提供分布式环境下透明的同步/异步通信服务功能，无需关心具体的操作系统和应用程序所处的网络物理位置</li><li>信息集成服务：为应用提供透明的信息访问服务</li><li>应用集成服务：通过高层应用编程接口来实现对相应应用程序的访问</li><li>二次开发工具：帮助用户开发特定应用程序的支持工具</li><li>平台运行管理工具：平台的运行管理和控制模块，负责企业集成平台系统的静态和动态配置、维护、管理。</li></ol><p>企业信息集成的划分：</p><ol><li>企业内部的集成内容：<ul><li>技术平台的集成</li><li>数据的集成</li><li>应用系统的集成</li><li>业务过程的集成</li></ul></li><li>企业外部的信息集成<ul><li>通过门户网站和互联网实现公众、社会团体、社会和客户的互动</li><li>通过与合作伙伴信息系统的对接，建立动态的企业联盟</li></ul></li></ol><h2 id="电子商务">电子商务</h2><p>参与电子商务的实体：</p><ul><li>顾客</li><li>商户</li><li>银行</li><li>认证中心</li></ul><p>模式：</p><ul><li>B2B</li><li>B2C</li><li>C2C</li><li>O2O</li></ul><h1>后记</h1><blockquote><p>才感春来忽至夏，灯与河川五月间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-信息系统基础知识（上）</title>
      <link href="/posts/a1b8376b.html"/>
      <url>/posts/a1b8376b.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>信息系统概述</li><li>信息系统声明周期</li></ul><h1>中论</h1><h2 id="信息系统概述">信息系统概述</h2><p>信息系统：以处理信息流为目的的人机一体化系统</p><p>基本功能：输入、存储、处理、输出和控制</p><blockquote><p>诺兰模型：信息系统进化的阶段模型</p><ol><li>初始阶段。只作为办公设备使用，应用非常少</li><li>传播阶段。盲目投入，效率低</li><li>控制阶段。<code>计算机管理变为数据管理的关键</code></li><li>集成阶段。建立基础数据库，建成统一的信息管理系统</li><li>数据管理阶段。使用统一平台，各部门、各系统基本实现资源整合和信息共享</li><li>成熟阶段。满足企业各个层次的需求</li></ol></blockquote><p>信息系统的分类（从低级到高级）</p><ol><li>业务（数据）处理系统（TPS/DPS）</li><li>管理信息系统（MIS）</li><li>决策支持系统（DSS）</li><li>专家系统（ES）</li><li>办公自动化系统（OAS）</li></ol><p><strong>企业中用到的信息化系统</strong></p><ul><li>ERP系统：管理公司各种资源</li><li>WMS系统：管理库房货位</li><li>MES系统：生产过程和过程中的防呆、自动化设备集成</li><li>PDM系统：管理研发阶段的物料、BOM、工程变更数据、负责产品数据为主</li></ul><h2 id="信息系统的生命周期">信息系统的生命周期</h2><p>产生–&gt;开发–&gt;运行–&gt;消亡</p><ul><li>产生：概念阶段或者是信息系统的需求分析阶段，主要有两个过程：概念的产生过程和需求分析过程</li><li>开发：<ul><li>总体规划阶段：基础是需求分析</li><li>系统分析阶段：为系统设计阶段提供系统的逻辑模型，是管理流程和信息流程的交汇点</li><li>系统设计阶段：设计出信息系统的实施方案</li><li>系统实施阶段：将设计阶段在计算机和网络上具体实现，该阶段的用户参与特别重要</li><li>系统验收阶段：系统试运行阶段</li></ul></li><li>运行：正式移交给用户</li><li>消亡：在信息系统建设的初期，企业就应当注意系统的消亡条件和时机</li></ul><h1>后记</h1><blockquote><p>教一个人学会批判思考的最佳方式————就是写作</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-7系统配置与性能评价</title>
      <link href="/posts/27338331.html"/>
      <url>/posts/27338331.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>性能指标</li><li>性能评价方法</li><li>阿姆达尔解决方案</li></ul><h1>中论</h1><h2 id="性能指标">性能指标</h2><p><strong>计算机</strong></p><ul><li>时钟频率（主频）</li><li>运算速度</li><li>运算精度</li><li>内存的存储容量</li><li>存储器的存取周期</li><li>数据处理速率PDR</li><li>吞吐率</li><li>各种响应时间</li><li>各种利用率</li><li>RASIS特性</li><li>平均故障响应时间</li><li>兼容性</li><li>可扩充性</li><li>性能价格比</li></ul><p><strong>路由器</strong></p><ul><li>设备吞吐量</li><li>端口吞吐量</li><li>丢包率</li><li>时延</li><li>时延抖动</li><li>VPN支持能力</li><li>…</li></ul><p><strong>交换机</strong></p><ul><li>…</li></ul><p><strong>网络</strong></p><ul><li>设备级性能指标</li><li>网络级性能指标</li><li>应用级性能指标</li><li>用户级性能指标</li><li>吞吐量</li></ul><p><strong>操作系统</strong></p><ul><li>系统的可靠性</li><li>系统的吞吐率（量）</li><li>系统响应时间</li><li>系统资源利用率</li><li>可移植性</li></ul><p><strong>数据库管理系统</strong></p><ul><li>数据库的大小</li><li>数据库中表的数量</li><li>单个表大小</li><li>表中允许的记录数</li><li>单个记录的大小</li><li>表上允许的索引数量</li><li>最大并发事务处理能力</li><li>负载均衡能力</li><li>最大连接数</li></ul><p><strong>WEB服务器</strong></p><ul><li>最大并发连接数</li><li>响应延迟</li><li>吞吐量</li></ul><h2 id="性能评价方法">性能评价方法</h2><p><strong>常用方法</strong></p><ol><li>时钟频率。频率越高，速度越快</li><li>指令执行速度。计量单位KIPS、MIPS</li><li>等效指令速度法。即固定比例法</li><li>数据处理速率。</li></ol><p><strong>基准程序法：把应用程序中用得对多、最频繁的那部分核心程序作为评价计算机性能的标准程序</strong></p><ol><li>整数测试程序。</li><li>浮点测试程序</li><li>SPEC基准程序</li><li>TPC基准程序<ol><li>TPC-C在线事务处理</li><li>TPC-D决策支持</li><li>TPC-E大型企业信息服务</li></ol></li></ol><blockquote><p>测评的准确程序：从高到低</p><p>真实的程序–&gt;核心程序–&gt;小型基准程序–&gt;合成基准程序</p></blockquote><h2 id="阿姆达尔解决方法">阿姆达尔解决方法</h2><p>公式：</p><p><img src="../image/post/image-20240504183627282.png" alt="image-20240504183627282"></p><blockquote><p>即总加速比 = （未增强的比例 + 增强的比例/加速比）的 倒数</p></blockquote><h1>后记</h1><blockquote><p>晒总会失去水分，藏才是保险的最好方式。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-调优篇（下）</title>
      <link href="/posts/1fdf4f1.html"/>
      <url>/posts/1fdf4f1.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><h2 id="命令行工具">命令行工具</h2><h3 id="jps：查看JVM统计信息">jps：查看JVM统计信息</h3><p>jps(Java Process Status):</p><p>显示指定系统内所有的HotSpot虚拟机进程(查看虚拟机进程信息)，可用于查询正在运行的虚拟机进程。</p><p>说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的。</p><h3 id="jinfo：实时查看和修改JVM配置参数">jinfo：实时查看和修改JVM配置参数</h3><p><img src="../image/post/image-20240504172818183.png" alt="image-20240504172818183"></p><p>java -XX:+PrintFlagsFinal：查看所有JVM参数的最终值</p><h3 id="jmap：导出内存映像文件-内存使用情况">jmap：导出内存映像文件&amp;内存使用情况</h3><p><img src="../image/post/image-20240504172829166.png" alt="image-20240504172829166"></p><h3 id="jstack：打印JVM中线程快照">jstack：打印JVM中线程快照</h3><p>jstack(JVM Stack Trace)：用于生成虚拟机指定进程当前时刻的线程快照(虚拟机堆栈跟踪)。 线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p><blockquote><p>在thread dump中，要留意下面几种状态</p><ul><li>死锁，Deadlock（重点关注）</li><li>等待资源，Waiting on condition（重点关注）<br>等待获取监视器，Waiting on monitor entry（重点关注）</li><li>阻塞，Blocked（重点关注）</li><li>执行中，Runnable</li><li>暂停，Suspended</li><li>对象等待中，Object.wait() 或 TIMED_WAITING</li><li>停止，Parked</li></ul></blockquote><h2 id="GUI工具">GUI工具</h2><p><strong>JDK自带的工具</strong><br>jconsole:JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等<br>位置：jdk\bin\jconsole.exe<br>Visual VM:Visual VM是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。<br>位置：jdk\bin\jvisualvm.exe<br>JMC:Java Mission Control，内置Java Flight Recorder。能够以极低的性能开销收集Java虚拟机的性能数据。<br><strong>第三方工具</strong><br>MAT: MAT(Memory Analyzer Tool)是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗<br>Eclipse的插件形式<br>JProfiler：商业软件，需要付费。功能强大。<br>与VisualVM类似<br>Arthas:Alibaba开源的Java诊断工具。深受开发者喜爱。<br>Btrace:Java运行时追踪工具。可以在不停机的情况下，跟踪指定的方法调用、构造函数调用和系统内存等信息。</p><h2 id="性能测试工具Jmeter">性能测试工具Jmeter</h2><h3 id="使用流程">使用流程</h3><ol><li>新增线程组</li><li>新增Jmeter元组</li><li>新增监视器</li><li>运行&amp;查看结果</li></ol><h1>面试题</h1><p><strong>你使用过Java虚拟机性能监控和故障处理工具吗？（美图）<br>怎么打出线程栈信息。（字节跳动）<br>JVM诊断调优工具用过哪些？ (京东)<br>怎么获取 Java 程序使用的内存？堆使用的百分比？（国美）<br>几种常用的内存调试工具你知道哪些？（搜狐）<br>JVM诊断调优工具用过哪些？ (蚂蚁金服)</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"></span><span class="strong">**JVM的进程有哪些线程启动，有了解吗？（神州租车）**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每当使用java命令执行一个带main方法的类时，就会启动JVM（应用程序），实际上就是在操作系统中启动一个JVM进程，JVM启动时，必然会创建以下5个线程：</p><p>1-main                     主线程，执行我们指定的启动类的main方法</p><p>2-Reference Handler        处理引用的线程</p><p>3-Finalizer                调用对象的finalize方法的线程，就是垃圾回收的线程</p><p>4-Signal Dispatcher        分发处理发送给JVM信号的线程</p><p>5-Attach Listener          负责接收外部的命令的线程</p><p>Attach Listener ：该线程是负责接收到外部的命令，执行该命令，并且把结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。</p><p>signal dispather： 前面我们提到第一个Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。</p><p>Finalizer：JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收。</p><p>Reference Handler ：它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题。</p><p>main：主线程，用于执行我们编写的java程序的main方法。</p><p>编写java应用程序查看JVM启动时创建的所有线程，代码如下：<br>package com.atguigu.java;</p><p>import java.lang.management.ManagementFactory;<br>import java.lang.management.ThreadInfo;<br>import java.lang.management.ThreadMXBean;</p><p>public class JVMTest {<br>　　public static void main(String[] args) throws Exception {<br>　　　　ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();<br>　　　　ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);<br>　　　　for(ThreadInfo threadInfo : threadInfos) {<br>　　　　　　System.out.println(threadInfo.getThreadId() + “-” + threadInfo.getThreadName());<br>　　　　}<br>　　}<br>}</p><hr><p>输出如下：</p><p>5-Attach Listener<br>4-Signal Dispatcher<br>3-Finalizer<br>2-Reference Handler<br>1-main</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**<span class="keyword">JVM的参数，你知道的说一下 </span>(百度)</span><br><span class="line">说说你知道的几种主要的<span class="keyword">JVM参数（京东）</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">JVM调优调的哪些参数？在哪里写这些参数？ </span>（亚信）</span><br><span class="line"> 内存调优参数都有什么？（顺丰）</span><br><span class="line"><span class="keyword">JVM调优调的哪些参数？问这样有什么好处？在哪里写这些参数（浪潮）**</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">这些参数可以被松散的聚合成三类：</span><br><span class="line">行为参数（<span class="keyword">Behavioral </span>Options）：用于改变<span class="keyword">jvm的一些基础行为；</span></span><br><span class="line"><span class="keyword"></span>性能调优（Performance Tuning）：用于<span class="keyword">jvm的性能调优；</span></span><br><span class="line"><span class="keyword"></span>调试参数（Debugging Options）：一般用于打开跟踪、打印、输出等<span class="keyword">jvm参数，用于显示jvm更加详细的信息；</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure><p>行为参数(功能开关)<br>-XX:-DisableExplicitGC  禁止调用System.gc()；但jvm的gc仍然有效<br>-XX:+MaxFDLimit 最大化文件描述符的数量限制<br>-XX:+ScavengeBeforeFullGC   新生代GC优先于Full GC执行<br>-XX:+UseGCOverheadLimit 在抛出OOM之前限制jvm耗费在GC上的时间比例<br>-XX:-UseConcMarkSweepGC 对老生代采用并发标记交换算法进行GC<br>-XX:-UseParallelGC  启用并行GC<br>-XX:-UseParallelOldGC   对Full GC启用并行，当-XX:-UseParallelGC启用时该项自动启用<br>-XX:-UseSerialGC    启用串行GC<br>-XX:+UseThreadPriorities    启用本地线程优先级</p><p>性能调优<br>-XX:LargePageSizeInBytes=4m 设置用于Java堆的大页面尺寸<br>-XX:MaxHeapFreeRatio=70 GC后java堆中空闲量占的最大比例<br>-XX:MaxNewSize=size 新生成对象能占用内存的最大值<br>-XX:MaxPermSize=64m 老生代对象能占用内存的最大值<br>-XX:MinHeapFreeRatio=40 GC后java堆中空闲量占的最小比例<br>-XX:NewRatio=2  新生代内存容量与老生代内存容量的比例<br>-XX:NewSize=2.125m  新生代对象生成时占用内存的默认值<br>-XX:ReservedCodeCacheSize=32m   保留代码占用的内存容量<br>-XX:ThreadStackSize=512 设置线程栈大小，若为0则使用系统默认值<br>-XX:+UseLargePages  使用大页面内存</p><p>调试参数<br>-XX:-CITime 打印消耗在JIT编译的时间<br>-XX:ErrorFile=./hs_err_pid<pid>.log 保存错误日志或者数据到文件中<br>-XX:-ExtendedDTraceProbes   开启solaris特有的dtrace探针<br>-XX:HeapDumpPath=./java_pid<pid>.hprof  指定导出堆信息时的路径或文件名<br>-XX:-HeapDumpOnOutOfMemoryError 当首次遭遇OOM时导出此时堆中相关信息<br>-XX:OnError=“<cmd args>;<cmd args>” 出现致命ERROR之后运行自定义命令<br>-XX:OnOutOfMemoryError=“<cmd args>;<cmd args>”  当首次遭遇OOM时执行自定义命令<br>-XX:-PrintClassHistogram    遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同<br>-XX:-PrintConcurrentLocks   遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同<br>-XX:-PrintCommandLineFlags  打印在命令行中出现过的标记<br>-XX:-PrintCompilation   当一个方法被编译时打印相关信息<br>-XX:-PrintGC    每次GC时打印相关信息<br>-XX:-PrintGC Details    每次GC时打印详细信息<br>-XX:-PrintGCTimeStamps  打印每次GC的时间戳<br>-XX:-TraceClassLoading  跟踪类的加载信息<br>-XX:-TraceClassLoadingPreorder  跟踪被引用到的所有类的加载信息<br>-XX:-TraceClassResolution   跟踪常量池<br>-XX:-TraceClassUnloading    跟踪类的卸载信息<br>-XX:-TraceLoaderConstraints 跟踪类加载器约束的相关信息</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-调优篇（中）</title>
      <link href="/posts/84a40413.html"/>
      <url>/posts/84a40413.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><h2 id="优化案例1：调整堆大小提高服务的吞吐量">优化案例1：调整堆大小提高服务的吞吐量</h2><p><strong>调整方法</strong></p><p>修改tomcatJVM配置。</p><p>生产环境下，Tomcat并不建议直接在catalina.sh里配置变量，而是写在与catalina同级目录（bin目录）下的setenv.sh里。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修改参数</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CATALINA_OPTS</span>=<span class="string">&quot;<span class="variable">$CATALINA_OPTS</span> -Xms120m&quot;</span></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CATALINA_OPTS</span>=<span class="string">&quot;<span class="variable">$CATALINA_OPTS</span> -XX:SurvivorRatio=8&quot;</span></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CATALINA_OPTS</span>=<span class="string">&quot;<span class="variable">$CATALINA_OPTS</span> -Xmx120m&quot;</span></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CATALINA_OPTS</span>=<span class="string">&quot;<span class="variable">$CATALINA_OPTS</span> -XX:+UseParallelGC&quot;</span></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CATALINA_OPTS</span>=<span class="string">&quot;<span class="variable">$CATALINA_OPTS</span> -XX:+PrintGCDetails&quot;</span></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CATALINA_OPTS</span>=<span class="string">&quot;<span class="variable">$CATALINA_OPTS</span> -XX:MetaspaceSize=64m&quot;</span></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CATALINA_OPTS</span>=<span class="string">&quot;<span class="variable">$CATALINA_OPTS</span> -XX:+PrintGCDateStamps&quot;</span></span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CATALINA_OPTS</span>=<span class="string">&quot;<span class="variable">$CATALINA_OPTS</span> -Xloggc:/opt/tomcat8.5/logs/gc.log&quot;</span></span><br></pre></td></tr></table></figure><h2 id="性能优化案例2：JVM优化之JIT优化">性能优化案例2：JVM优化之JIT优化</h2><p><strong>堆，是分配对象的唯一选择吗</strong></p><p>如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><h3 id="前提：逃逸分析">前提：逃逸分析</h3><blockquote><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></blockquote><p>逃逸分析包括：</p><ul><li>全局变量赋值逃逸</li><li>方法返回值逃逸</li><li>实例引用发生逃逸</li><li>线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量</li></ul><p><strong>参数设置</strong></p><p>在JDK 6u23版本之后，HotSpot中默认就已经开启了逃逸分析。<br>如果使用的是较早的版本，开发人员则可以通过：<br>通过选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析<br>通过选项“-XX：+PrintEscapeAnalysis”查看逃逸分析的筛选结果。</p><p><strong>逃逸分析存在的问题</strong></p><p>是无法保证非逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p><h3 id="方法：栈上分配">方法：栈上分配</h3><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><h3 id="方法：同步省略（消除）">方法：同步省略（消除）</h3><p>同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li><li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</li></ul><h3 id="方法：标量替换">方法：标量替换</h3><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><blockquote><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p></blockquote><p>如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><p><strong>参数设置</strong></p><p>参数-XX:+EliminateAllocations：开启了标量替换(默认打开)，允许将对象打散分配在栈上。</p><h2 id="性能优化案例3：合理配置堆内存">性能优化案例3：合理配置堆内存</h2><p><strong>堆大小设置原则</strong></p><p>Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍。<br>方法区（永久代 PermSize和MaxPermSize 或 元空间 MetaspaceSize 和 MaxMetaspaceSize）设置为老年代存活对象的1.2-1.5倍。<br>年轻代Xmn的设置为老年代存活对象的1-1.5倍。<br>老年代的内存大小设置为老年代存活对象的2-3倍。</p><p><strong>如何计算老年代存活对象</strong></p><ol><li><p>JVM参数中添加GC日志，GC日志中会记录每次FullGC之后各代的内存大小，观察老年代GC之后的空间大小。可观察一段时间内（比如2天）的FullGC之后的内存情况，根据多次的FullGC之后的老年代的空间大小数据来预估FullGC之后老年代的存活对象大小（可根据多次FullGC之后的内存大小取平均值）。</p></li><li><p>强制触发一次FullGC，来观察FullGC之后的老年代存活对象大小。</p><ul><li>如何强制触发Full GC?<ul><li>jmap -dump:live,format=b,file=heap.bin &lt;pid&gt; 将当前的存活对象dump到文件，此时会触发FullGC</li><li>jmap -histo:live <pid> 打印每个class的实例数目,内存占用,类全名信息.live子参数加上后,只统计活的对象数量. 此时会触发FullGC</li><li>在性能测试环境，可以通过Java监控工具来触发FullGC，比如使用VisualVM和JConsole，VisualVM集成了JConsole，VisualVM或者JConsole上面有一个触发GC的按钮</li></ul></li></ul></li></ol><p><strong>新生代与老年代的比例</strong></p><p>JDK 1.8 默认使用 UseParallelGC 垃圾回收器，该垃圾回收器默认启动了 AdaptiveSizePolicy，会根据GC的情况自动计算计算 Eden、From 和 To 区的大小；所以这是由于JDK1.8的自适应大小策略导致的</p><blockquote><p>开启：-XX:+UseAdaptiveSizePolicy</p><p>关闭：-XX:-UseAdaptiveSizePolicy</p><p>如果不想动态调整内存大小，以下是解决方案：</p><p>1、保持使用 UseParallelGC，显式设置 -XX:SurvivorRatio=8。</p><p>2、使用 CMS 垃圾回收器。CMS 默认关闭 AdaptiveSizePolicy。配置参数 -XX:+UseConcMarkSweepGC</p></blockquote><h2 id="性能优化案例4：CPU占用很高排查方案">性能优化案例4：CPU占用很高排查方案</h2><p><strong>排查方案</strong></p><p>方案一：</p><ol><li>首先查看java进程ID</li><li>根据进程 ID 检查当前使用异常线程的pid</li><li>把线程pid变为16进制如 31695 -&gt; 7bcf  然后得到0x7bcf</li><li>jstack 进程的pid | grep -A20  0x7bcf  得到相关进程的代码 (鉴于我们当前代码量比较小，线程也比较少，所以我们就把所有的信息全部导出来)</li><li>jps -l。 # 查看所有java进程 ID</li><li>top -Hp 1456。 # 根据进程 ID 检查当前使用异常线程的pid</li></ol><p>方案二</p><p>1-3同上</p><ol start="4"><li>ps aux | grep java  查看到当前java进程使用cpu、内存、磁盘的情况获取使用量异常的进程</li><li>top -Hp 进程pid  检查当前使用异常线程的pid</li><li>把线程pid变为16进制如 31695 - 》 7bcf  然后得到0x7bcf</li><li>jstack 进程的pid | grep -A20  0x7bcf  得到相关进程的代码</li></ol><h2 id="性能优化案例5：G1并发执行的线程数对性能的影响">性能优化案例5：G1并发执行的线程数对性能的影响</h2><p>对于G1GC来说，增加线程数之后，我们的请求的平均响应时间和GC时间都有一个明显的减少了，仅从效果上来看，我们这次的优化是有一定效果的。大家在工作中对于线上项目进行优化的时候，可以考虑到这方面的优化。</p><h2 id="性能优化案例6：调整垃圾回收器提高服务的吞吐量">性能优化案例6：调整垃圾回收器提高服务的吞吐量</h2><p>略</p><h2 id="性能优化案例7：日均百万级订单交易系统如何设置JVM参数">性能优化案例7：日均百万级订单交易系统如何设置JVM参数</h2><p>一天百万级订单这个绝对是现在顶尖电商公司交易量级，百万订单一般在4个小时左右产生，我们计算一下每秒产生多少订单，3000000/3600/4 = 208.3单/s，我们大概按照每秒300单来计算。</p><p><img src="../image/post/image-20240504163657635.png" alt="image-20240504163657635"></p><p>种系统我们一般至少要三四台机器去支撑，假设我们部署了三台机器，也就是每台每秒钟大概处理完成100单左右，也就是每秒大概有100个订单对象在堆空间的新生代内生成，一个订单对象的大小跟里面的字段多少及类型有关，比如int类型的订单id和用户id等字段，double类型的订单金额等，int类型占用4字节，double类型占用8字节，初略估计下一个订单对象大概1KB左右，也就是说每秒会有100KB的订单对象分配在新生代内。</p><p>真实的订单交易系统肯定还有大量的其他业务对象，比如购物车、优惠券、积分、用户信息、物流信息等等，实际每秒分配在新生代内的对象大小应该要再扩大几十倍，我们假设20倍，也就是每秒订单系统会往新生代内分配近2M的对象数据，这些数据一般在订单提交完的操作做完之后基本都会成为垃圾对象。</p><p>假设我们选择4核8G的服务器，就可以给JVM进程分配四五个G的内存空间，那么堆内存可以分到三四个G左右，于是可以给新生代至少分配1G，这样算下差不多需要10分钟左右才能把新生代放满触发minor gc，这样的GC频率我们是可以接受的。我们还可以继续调整young区大小。不一定是1:2，这样就可以降低GC频率。这样进入老年代的对象也会降低，减少Full GC频率。</p><p><img src="../image/post/image-20240504163711819.png" alt="image-20240504163711819"></p><p>如果系统业务量继续增长那么可以水平扩容增加更多的机器，比如五台甚至十台机器，这样每台机器的JVM处理请求可以保证在合适范围，不至于压力过大导致大量的gc。</p><p>假设业务量暴增几十倍，在不增加机器的前提下，整个系统每秒要生成几千个订单，之前每秒往新生代里分配的1M对象数据可能增长到几十M，而且因为系统压力骤增，一个订单的生成不一定能在1秒内完成，可能要几秒甚至几十秒，那么就有很多对象会在新生代里存活几十秒之后才会变为垃圾对象，如果新生代只分配了几百M，意味着一二十秒就会触发一次minor gc，那么很有可能部分对象就会被挪到老年代，这些对象到了老年代后因为对应的业务操作执行完毕，马上又变为了垃圾对象，随着系统不断运行，被挪到老年代的对象会越来越多，最终可能又会导致full gc，full gc对系统的性能影响还是比较大的。</p><h1>面试题</h1><p><strong>常用的性能优化方式有哪些？（百度金融）<br>虚拟机如何调优？（顺丰）<br>内存调优怎么调？有几种方式？（顺丰）<br>栈溢出导致的原因？如何解决？（搜狐）<br>JVM调优策略 （杭州鲁尔物联科技有限公司、燕梭金融、汇博云通）<br>如何优化减少Full GC？（阿里-闲鱼）<br>当出现了内存溢出，你怎么排错。  (京东)<br>有实际的JVM性能调优案例吗？重点需要关注哪些核心参数？  (滴滴)<br>OOM说一下？怎么排查？哪些会导致OOM? OOM出现在什么时候 (腾讯)<br>JVM性能调优都做了什么？(支付宝)<br>有做过JVM内存优化吗？ (小米)<br>JVM的编译优化 (蚂蚁金服)<br>JVM性能调优都做了什么  (蚂蚁金服)<br>JVM怎样调优，堆内存栈空间设置多少合适…  (蚂蚁金服)<br>JVM相关的分析工具使用过的有哪些？具体的性能调优步骤如何  (蚂蚁金服)<br>如何进行JVM调优？有哪些方法？ (阿里)<br>JVM如何调优、参数怎么调？ (字节跳动)<br>每秒几十万并发的秒杀系统为什么会频繁发生GC？  (京东)<br>日均百万级交易系统如何优化JVM？  (京东)<br>线上生产系统OOM如何监控及定位与解决？  (京东)<br>高并发系统如何基于G1垃圾回收器优化性能？ (京东)</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"></span><span class="strong">**12306遭遇春节大规模抢票如何支撑？**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>12306号称是国内并发量最大的秒杀网站，并发量达到百万级别。</p><p>普通电商订单–&gt;  下单 --&gt; 订单系统（IO）减库存 --&gt; 等待用户付款</p><p>12306一种可能的模型：下单 --&gt; 减库存和订单（redis、kafka）同时异步进行 --&gt; 等付款<br>但减库存最后还会把压力压到一台服务器上。如何？</p><p>分布式本地库存+单独服务器做库存均衡！</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**有一个50万PV的资料类网站（从磁盘提取文档到内存）原服务器是32位的，1.5G的堆，用户反馈网站比较缓慢。因此公司决定升级，新的服务器为64位，16G的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了！**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>为什么原网站慢？<br>频繁的GC,STW时间比较长，响应时间慢！</p></li><li><p>为什么会更卡顿？<br>内存空间越大，FGC时间更长，延迟时间更长</p></li><li><p>咋办？</p></li></ol><blockquote><p>垃圾回收器：parallel GC ;  ParNew + CMS ; G1<br>配置GC参数：-XX:MaxGCPauseMillis 、 -XX:ConcGCThreads<br>根据log日志、dump文件分析，优化内存空间的比例<br>jstat   jinfo  jstack  jmap</p></blockquote><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**系统CPU经常100%，如何调优？（面试高频）**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（同 性能优化案例4：CPU占用很高排查方案）<br>CPU100%的话，一定是有线程占用系统资源。具体步骤前面已经讲过。<br>注意： 工作中有时候是工作线程100%占用了CPU，还有可能是垃圾回收线程占用了100%</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**系统内存飙高，如何查找问题？（面试高频）**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一方面：jmap -heap 、jstat 、… ; gc日志情况<br>另一方面：dump文件分析</p><pre><code>**如何监控JVM**<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">命令行工具</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">图形化界面工具</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-6计算机其他基础知识</title>
      <link href="/posts/3ebaca61.html"/>
      <url>/posts/3ebaca61.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>主要和系统工程相关（几乎不考）</li></ul><h1>中论</h1><p>略</p><p>相关资料见PPT<code>6、其他计算机系统基础知识</code></p><h1>后记</h1><blockquote><p>有些事情只能做给自己看，做给别人看的是表演。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-调优篇（上）</title>
      <link href="/posts/b9419394.html"/>
      <url>/posts/b9419394.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><h2 id="案例篇章-OOM">案例篇章-OOM</h2><h3 id="堆溢出">堆溢出</h3><p><strong>报错信息</strong></p><p>java.lang.OutOfMemoryError: Java heap space</p><p><strong>JVAM参数配置</strong></p><p>-XX:+PrintGCDetails -XX:MetaspaceSize=64m -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=heap/heapdump.hprof -XX:+PrintGCDateStamps -Xms200M  -Xmx200M  -Xloggc:log/gc-oomHeap.log</p><p><strong>原因及解决方案</strong></p><ul><li>原因<ul><li>代码中可能存在大对象分配</li><li>可能存在内存泄漏，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对</li></ul></li><li>解决方法<ul><li>检查是否存在大对象的分配，最有可能的是大数组分配</li><li>通过jmap命令，把堆内存dump下来，使用MAT等工具分析一下，检查是否存在内存泄漏的问题</li><li>如果没有找到明显的内存泄漏，使用 -Xmx 加大堆内存</li><li>还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性</li></ul></li></ul><h3 id="元空间溢出">元空间溢出</h3><p><strong>报错信息</strong></p><p>java.lang.OutOfMemoryError: Metaspace</p><p><strong>参数配置</strong></p><p>-XX:+PrintGCDetails -XX:MetaspaceSize=60m -XX:MaxMetaspaceSize=60m -Xss512K -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap/heapdumpMeta.hprof  -XX:SurvivorRatio=8 -XX:+TraceClassLoading -XX:+TraceClassUnloading -XX:+PrintGCDateStamps  -Xms60M  -Xmx60M -Xloggc:log/gc-oomMeta.log</p><p><strong>原因及解决方案</strong></p><p>JDK8后，元空间替换了永久代，元空间使用的是本地内存</p><ul><li><p>原因</p><ul><li>运行期间生成了大量的代理类，导致方法区被撑爆，无法卸载</li></ul><ol start="2"><li>应用长时间运行，没有重启</li><li>元空间内存设置过小</li></ol></li><li><p>解决方案</p><ul><li>检查是否永久代空间或者元空间设置的过小</li></ul><ol start="2"><li>检查代码中是否存在大量的反射操作</li><li>dump之后通过mat检查是否存在大量由于反射生成的代理类</li><li>如果加载同一个代理类即可，可以创建对象以后调用对象的<code>setUseCache(true)</code>方法，</li></ol><blockquote><p>选择为true的话，使用和更新一类具有相同属性生成的类的静态缓存，而不会在同一个类文件还继续被动态加载并视为不同的类，这个其实跟类的equals()和hashCode()有关，它们是与cglib内部的class cache的key相关的。</p></blockquote></li></ul><h3 id="GC-overhead-limit-exceeded">GC overhead limit exceeded</h3><p><strong>报错信息</strong></p><p>GC overhead limit exceeded</p><p><strong>原因及解决方案</strong></p><ul><li>原因<ul><li><strong>超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常</strong>，本质是一个预判性的异常，抛出该异常时系统没有真正的内存溢出。</li></ul></li><li>解决方案<ul><li>检查项目中是否有大量的死循环或有使用大内存的代码，优化代码</li><li>添加参数 <code>-XX:-UseGCOverheadLimit</code> 禁用这个检查，其实这个参数解决不了内存问题，只是把错误的信息延后，最终出现 java.lang.OutOfMemoryError: Java heap space</li><li>dump内存，检查是否存在内存泄漏，如果没有，加大内存</li></ul></li></ul><h3 id="线程溢出">线程溢出</h3><p><strong>报错信息</strong></p><p>java.lang.OutOfMemoryError : unable to create new native Thread</p><p><strong>原因及解决方案</strong></p><ul><li><p>原因</p><ul><li><p>出现这种异常，基本上都是创建了大量的线程导致的</p></li><li><p>正常情况下，在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右</p></li><li><p>能创建的线程数的具体计算公式如下：<br>(MaxProcessMemory - JVMMemory - ReservedOsMemory) / (ThreadStackSize) = Number of threads</p><blockquote><p>MaxProcessMemory 指的是进程可寻址的最大空间<br>JVMMemory     JVM内存<br>ReservedOsMemory 保留的操作系统内存<br>ThreadStackSize   线程栈的大小</p></blockquote></li><li><p>在Java语言里， 当你创建一个线程的时候，虚拟机会在JVM内存创建一个Thread对象同时创建一个操作系统线程，而这个系统线程的内存用的不是JVMMemory，而是系统中剩下的内存(MaxProcessMemory - JVMMemory - ReservedOsMemory)。</p></li><li><p>由公式得出结论：你给JVM内存越多，那么你能创建的线程越少，越容易发生java.lang.OutOfMemoryError: unable to create new native thread</p></li></ul></li><li><p>解决方案</p><ul><li><p>如果程序中有bug，导致创建大量不需要的线程或者线程没有及时回收，那么必须解决这个bug，修改参数是不能解决问题的。</p></li><li><p>如果程序确实需要大量的线程，现有的设置不能达到要求，那么可以通过修改MaxProcessMemory，JVMMemory，ThreadStackSize这三个因素，来增加能创建的线程数。</p><ul><li>MaxProcessMemory 使用64位操作系统</li><li>JVMMemory  减少JVMMemory的分配</li><li>ThreadStackSize 减小单个线程的栈大小</li></ul><blockquote><p>经实测，在32位windows系统下较为严格遵守；64位系统下只能保证正/负相关性，甚至说相关性也不能保证。即：<br>在测试的过程中，64位操作系统下调整Xss的大小并没有对产生线程的总数产生影响，程序执行到极限的时候，操作系统会死机。无法看出效果</p></blockquote></li><li><p>线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：</p><ul><li><p>/proc/sys/kernel/pid_max          系统最大pid值，在大型系统里可适当调大</p></li><li><p>/proc/sys/kernel/threads-max     系统允许的最大线程数</p></li><li><p>maxuserprocess（ulimit -u）   系统限制某用户下最多可以运行多少进程或线程</p></li><li><p>/proc/sys/vm/max_map_count</p><blockquote><p>max_map_count文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量。虚拟内存区域是一个连续的虚拟地址空间区域。在进程的生命周期中，每当程序尝试在内存中映射文件，链接到共享内存段，或者分配堆空间的时候，这些区域将被创建。调优这个值将限制进程可拥有VMA的数量。限制一个进程拥有VMA的总数可能导致应用程序出错，因为当进程达到了VMA上线但又只能释放少量的内存给其他的内核进程使用时，操作系统会抛出内存不足的错误。如果你的操作系统在NORMAL区域仅占用少量的内存，那么调低这个值可以帮助释放内存给内核用。</p></blockquote></li></ul></li></ul></li></ul><h1>面试题</h1><p><strong>说到内存泄漏，问有没有碰到，内存泄漏怎么解决？（拼多多）<br>内存泄漏是怎么造成的？（拼多多、字节跳动）<br>如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？ (阿里)</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-5.3网络规划-网络存储</title>
      <link href="/posts/a80158b0.html"/>
      <url>/posts/a80158b0.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容（知识点杂）：</p><ul><li>IPv6</li><li>网络规划与设计</li></ul><h1>中论</h1><h2 id="IPv6">IPv6</h2><p>特点：</p><ul><li>IPv6地址长度为128位</li><li>报文头部选项部分有所变化，使路由器可以简单过滤选项而不做任何处理，加快了报文处理速度</li><li>安全性提高，增加了身份认证和隐私权</li><li>支持更多的服务类型</li><li>允许协议继续演变</li></ul><p>IPv4到IPv6过渡时期主要采用的三种基本技术</p><ul><li>双协议栈：主机同时运行IPv4和IPv6两套协议栈。</li><li>隧道技术：在IPv4网络之上建立一条能够传输IPv6的数据报隧道，比如将IPv6整体当做IPv4的数据报进行发送。</li><li>翻译技术：利用专门的翻译设备（比如转换网关），在纯IPv4和纯IPv6网络之间转换IP报头的地址，根据协议不同对分组做相应的语义转换。</li></ul><h2 id="网络规划与设计">网络规划与设计</h2><p><img src="../image/post/image-20240430203820396.png" alt="image-20240430203820396"></p><p>三层模型：核心层、汇聚层、接入层</p><ul><li>核心层：提供不同区域之间的最佳路由和高速数据传送</li><li>汇聚层：将网络业务连接到接入层，并实施与安全、流量、负载和路由相关的策略</li><li>接入层：为用户提供本地网段访问应用系统的能力，主要负责用户信息的收集工作和管理功能</li></ul><p><img src="../image/post/image-20240430204152071.png" alt="image-20240430204152071"></p><p><strong>建筑物综合布线系统PDS</strong></p><ul><li>工作区子系统：实现工作区终端设备到水平子系统的信息插座之间的互联</li><li>水平布线子系统：实现信息插座和管理子系统的连接</li><li>设备间子系统：实现中央主配线架与各种不同设备之间的链接</li><li>垂直干线子系统：实现各楼层设备间子系统之间的互联</li><li>管理子系统：连接各楼层水平布线子系统和垂直干缆线（不是垂直干线子系统），连接控制其他子系统</li><li>建筑群子系统：各个建筑物通信系统之间的关联</li></ul><blockquote><p>工作区-&gt;水平布线-&gt;管理子系统-&gt;垂直干线子系统-&gt;设备间子系统-&gt;建筑群子系统</p></blockquote><h2 id="磁盘冗余阵列">磁盘冗余阵列</h2><p>RAID：将数据分散在不同磁盘中，可并行读取、可冗余存储，提高磁盘访问速度，保障数据安全性</p><ul><li>RAID0：将数据分散存储在不同磁盘中，没有提供冗余和错误修复技术</li><li>RAID1：在成对的独立磁盘上产生互为备份的数据，增加存储可靠性</li><li>RAID2：将数据条块化分布于不同硬盘上，使用海明码校验</li><li>RAID3：奇偶校验，用单块磁盘存储奇偶校验信息</li><li>RAID5：交叉存储数据并奇偶校验信息</li><li>RAIDO+1：两个RAID0</li><li>RAID1+0：两个DAID1</li></ul><blockquote><p>0 1 5 比较重要</p></blockquote><p><img src="../image/post/image-20240430205454314.png" alt="image-20240430205454314"><img src="../image/post/image-20240430205517025.png" alt="image-20240430205517025"></p><p><img src="../image/post/image-20240430205605613.png" alt="image-20240430205605613"></p><h2 id="网络存储技术">网络存储技术</h2><ul><li>直接附加存储（DAS）：将存储设备通过SCSI接口直接连接到一台服务器上使用，存储操作依赖服务器，不带有任何存储操作系统<ul><li>问题：在传递距离、连接数量、传输速率等方面都受到限制，容量难以扩展升级</li></ul></li><li>网络附加存储（NAS）：通过网络接口与网络直接相连，用户通过网络访问，有独立的存储系统。客户机与存储设备之间的数据访问不再需要文件服务器的干预，响应速度快且传输速率高<ul><li>性能特点：小文件级的共享存取</li></ul></li><li>存储区域网（SAN）：通过专有交换机将磁盘阵列与服务器连接起来的高速专用子网，采用块（block）级别存储。将存储设备从传统的以太网中分离出来，成为独立的存储区域网络</li></ul><h2 id="其他概念">其他概念</h2><ul><li><p>网络地址翻译NAT：将地址映射到公有网IP上的技术</p></li><li><p>默认网关：一个主机可以有多个网关。如果一个主机找不到可用网关，就把数据包发送给默认指定的网关。默认网关的IP地址必须与本机IP地址在同一个网段内，即同网络号</p></li><li><p>虚拟局域网VLAN：一组逻辑上的设备和用户</p></li><li><p>虚拟专用网VPN：在公用网络上建立专用网络的技术，VPN网络的任意两个节点之间没有端到端的物理连接，而是架构在公有网络服务商所提供的网络平台上</p></li><li><p>PPP：安全认证</p></li><li><p>冲突域和广播域：路由器可以阻断广播域和冲突域，交换机只能阻断冲突域；一个路由器下可以划分多个广播域和多个冲突域，一个交换机下整体是一个广播域，但可以划分多个冲突域；物理层设备集线器下整体作为一个冲突域和一个广播域。</p></li><li><p>URL：<a href="http://www.xxx.com">www.xxx.com</a>。 www为主机名，xxx.com为域名；当URL地址上没有明确协议时，默认使用http协议；主机名+域名=IP地址。</p></li></ul><h1>后记</h1><blockquote><p>世上没有白费的努力，也没有碰巧的成功，一切无心插柳，其实都是水到渠成。人生没有白走的路，也没白吃的苦，当下跨出去的每一步，都是未来的基石与铺垫。 ——————《南来北往》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-5.2传输介质-通信方式-IP地址-子网划分</title>
      <link href="/posts/f42c09a9.html"/>
      <url>/posts/f42c09a9.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>传输介质（了解）</li><li>通信方式、同步方式和交换方式（重要）</li><li>IP地址（重点）</li><li>子网划分（重点）</li><li>超网（了解）</li></ul><h1>中论</h1><h2 id="传输介质">传输介质</h2><ul><li><p>双绞线：俗称网线；传输距离在100m以内</p><ul><li>无屏蔽双绞线UTP。CAT3（3类UTP；10Mbps）、CAT5（5类UTP；100Mbps）、CAT5E（超5类UTP；1000Mbps）、CAT6（6类UTP；1000Mbps）</li><li>屏蔽双绞线STP。相较于UTP增加了一层屏蔽层，提高了传输的可靠性。</li><li>网线安装顺序（记住位置）</li></ul><p><img src="../image/post/image-20240429205538714.png" alt="image-20240429205538714"></p></li><li><p>光纤：光信号传输</p><ul><li>多模光纤MMF：可以同时传输多种不同的信号；采用发光二极管LED为光源；成本低；传输效率和可靠性也低；适合短距离传输</li><li>单模光纤SMF：一般只能传输一种信号；采用激光二极管LD作为光源；支持激光信号的传播；成本高；传输距离远；可靠性高。</li></ul></li><li><p>无线信道</p><ul><li>无线电波</li><li>红外光波</li></ul></li></ul><h2 id="通信方式、同步方式和交换方式（重要）">通信方式、同步方式和交换方式（重要）</h2><p><strong>通信方向</strong></p><ul><li>单工</li><li>半双工</li><li>全双工</li></ul><p><strong>同步方式</strong></p><ul><li>异步传输：发送方每发送一个字符，需要约定一个起始位和停止位插入到字符的起始和结尾处。</li><li>同步传输：以数据块为单位进行传输，当发送方要发送数据时，先发送一个同步帧；结束后又会有结束帧。</li></ul><p><strong>传输方式</strong></p><ul><li>串行传输：一根数据线，1bit发送</li><li>并行传输：多跟数据线，多bit发送</li></ul><p><strong>交换方式</strong>（重要）</p><ul><li>电路交换：通信双方建立一个专用电路；面向连接；实时性高；链路利用率低</li><li>报文交换：以报文为单位，存储转发模式（收到数据先存储，后校验，无误后转发）；有延迟；可靠性高；无连接</li><li>分组交换：以分组为单位，存储转发模式；时延小于报文交换<ul><li>数据报：目前主流交换方式；各个分组携带地址信息；自由选择不同的路由路径；接收方重新组装；无连接；不可靠</li><li>虚电路：通信双方建立一个虚拟的通信线路；空闲的时候这条线路也可以传输其他数据；面向连接；可靠</li><li>信元交换：异步传输模式ATM采用的交换模式；本质按照虚电路方式进行转发；信元固定长度的分组（共53B，其中5B为头部，48B为数据域）；面向连接；可靠</li></ul></li></ul><h2 id="IP地址（重点）">IP地址（重点）</h2><p>点分十进制表示。</p><p><strong>分类IP地址</strong></p><p>逻辑上将IP地址分为网络号和主机号，根据网络号位数的不同，将IP地址分为以下几类：</p><p><img src="../image/post/image-20240429211036717.png" alt="image-20240429211036717"></p><p><strong>无分类编址</strong></p><p>IP地址/网络号表示</p><p><strong>特殊IP地址</strong></p><p>公有地址：直接访问因特网的地址，全网唯一</p><p>私有地址：非注册地址，组织机构内部使用</p><p><img src="../image/post/image-20240429211301558.png" alt="image-20240429211301558"></p><p>其他特殊地址：</p><p><img src="../image/post/image-20240429211314083.png" alt="image-20240429211314083"></p><h2 id="子网划分（重点）">子网划分（重点）</h2><p>将IP地址按标准划分为A、B、C类后，进一步划分，即<strong>将主机号拿出即为作为子网号</strong>，就可以划分多个子网，此时IP地址组成：网络号+子网号+主机号</p><ul><li>网络号和子网号都为1，主机号都为0，这样的地址为子网掩码</li><li>子网号可以全0或全1，主机号不能为全0或全1，所以计算主机数时需要-2。</li></ul><h2 id="超网（了解）">超网（了解）</h2><p>就是划分子网的逆过程，将网络号取出几位作为主机号。</p><h1>后记</h1><blockquote><p>活得太清楚，本身就不是一件浪漫的事</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-5.1七层模型-局域网-TCPIP协议族</title>
      <link href="/posts/785e391.html"/>
      <url>/posts/785e391.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li><p>网络相关功能分类</p></li><li><p>七层模型</p></li><li><p>局域网</p></li><li><p>广域网</p></li><li><p>TCP/IP协议（重点）</p></li><li><p>交换技术</p></li><li><p>路由技术</p></li></ul><h1>中论</h1><h2 id="网络相关功能分类">网络相关功能分类</h2><p>计算机网络的功能：数据通信、资源共享、管理集中化、实现分布式处理、负载均衡</p><p>网络性能指标：速率、带宽、吞吐量、时延、往返时间</p><p>网络非性能指标：费用、质量、标准化、可靠性、可扩展性、可升级性、易管理性和可维护性</p><p>通信技术是计算机网络的基础，信道可以分为物理信道和逻辑信道。</p><p>同时传递多路数据需要：复用技术和多址技术</p><p>新一代移动通信技术（5G），特点：</p><p>（1）基于OFDM优化的波形和多址接入</p><p>（2）实现可扩展的OFDM间隔参数配置</p><p>（3）OFDM加窗提高多路传输效率</p><p>（4）灵活框架设计</p><p>（5）大规模MIMO：最多256根天线</p><p>（6）毫米波：频率大约24GHz以上的频段</p><p>（7）频谱共享</p><p>（8）先进的信道编码技术</p><h2 id="OSI七层模型">OSI七层模型</h2><p><img src="../image/post/image-20240425215446097.png" alt="image-20240425215446097"></p><h2 id="局域网">局域网</h2><p>以太网：一种计算机局域网组网技术</p><p>以太网规范：IEEE 802.3。最小帧长64字节</p><p>无线局域网WLAN技术标准：IEEE 802.11</p><h2 id="广域网">广域网</h2><p>广域网相关技术：同步光网络、数字数据网、帧中继、异步传输技术</p><h2 id="TCP-IP协议">TCP/IP协议</h2><p>网络协议三要素：语义、语法、时序</p><p><strong>TCP/IP四层模型</strong></p><p><img src="../image/post/image-20240425215852145.png" alt="image-20240425215852145"></p><ul><li>网络层协议：<ul><li>IP：无连接、不可靠</li><li>ICMP：因特网控制报文协议</li><li>ARP和RARP：地址解析协议。ARP：IP转物理地址；RARP：物理地址转IP</li><li>IGMP：网络组管理协议，支持组播</li></ul></li><li>传输层协议：<ul><li>TCP：可靠的、全双工</li><li>UDP：不可靠、无连接</li></ul></li><li>应用层协议：<ul><li>FTP：可靠的文本协议</li><li>HTTP：超文本传输协议</li><li>SMTP和POP3：简单邮件传输协议</li><li>Telnet：远程连接协议</li><li>TFTP：不可靠、开销小的小文件传输协议</li><li>SNMP：简单网络管理协议</li><li>DHCP：动态主机配置协议</li><li>DNS：域名解析协议</li></ul></li></ul><p><strong>协议端口号对照表（掌握）</strong></p><p><img src="../image/post/image-20240425220659471.png" alt="image-20240425220659471"></p><h2 id="交换技术">交换技术</h2><p>交换机功能：</p><ul><li>集线功能</li><li>中继功能</li><li>桥接功能</li><li>隔离冲突域功能</li></ul><p>交换机需要实现的功能：</p><ul><li>转发路径学习</li><li>数据转发</li><li>数据泛洪</li><li>链路地址更新</li></ul><h2 id="路由技术">路由技术</h2><p>路由功能：</p><ul><li>异种网络互连</li><li>子网协议转换</li><li>数据路由</li><li>速率适配</li><li>隔离网络</li><li>报文分片和重组</li><li>备份、流量控制</li></ul><p>路由协议可分为内部网关协议（IGP）和外部网关协议（EGP）</p><p>网络建设工程可分为网络规划、网络设计和网络实施三个环节</p><h1>后记</h1><blockquote><p>人总要沉淀下来，过一段宁静而自醒的日子。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-垃圾回收篇（上）</title>
      <link href="/posts/5026c3fb.html"/>
      <url>/posts/5026c3fb.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><p><strong>什么是垃圾</strong></p><p>运行程序中没有任何指针指向的对象。</p><p><strong>Java垃圾回收的重点区域</strong></p><p>堆和方法区</p><h2 id="垃圾回收算法">垃圾回收算法</h2><h3 id="垃圾判别算法">垃圾判别算法</h3><ul><li><p>引用计数法：对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><ul><li><p>优点：实现简单，便于辨识；效率高。</p></li><li><p>缺点：存在循环引用的情况。</p><p><img src="../image/post/image-20240424062846318.png" alt="image-20240424062846318"></p></li></ul></li><li><p>可达性分析法（Java使用）：就是将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条(Reference Chain)，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。</p><ul><li>优点：有效的解决循环引用的问题。</li><li>缺点：可达性分析时会有STW（即使是CMS，在枚举根节点时也必须要STW）</li></ul></li></ul><p><strong>有哪些对象可以是GC Roots</strong></p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁synchronized持有的对象</li><li>JVM内部的引用（基本数据类型对应的Class对象，常驻的异常对象，系统类加载器）</li><li>反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><blockquote><p>由于GC Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个GC Root 。</p></blockquote><h3 id="垃圾清除算法">垃圾清除算法</h3><p>垃圾清除算法主要有标记-清除、复制、标记-压缩、分代收集、增量收集、分区。</p><p><strong>标记-清除</strong></p><ul><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li></ul><p>缺点：效率低，需要遍历两次；GC时，需要STW；容易产生内存碎片</p><blockquote><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。内存不够时再清除</p></blockquote><p><img src="../image/post/image-20240424064015614.png" alt="image-20240424064015614"></p><p><strong>复制算法</strong></p><p>将内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p>优点：</p><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题</li></ul><p>缺点：</p><ul><li>需要两倍的内存空间</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li><li>如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</li></ul><blockquote><p><strong>新生代</strong>常用的垃圾回收算法</p></blockquote><p><img src="../image/post/image-20240424064451166.png" alt="image-20240424064451166"></p><p><strong>标记-压缩算法</strong>（标记-整理）</p><p>从根节点开始标记所有被引用对象，将所有的存活对象压缩到内存的一端，按顺序排放。</p><p>优点：</p><ul><li>消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li><li>消除了复制算法当中，内存减半的高额代价</li></ul><p>缺点：</p><ul><li>从效率上来说，标记-压缩算法要低于复制算法。（效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址；对于老年代每次都有大量对象存活的区域来说，极为负重）</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><p><img src="../image/post/image-20240424064815073.png" alt="image-20240424064815073"></p><p><strong>分代收集算法</strong></p><p>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p><ul><li><p>年轻代：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。<code>一般采用复制算法</code></p></li><li><p>老年代：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。<code>一般采用标记-清除或者标记-清除与标记-整理的混合实现</code></p></li></ul><p><strong>增量收集算法</strong></p><p>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><ul><li>优点：尽可能的减少STW的情况</li><li>缺点：系统吞吐量下降</li></ul><p><strong>分区算法</strong></p><p>分代算法将按照对象的生命周期长短划分成两个部分，而分区算法将整个堆空间划分成连续的不同小区间。</p><ul><li>优点：每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ul><h2 id="相关概念">相关概念</h2><p><strong>System.gc()</strong></p><p>在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><blockquote><p>**Java中调用System.gc()方法并不一定会立即触发垃圾回收。**System.gc()方法只是向 JVM 提出一个垃圾回收的建议,具体的垃圾回收时间及方式仍然由 JVM 决定。</p></blockquote><p><strong>finalize()</strong></p><p>垃圾回收器在回收某个对象的时候，首先会调用该对象的finalize()方法</p><p>特点：</p><ul><li>Java不保证finalize方法会被及时地执行</li><li>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</li><li>finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</li><li>一个对象的finalize方法至多由GC执行一次</li></ul><blockquote><p>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作</p></blockquote><p><strong>finalize的执行过程（生命周期）</strong></p><p>当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p><p><strong>内存溢出和内存泄露</strong></p><p><strong>内存溢出</strong>：是真实有用的对象，占用了内存空间，当需要更多内存空间时，内存空间不足，内存溢出。</p><p><strong>内存溢出的原因</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）<span class="keyword">Java虚拟机的堆内存设置不够</span></span><br><span class="line"><span class="keyword"></span>（<span class="number">2</span>）代码中创建了大量大对象，并且一直被引用导致不能被回收。</span><br></pre></td></tr></table></figure><p><strong>内存泄露</strong>：是无用的对象(应用中无实际作用)，占用了内存空间，当GC时又不能回收它们。</p><blockquote><p>内存泄漏并不会立刻引起程序崩溃</p></blockquote><p><strong>内存泄露的几种情况</strong></p><p>长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）静态集合类存放外部对象。静态集合类的生命周期与JVM程序一致，当容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。</span><br><span class="line">（<span class="number">2</span>）单例模式持有外部对象。</span><br><span class="line">（<span class="number">3</span>）内部类持有外部类。</span><br><span class="line">（<span class="number">4</span>）各种连接。数据库、网络、IO连接。</span><br><span class="line">（<span class="number">5</span>）变量作用域不合理。</span><br><span class="line">（<span class="number">6</span>）改变对象<span class="built_in">Hash</span>值。对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在<span class="built_in">contains</span>方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄漏。</span><br><span class="line">（<span class="number">7</span>）缓存泄露。</span><br><span class="line">（<span class="number">8</span>）监听与回调。</span><br></pre></td></tr></table></figure><p><strong>OOM之前一定会GC？</strong></p><p>不一定。通常在抛出OOM之前会GC，但是如果分配一个超大的对象，超过了堆的最大值，JVM直接抛出OOM。</p><p><strong>什么是STW？</strong></p><p>Stop-the-World ，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><ul><li>STW事件和采用哪款GC无关，所有的GC都有这个事件。</li><li>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</li><li>开发中不要用System.gc();会导致Stop-the-world的发生。</li></ul><p><strong>垃圾回收的并行和并发</strong></p><p>垃圾回收串行：单线程执行垃圾回收。</p><p>垃圾回收并行：多线程执行垃圾回收，但此时用户线程仍处于等待状态。</p><p>垃圾回收并发：用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行，用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上。</p><p><strong>安全点和安全区域</strong></p><p>安全点：程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”</p><p>常见的安全点：方法调用、循环跳转和异常跳转</p><p>安全区域：安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p><p><strong>JAVA中的引用————垃圾回收相关</strong></p><p>强引用：不回收。</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><p>软引用：内存不足时回收。</p><ul><li>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。</li></ul><p>弱引用：发现即回收。</p><ul><li>弱引用非常适合来保存那些可有可无的缓存数据。</li><li>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</li></ul><p>虚引用：对象回收跟踪。</p><ul><li>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</li><li>随时都可能被垃圾回收器回收。</li><li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li></ul><p>终结期引用：它用以实现对象的finalize()方法，也可以称为终结器引用。</p><ul><li>无需手动编码，其内部配合引用队列使用。</li><li>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。</li></ul><h1>面试题</h1><p><strong>讲讲JVM的gc  (携程)<br>GC是什么？为什么要有GC？ (蚂蚁金服)<br>垃圾回收的优点和原理。  (蚂蚁金服)<br>垃圾回收机制等 (支付宝)<br>GC回收的是哪部分的垃圾？（vivo）<br>垃圾回收的优点和原理？基本原理是什么？（瓜子）<br>GC是什么？为什么要有GC？ (美团)<br>简述Java垃圾回收机制  (美团)<br>垃圾回收的优点和原理。(美团)</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>GC算法都有哪些？他们之间的区别是什么？（菜鸟）<br>JVM的常用的GC算法（高得地图）<br>GC垃圾回收机制算法（数信互融科技发展有限公司）<br>GC的算法，复制算法和标记清除的优缺点？（迪原创新）<br>常用的GC算法，如何确定哪些是要被清除的哪些是不能被清除（网易邮箱、美团）<br>垃圾回收机制的几种回收算法（亚信）<br>GC算法都有哪些？他们之间的区别是什么？各自的适用场景？（B站）<br>GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？（腾讯）<br>如和判断一个对象是否存活?（唯品会）<br>Java 中垃圾收集的方法有哪些?（苏宁）<br>你是用什么方法判断对象是否死亡？（滴滴）<br>如何判断一个对象是否存活？ (蚂蚁金服)<br>垃圾收集策略和算法  (百度)<br>常见的垃圾回收器算法有哪些，各有什么优劣？（网易）<br>JVM有哪些回收算法，对应的收集器有哪些？ (蚂蚁金服)<br>JVM GC算法有哪些，目前的JDK版本采用什么回收算法  (蚂蚁金服)<br>垃圾回收算法的实现原理。  (京东)<br>讲一下JVM中如何判断对象的生死？ (京东)<br>如何选择合适的垃圾收集算法？ (阿里)<br>讲一讲垃圾回收算法。 (阿里)<br>JVM有哪些回收算法，对应的收集器有哪些？ (拼多多)<br>讲讲你知道的垃圾回收算法 (字节跳动)<br>Java对象的回收方式，回收算法。 (字节跳动)<br>JVM垃圾收集算法与收集器有哪些？ (京东)<br>常见的垃圾回收器算法有哪些，各有什么优劣？（阿里-天猫、UC）<br>有哪些垃圾回收方法，jdk8的垃圾收集器是什么？（搜狐、万达集团）<br>如何判断一个对象是否存活？（或者GC对象的判定方法） (美团)<br>常见的垃圾回收器算法有哪些，各有什么优劣？ (字节跳动)</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Java GC机制？GC Roots有哪些？ (拼多多)<br>JVM怎样判断一个对象是否可回收，怎样的对象才能作为GC root  (腾讯)<br>Java GC机制？GC Roots有哪些？ (字节跳动)<br>哪些部分可以作为GC Root？ (字节跳动)<br>Java GC机制？GC Roots有哪些？ (抖音)<br>Java GC机制？GC Roots有哪些？ (京东)<br>GC root如何确定，哪些对象可以作为GC Root?  (美团)</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>JVM的垃圾回收为什么采用分代GC。跟语言有关系吗？（阿里-钉钉）<br>分代的意义说一下 （阿里-钉钉）<br>GC分代算法（花旗银行）<br>说一下gc算法，分代回收说下  (百度)<br>Java怎么进行垃圾回收的？什么对象会进老年代？ 垃圾回收算法有哪些？为什么新生代使用复制算法？ (京东)<br>分代垃圾回收过程？ (美团)<br>GC如何分代的？各代用什么算法回收？  (美团)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">垃圾清除算法</span><br></pre></td></tr></table></figure><p><strong>System.gc()和Runtime.getRunTime().gc()会做什么事情？  (字节跳动)</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**什么是内存泄漏和什么是内存溢出 <span class="comment">(陌陌)</span></span><br><span class="line">Java存在内存泄漏吗，内存泄漏的场景有哪些，如何避免<span class="comment">(百度)</span></span><br><span class="line">Java 中会存在内存泄漏吗，简述一下？<span class="comment">(猎聘)</span></span><br><span class="line">内存泄漏是怎么造成的？<span class="comment">(拼多多、字节跳动)</span></span><br><span class="line">内存泄漏与内存溢出的区别  <span class="comment">(字节跳动)</span></span><br><span class="line">Java存在内存溢出的现象吗  <span class="comment">(字节跳动)</span></span><br><span class="line">Java中会存在内存泄漏吗，请简单描述。   <span class="comment">(美团)</span>  **</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**什么是Full <span class="built_in">GC</span>？<span class="built_in">GC</span>? major <span class="built_in">GC</span>? stop the world (腾讯)**</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**SafePoint 是什么（360安全）**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**强引用、软引用、弱引用、虚引用的区别？（字节跳动）</span></span><br><span class="line"><span class="strong">你开发中使用过WeakHashMap吗？(京东)**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-垃圾回收篇（下）</title>
      <link href="/posts/e89aa49e.html"/>
      <url>/posts/e89aa49e.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><h2 id="垃圾回收器">垃圾回收器</h2><h3 id="分类">分类</h3><p><strong>串行VS并行</strong></p><p>从线程数角度划分</p><ul><li><p>串行回收指同一时间段只允许有一个CPU用于执行垃圾回收操作</p></li><li><p>并行回收指用多个CPU同时执行垃圾回收，也会有STW。</p></li></ul><blockquote><p>单CPU处理器或者较小的应用内存推荐使用串行回收，比如在客户端的Client模式下的JVM中</p></blockquote><p><strong>独占式VS并发式</strong></p><p>从工作模式角度划分，</p><ul><li>独占式：垃圾回收器运行时，停止用户线程，直到垃圾回收结束。</li><li>并发式：垃圾回收器运行和用户应用程序线程交替工作，减少应用程序的停顿时间。</li></ul><p><strong>压缩式VS非压缩式</strong></p><p>从碎片处理方式</p><ul><li>压缩式：对存活对象进行压缩整理，再分配对象空间使用：指针碰撞</li><li>非压缩式：不进行压缩处理，再分配对象空间使用：空闲列表</li></ul><p><strong>年轻代VS老年代</strong></p><p>从工作的内存区间划分</p><h3 id="GC评估指标">GC评估指标</h3><p>吞吐量：运行用户代码时间/（运行用户代码时间+垃圾回收时间）</p><p>垃圾收集开销：吞吐量的补数</p><p>暂停时间：执行垃圾回收时，程序的工作线程被暂停的时间</p><p>收集频率：收集操作发生的频率</p><p>内存占用：Java堆区所占的内存大小</p><p>快速：一个对象从诞生到被回收所经历的时间</p><blockquote><p>吞吐量优先：单位时间内STW时间最短</p><p>响应时间优先：尽可能让单次STW时间最短</p></blockquote><p><strong>目前JVM调优的标准：在最大吞吐量优先的情况下，降低停顿时间</strong></p><h3 id="垃圾回收器-2">垃圾回收器</h3><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel Old</li><li>并发回收器：CMS、G1</li></ul><p><img src="../image/post/image-20240430070128897.png" alt="image-20240430070128897"></p><p><strong>7种GC组合关系</strong></p><p><img src="../image/post/image-20240430070234089.png" alt="image-20240430070234089"></p><p><strong>如何查看默认GC</strong></p><p>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：jinfo –flag 相关垃圾回收器参数 进程ID</p><h4 id="Serial-GC-和Serial-Old-GC">Serial GC 和Serial Old GC</h4><ul><li>Serial收集器是最基本、历史最悠久的垃圾收集器</li><li>HotSpot中Client模式下的默认新生代垃圾收集器</li><li>采用复制算法、串行回收和”Stop-the-World”机制的方式执行内存回收</li><li>Serial Old 收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</li><li>Serial Old是运行在Client模式下默认的老年代的垃圾回收器</li><li>Serial Old在Server模式下主要有两个用途：① 与新生代的Parallel Scavenge配合使用 ② 作为老年代CMS收集器的后备垃圾收集方案</li></ul><p><img src="../image/post/image-20240430071908309.png" alt="image-20240430071908309"></p><blockquote><p>Serial必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。</p></blockquote><p><strong>优点</strong></p><ul><li>简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</li><li>适合运行在Client模式下的虚拟机</li><li>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms）,只要不频繁发生，使用串行回收器是可以接受的。</li></ul><p><strong>参数</strong></p><p>-XX:+UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器</p><h4 id="PerNew-GC">PerNew GC</h4><ul><li>Par是Parallel的缩写，New：只能处理的是新生代</li><li>多线程垃圾回收器</li><li>ParNew 收集器除了采用并行回收的方式执行内存回收外，在年轻代中同样也是采用复制算法、&quot;Stop-the-World&quot;机制</li><li>很多JVM运行在Server模式下新生代的默认垃圾收集器</li><li>通常PerNew GC和Serial Old GC配合使用<ul><li>对于新生代，回收次数频繁，使用并行方式高效</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul></li></ul><p><img src="../image/post/image-20240430071853144.png" alt="image-20240430071853144"></p><p><strong>优点</strong></p><ul><li>ParNew 收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li></ul><blockquote><p>但是在单个CPU的环境下，ParNew收集器不比Serial 收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</p></blockquote><p><strong>参数</strong></p><p>-XX:+UseParNewGC：手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数据相同的线程数。</p><h4 id="Parallel-GC和Parallel-Old-GC">Parallel GC和Parallel Old GC</h4><ul><li>基于并行回收</li><li>同样也采用了复制算法和”Stop the World”机制</li><li>自适应调节策略。（和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量）</li><li>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</li><li>Parallel 收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</li><li>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。</li><li>在程序吞吐量优先的应用场景中， Parallel 收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。</li><li>在Java8中，默认是此垃圾收集器。</li></ul><p><img src="../image/post/image-20240430071830484.png" alt="image-20240430071830484"></p><p><strong>参数</strong></p><p>-XX:+UseParallelGC  手动指定年轻代使用Parallel并行收集器执行内存回收任务。<br>-XX:+UseParallelOldGC  手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认jdk8是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul><p>-XX:ParallelGCThreads 设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><ul><li>在默认情况下，当CPU 数量小于8个， ParallelGCThreads 的值等于CPU 数量。</li><li>当CPU数量大于8个，ParallelGCThreads 的值等于3+[5*CPU_Count]/8] 。</li></ul><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。<br>该参数使用需谨慎。</li></ul><p>-XX:GCTimeRatio 垃圾收集时间占总时间的比例（= 1 / (N + 1))。用于衡量吞吐量的大小。</p><ul><li>取值范围（0,100）。默认值99，也就是垃圾回收时间不超过1%。</li><li>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</li></ul><p>-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略</p><ul><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</li></ul><h4 id="CMS-GC">CMS GC</h4><ul><li>在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent-Mark-Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，<strong>它第一次实现了让垃圾收集线程与用户线程同时工作</strong></li><li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验</li><li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求</li><li>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-world”</li></ul><p><img src="../image/post/image-20240430071751003.png" alt="image-20240430071751003"></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始标记（<span class="variable">STW</span>）：暂时时间非常短，标记与<span class="variable">GC</span> <span class="built_in">Roots</span>直接关联的对象。</span><br><span class="line">并发标记（最耗时）：从<span class="variable">GC</span> <span class="built_in">Roots</span>开始遍历整个对象图的过程。不会停顿用户线程</span><br><span class="line">重新标记：（<span class="variable">STW</span>）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题</span><br><span class="line">并发清理（最耗时）</span><br></pre></td></tr></table></figure><blockquote><p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器Parallel Scavenge 配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p></blockquote><p><strong>收集过程</strong></p><p>CMS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p><ul><li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快</li><li>并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</li><li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比如：由不可达变为可达对象的数据），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li><li>并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><blockquote><ol><li>尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程</li><li>最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</li><li>CMS收集器的垃圾收集算法采用的是标记—清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。CMS在为新对象分配内存空间时，只能够选择空闲列表执行内存分配。</li><li>CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li></ol></blockquote><p><strong>优缺点</strong></p><p>优点：</p><ul><li>并发收集</li><li>低延迟</li></ul><p>缺点：</p><ul><li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li><li>CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><p><strong>参数</strong></p><p>-XX:+UseConcMarkSweepGC 手动指定使用CMS 收集器执行内存回收任务。</p><ul><li>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew(Young区用)+CMS(Old区用)+Serial Old的组合。</li></ul><p>-XX:CMSlnitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p><ul><li>JDK5及以前版本的默认值为68,即当老年代的空间使用率达到68%时，会执行一次CMS 回收。JDK6及以上版本默认值为92%</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC 的执行次数。</li></ul><p>-XX:+UseCMSCompactAtFullCollection 用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p><p>-XX:CMSFullGCsBeforeCompaction 设置在执行多少次Full GC后对内存空间进行压缩整理。</p><p>-XX:ParallelCMSThreads 设置CMS的线程数量。</p><ul><li>CMS 默认启动的线程数是（ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul><p><strong>新特性</strong></p><p>JDK9新特性：CMS被标记为Deprecate了(JEP291)</p><ul><li>如果对JDK 9及以上版本的HotSpot虚拟机使用参数-XX：+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul><p>JDK14新特性：删除CMS垃圾回收器(JEP363)</p><ul><li>移除了CMS垃圾收集器，如果在JDK14中使用-XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li></ul><h4 id="G1-GC">G1 GC</h4><ul><li>G1是一个并行回收器；把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li><li>有计划地避免在整个Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</li><li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</li><li>一款面向服务端应用的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器</strong>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li><li>是JDK 9以后的默认垃圾回收器，取代了CMS 回收器以及Parallel + Parallel Old组合。被Oracle官方称为“全功能的垃圾收集器”。</li><li>并行与并发<ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li>分代收集<ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul></li><li>空间整合<ul><li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ul></li><li>可预测的停顿时间模型（即：软实时soft real-time）：让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。<ul><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul></li></ul><blockquote><p>缺点：</p><ul><li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</li><li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li></ul></blockquote><p><strong>参数</strong></p><p>-XX：+UseG1GC   手动指定使用G1收集器执行内存回收任务。<br>-XX:G1HeapRegionSize  设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。<br>-XX:MaxGCPauseMillis   设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms<br>-XX:ParallelGCThread   设置STW时GC线程数的值。最多设置为8<br>-XX:ConcGCThreads   设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。<br>-XX:InitiatingHeapOccupancyPercent  设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p><p><strong>操作步骤</strong></p><p>第一步：开启G1垃圾收集器<br>第二步：设置堆的最大内存<br>第三步：设置最大的停顿时间</p><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p><p><strong>适用场景</strong></p><ul><li>面向服务端应用，针对具有大内存、多处理器的机器。(在普通大小的堆里表现并不惊喜)</li><li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；<ul><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li></ul></li><li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ul><li>① 超过50％的Java堆被活动数据占用；</li><li>② 对象分配频率或年代提升频率变化很大；</li><li>③ GC停顿时间过长（长于0.5至1秒）。</li></ul></li><li>HotSpot 垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li></ul><p><strong>分区Region</strong></p><p>使用 G1 收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB,2MB,4MB,8MB,16MB,32MB。可以通过-XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p><p><img src="../image/post/image-20240430081237920.png" alt="image-20240430081237920"></p><ul><li>一个 region 有可能属于 Eden，Survivor 或者 Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的 E 表示该region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</li><li>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过1.5个region，就放到H。</li></ul><blockquote><p>设置H的原因：<br>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p></blockquote><p><strong>垃圾回收过程（简略版）</strong></p><ol><li><p>年轻代GC （Young GC）</p></li><li><p>老年代并发标记过程 （Concurrent Marking）</p></li><li><p>混合回收（Mixed GC）</p></li><li><p>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p></li></ol><h4 id="小结">小结</h4><p>如果你想要最小化地使用内存和并行开销，请选Serial GC；<br>如果你想要最大化应用程序的吞吐量，请选Parallel GC；<br>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p><blockquote><p>怎么选择垃圾收集器？</p><ul><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行收集器</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器<ul><li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ul></li></ul></blockquote><h2 id="垃圾回收使用场景">垃圾回收使用场景</h2><p><img src="../image/post/image-20240430081444939.png" alt="image-20240430081444939"></p><h2 id="新型GC">新型GC</h2><h1>面试题</h1><p><strong>请问吞吐量的优化和响应优先的垃圾收集器是如何选择的呢？（滴滴）<br>吞吐量优先选择什么垃圾回收器？响应时间优先呢？ (阿里)</strong></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">**GC 收集器有哪些？（滴滴）</span><br><span class="line">几种垃圾回收器（亚信）</span><br><span class="line">垃圾回收器有哪些？都有哪些算法来实现？项目中用的垃圾回收器是什么？（平安）</span><br><span class="line">垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（平安）</span><br><span class="line">你知道那些垃圾回收器（高德地图）</span><br><span class="line">有哪些垃圾方法，垃圾收集器是什么。(新浪)</span><br><span class="line">JVM有哪三种垃圾回收器？ (阿里)**</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？ <span class="comment">(天猫)</span></span><br><span class="line">讲一下CMS垃圾收集器垃圾回收的流程，以及CMS的缺点  <span class="comment">(抖音)</span></span><br><span class="line">说几个垃圾回收器，cms回收器有哪几个过程，停顿几次，会不会产生内存碎片。老年代产生内存碎片会有什么问题。 <span class="comment">(小米)</span></span><br><span class="line"><span class="name">g1</span>和cms区别,吞吐量优先和响应优先的垃圾收集器选择 <span class="comment">(携程)</span>**</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="name">G1</span>原理。（亚信）</span><br><span class="line">CMS和<span class="name">G1</span>了解么，CMS解决什么问题，说一下回收的过程。<span class="comment">(字节跳动)</span></span><br><span class="line">CMS回收停顿了几次，为什么要停顿两次。<span class="comment">(字节跳动)</span></span><br><span class="line">CMS过程是怎样的？内部使用什么算法做垃圾回收？  <span class="comment">(美团)</span></span><br><span class="line">CMS 收集器与 <span class="name">G1</span> 收集器的特点。（滴滴）</span><br><span class="line">CMS 收集器与 <span class="name">G1</span> 收集器的特点。 <span class="comment">(蚂蚁金服)</span></span><br><span class="line"><span class="name">G1</span>回收器讲下回收过程 <span class="comment">(蚂蚁金服)</span></span><br><span class="line">你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和<span class="name">G1</span>，包括原理，流程，优缺点。（拼多多）</span><br><span class="line">你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和<span class="name">g1</span>，包括原理，流程，优缺点  <span class="comment">(蚂蚁金服)</span></span><br><span class="line">Java的垃圾回收器都有哪些，说下<span class="name">g1</span>的应用场景，平时你是如何搭配使用垃圾回收器的  <span class="comment">(滴滴)</span>**</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-4.1嵌入式微处理器-多核处理器-嵌入式技术</title>
      <link href="/posts/a45dcd81.html"/>
      <url>/posts/a45dcd81.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>嵌入式微处理体系结构</li></ul><h1>中论</h1><h2 id="嵌入式微处理体系结构">嵌入式微处理体系结构</h2><ul><li><p>冯诺依曼结构</p><ul><li>也称普林斯顿结构。将程序指令存储器和数据存储器合并在一起的存储器结构。</li><li>指令存储地址和数据存储地址指向同一个存储器的不同物理位置</li><li>单一的地址和数据总线</li><li>处理器执行指令时，先从存储器取出指令解码，然后再取操作数执行运算</li></ul></li><li><p>哈佛结构</p><ul><li>并行体系结构。将程序和数据存储在不同的存储空间中。</li><li>程序存储器和数据存储器相互独立，独立编址、独立访问</li><li>两套独立的地址总线和数据总线</li><li>允许在一个机器周期内同时获取指令字（来自程序存储器）和操作数（来自数据存储器）</li></ul></li></ul><p><strong>微处理器分类</strong></p><ul><li>嵌入式微控制器MCU。典型代表单片机，和嵌入式微处理器相比体积小、功耗和成本下，适用于控制。16位及其以下的处理器。</li><li>嵌入式微处理器MPU。由通用计算机中的CPU演变而来，32位以上的处理器。只保留和嵌入式应用紧密相关的功能硬件，去除其他的冗余功能。</li><li>嵌入式数字信号处理器DSP。采用哈佛结构，流水线处理，处理速度比最快的CPU还要快10-50倍，用于信号处理方面的处理器。</li><li>嵌入式片上系统SOC。直接在处理器片内嵌入操作系统的代码模块，包含完整系统并有嵌入软件的全部内容。</li></ul><p><strong>多核处理器</strong></p><p>多核：多个微处理器内核。将两个或更多的微处理器封装在一起，集成在一个电路中。多核和多CPU相比，很好的降低了计算机系统的功耗和体积。</p><ul><li><p>多核工作协调实现方式</p><ul><li>SMP（对称多处理技术）：一个操作系统的实例可以同时管理所有CPU内核，且应用并不绑定某一个内核。</li><li>AMP（非对称处理技术）：每个CPU内核运行一个独立的操作系统或同一操作系统的独立实例。</li><li>BMP（混合多处理技术）：一个操作系统的实例可以同时管理所有CPU内核，但每个应用被锁定于某个指定的核心。</li></ul></li><li><p>多核CPU的调度</p><ul><li>全局队列调度：当系统中有一个CPU空闲时，操作系统就从全局任务等待队列中选取就绪任务开始执行，CPU的利用率高</li><li>局部队列调度：操作系统为每个CPU内核维护一个局部的任务等待队列，当系统中有一个CPU内核空闲时，就从该核心的任务等待队列中选取适当的任务执行，优点是无需在多个CPU之间进行切换。</li></ul></li></ul><h1>后记</h1><blockquote><p>人总是觉得没选的那条路开满鲜花。——————佚名</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-4.2嵌入式软件-RTOS-软件开发</title>
      <link href="/posts/4f0cae9e.html"/>
      <url>/posts/4f0cae9e.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>嵌入式软件</li></ul><h1>中论</h1><h2 id="嵌入式软件">嵌入式软件</h2><p>分类</p><ul><li>系统软件：控制和管理嵌入式系统资源，比如设备驱动程序、嵌入式操作系统、嵌入式中间件</li><li>应用程序：嵌入式系统中的上层软件，比如飞控软件、手机软件</li><li>支撑软件：辅助软件开发的工具软件，比如系统分析设计工具、在线仿真工具</li></ul><p><strong>板级支持包(BSP)</strong></p><p>介于主板硬件和操作系统中驱动层程序之间的一层。<code>主要包括两个方面：引导加载程序BootLoader和设备驱动程序</code></p><p>功能：</p><ul><li>单板硬件初始化，主要是CPU的初始化</li><li>为操作系统提供设备驱动程序和程序中断服务程序</li><li>定制操作系统的功能，为软件系统提供一个实时的多任务的运行环境</li><li>初始化操作系统，为操作系统的正常运行做好准备</li></ul><p>特点：</p><ul><li>硬件相关性</li><li>操作系统相关性</li></ul><p><strong>BootLoader</strong></p><p>嵌入式系统加电后运行的第一段软件代码，在操作系统内核运行之前的一小段程序。主要是初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境设置到一个合适的状态。</p><p>功能：</p><ul><li>片级初始化。主要完成微处理器初始化</li><li>板级初始化。主要完成微处理器以外的其他硬件设备初始化。</li><li>加载内核（系统级初始化）。将操作系统和应用程序的映像从Flash存储器复制到系统的内存中，然后跳转到系统内核的第一条指令处继续执行。</li></ul><blockquote><p>在一个嵌入式系统中，操作系统是可有可无的。<strong>但设备驱动程序是必不可少的。</strong></p><p>设备驱动程序：一组库函数，用来对硬件进行初始化和管理，并向上层软件提供良好的访问接口。</p><p>设备驱动程序基本功能：</p><ul><li>硬件启动</li><li>硬件关闭</li><li>硬件停用</li><li>硬件启用</li><li>读操作</li><li>写操作</li></ul></blockquote><h2 id="嵌入式系统">嵌入式系统</h2><p><strong>嵌入式系统的组成</strong></p><ul><li>嵌入式处理器</li><li>相关支撑硬件</li><li>嵌入式操作系统</li><li>支撑软件</li><li>应用软件</li></ul><p><strong>嵌入式系统的特点</strong></p><ul><li>专用型强</li><li>技术融合</li><li>软硬一体软件为主</li><li>比通用计算机资源少</li><li>程序代码固化在非易失的存储器中</li><li>需专门开发工具和环境</li><li>体积小、价格低</li><li>对安全性和可靠性要求高</li></ul><p><strong>嵌入式系统的分类</strong></p><p>用途：嵌入式实时（强实时和弱实时）和嵌入式非实时</p><p>安全：安全攸关和非安全攸关系统</p><p><strong>嵌入式系统的层级</strong></p><ol><li>硬件层</li><li>抽象层（驱动）</li><li>操作系统层</li><li>中间件层</li><li>应用层</li></ol><h2 id="嵌入式数据库系统">嵌入式数据库系统</h2><p>特点：</p><ol><li>设备随时移动性</li><li>网络频繁断接</li><li>网络条件多样化</li><li>信息能力不对称</li></ol><p>组成：</p><ul><li>主数据库</li><li>同步服务器</li><li>嵌入式数据库</li><li>网络连接</li></ul><blockquote><p>嵌入式移动数据库比如满足数据一致性（复制性）、高校的事务处理以及数据的安全性等关键问题。</p></blockquote><h2 id="嵌入式操作系统EOS">嵌入式操作系统EOS</h2><p>特点：</p><ul><li>微型化</li><li>代码质量高</li><li>专业化</li><li>实时性强</li><li>可裁减和可配置</li></ul><h2 id="实时操作系统RTOS">实时操作系统RTOS</h2><p>特点：能够接受并以足够快的速度予以处理，能够提供及时响应和高可靠性。</p><p>特征：高精度计时系统；多级中断机制；实时调度机制</p><blockquote><p>嵌入式实时系统中，要求系统在投入运行前即具有<strong>确定性和可预测性</strong>。</p><ul><li>可预测性：在运行之前，其功能、响应特性和执行结果是可预测的。</li><li>确定性：系统在给定的初试状态和输入条件下，在确定的时间内给出确定的结果。</li></ul></blockquote><h2 id="嵌入式软件设计">嵌入式软件设计</h2><p>嵌入式软件开发是一个典型的交叉平台开发环境，包含三个高度集成的部分</p><ol><li>运行在宿主机和目标机上的强有力的交叉开发工具和实时程序</li><li>运行在目标机上的高性能、可裁剪的实时操作系统</li><li>连接宿主机和目标机的多种通信方式。</li></ol><p><img src="../image/post/image-20240424212859949.png" alt="image-20240424212859949"></p><p>特点：</p><ul><li>交叉编译：在一个平台上生成可以在另一个平台上执行的代码。（嵌入式系统的开发需要借助宿主机【通用计算机】来编译出目标机的可执行代码）</li><li>交叉调试：调试器仍然运行在宿主机的通用操作系统之上，但被调试的进程却是运行在基于特定硬件平台的嵌入式操作系统中，二者通过串口或者网络进行通信。</li></ul><h2 id="软件开发工具">软件开发工具</h2><ul><li><p>嵌入式软件开发阶段：编码、交叉编译、交叉调试</p></li><li><p>编辑器：用于编写嵌入式源代码程序，比如keil</p></li><li><p>编译器gcc：根据源代码交叉编译生成可执行的目标文件</p></li><li><p>调试器gdb：调试器运行在宿主机上，被调试程序运行在目标机上。二者通过通信（串口、并口、网络、JTAG）等方式建立联系。</p></li></ul><h1>后记</h1><blockquote><p>生活中真正的勇士向来默默无闻，喧哗不止的永远是自视高贵的一群。——————路遥《平凡的世界》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-3.4数据库新技术-SQL语言</title>
      <link href="/posts/cdda78d7.html"/>
      <url>/posts/cdda78d7.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>数据库安全</li><li>数据仓库技术</li><li>反规范化技术</li><li>SQL语言</li></ul><h1>中论</h1><h2 id="数据库安全">数据库安全</h2><p><strong>相关概念</strong></p><p>静态转储：冷备份，在转储期间不允许对数据库进行任何存取、修改的操作</p><p>动态转储：热备份，转储期间允许对数据库进行存取、修改操作</p><p>完全备份：备份所有数据</p><p>增量备份：备份上一次备份之后变化的数据</p><p>差量备份：仅备份上一次完全备份之后变化的数据</p><p>日志文件：事务处理过程中，数据库管理系统(DBMS)把事务开始、结束以及对数据库的插入、删除、修改的每一次操作写入日志文件。</p><p>水平分片：将表中水平的记录分别存放在不同的地方。</p><p>垂直分片：将表中垂直的列值分别存放在不同的地方。</p><p>分布透明性：分片透明性、位置透明性、逻辑透明性、复制透明性。</p><h2 id="数据仓库技术">数据仓库技术</h2><p>数据仓库：面向主题的、集成的、非易失的、且随时间变化的数据的集合。</p><ul><li>面向主题：按一定主题域进行组织</li><li>集成的：对原有分散的数据库数据抽取、清理的基础上经过系统加工、汇总和整理得到的</li><li>相对稳定的：数据仓库中一般有大量的查询操作，但修改和删除操作很少</li><li>反映历史变化：记录了企业从过去某一时间点到目前的各个阶段的信息</li></ul><p><strong>结构层次</strong></p><ol><li>数据源</li><li>数据的存储与管理</li><li>OLAP(联机分析处理)服务器</li><li>前端工具</li></ol><p><strong>BI系统</strong></p><p>BI系统主要包括数据预处理、建立数据仓库、数据分析和数据展现。</p><h2 id="反规范化技术">反规范化技术</h2><p>牺牲部分规范化来提高性能。</p><p>可能带来的问题：数据的重复存储、数据的完整性问题。</p><h2 id="SQL语言">SQL语言</h2><p><strong>关键字</strong></p><blockquote><p>创建表：creat table</p><p>主键：primary</p><p>外键：foreign</p><p>修改：alter</p><p>删除：drop</p><p>索引：index</p><p>视图：view</p><p>数据库查询：select…from…where</p><p>分组查询：group by</p><p>别名：as</p><p>字符串匹配：like</p><p>数据库插入：insert</p><p>数据库删除：delete</p><p>数据库修改：update</p><p>排序：order by</p><p>过滤重复选项：distinct</p><p>两SQL取或运算：UNION</p><p>两SQL取与运算：INTERSECT</p><p>分组聚合函数：MIN、AVG、MAX</p></blockquote><h1>后记</h1><blockquote><p>每一段不努力的时光，都是对生命的辜负。————尼采</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-执行引擎篇</title>
      <link href="/posts/9ec3659b.html"/>
      <url>/posts/9ec3659b.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><p><strong>执行引擎的功能</strong></p><p>将字节码指令解释/编译为对应平台上的本地机器指令</p><p><strong>执行引擎的工作原理</strong></p><p>所有的Java虚拟机的执行引擎输入、输出都是一致的：<code>输入</code>的是字节码二进制流，<code>处理</code>过程是字节码解析执行的等效过程，<code>输出</code>的是执行结果。</p><p><img src="../image/post/image-20240421174951328.png" alt="image-20240421174951328"></p><h2 id="代码编译和执行的过程">代码编译和执行的过程</h2><ul><li>javac.exe的执行。由Java源码编译器来完成。</li></ul><p><img src="../image/post/image-20240421175039930.png" alt="image-20240421175039930"></p><ul><li>java.exe的执行。由JVM执行引擎来完成。</li></ul><p><img src="../image/post/image-20240421175123690.png" alt="image-20240421175123690"></p><p><strong>JAVA编译器</strong></p><ul><li>前端编译器：把.java文件转变成.class文件的过程</li><li>后端编译器（JIT）：把字节码转变成机器码的过程。</li><li>静态提前编译器（AOT）：</li></ul><p><strong>JAVA解释器</strong></p><p>当Java虚拟机启动时会根据<code>预定义的规范对字节码采用逐行解释的方式执行</code>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><blockquote><p>为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而实现解释器在运行时采用逐行解释字节码执行程序。</p></blockquote><ul><li>字节码解释器。纯软件代码模拟字节码的执行，效率非常低下</li><li>模板解释器。每一条字节码和一个模板函数相关联</li></ul><p><strong>为什么说JAVA是半编译半解释型语言</strong></p><p><img src="../image/post/image-20240421175903983.png" alt="image-20240421175903983"></p><blockquote><p>详细原因可以参考JavaGuide的面试宝典</p></blockquote><h3 id="JIT"><strong>JIT</strong></h3><p>虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><blockquote><p>为什么有了JIT还要保留解释器</p><p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p></blockquote><p><strong>热点代码及探测方式</strong></p><p>是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。</p><ul><li>方法调用计数器</li><li>回边计数器</li></ul><p><strong>JVM启动方式</strong></p><ul><li>Xint：完全采用解释器模式执行程序；</li><li>Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li><li>Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p><strong>C1和C2编译器</strong></p><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器(默认使用)。</p><ul><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。</li><li>client启动快，占用内存小，执行效率没有server快，默认情况下不进行动态编译，适用于桌面应用程序。</li></ul></li><li>-server：指定Java虚拟机运行在Server模式下，并使用C2编译器。<ul><li>C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。</li><li>server启动慢，占用内存多，执行效率高，适用于服务器端应用；</li></ul></li></ul><p><strong>C1和C2编译器的优化策略</strong></p><ul><li>C1编译器<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2编译器<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ul><blockquote><p>一般来讲，JIT编译出来的机器码性能比解释器高。<br>C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。</p></blockquote><h1>面试题</h1><p><strong>你是怎么指定JVM启动模式？（字节跳动）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM启动方式</span><br></pre></td></tr></table></figure><p><strong>那你知道-server和-client的区别吗？（美图）</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">C1</span>和<span class="built_in">C2</span>编译器</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-对象内存布局篇</title>
      <link href="/posts/59948bcd.html"/>
      <url>/posts/59948bcd.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><h2 id="对象实例化">对象实例化</h2><p><strong>创建对象的几种方式</strong></p><ul><li>new<ul><li>xxx静态方法</li><li>工厂方法</li></ul></li><li>Class的newInstance()方法，反射的方式，只能调用空参构造器且权限为public。（jdk8及之前）</li><li>Constructor的newInstance(xxx)方法，反射的方式，可以调用空参、有参的构造器，且没有权限要求。（jdk9及之后）</li><li>clone()</li><li>反序列化</li><li>第三方库，比如Objenesis，利用了asm字节码技术，动态生成Constructor对象</li></ul><p><strong>创建对象的相关字节码指令</strong></p><ul><li>NEW：将指向实例对象的引用变量压入虚拟机栈顶</li><li>DUP：在栈顶复制该引用变量，如果&lt;init&gt;方法有参数，还需要把参数压入操作栈中。</li><li>INVOKESPECIAL：调用对象实例方法，通过栈顶的引用变量调用&lt;init&gt;方法。</li></ul><blockquote><p>&lt;clinit&gt; 是类初始化时执行的方法， 而&lt;init&gt; 是对象初始化时执行的方法。</p></blockquote><p><strong>对象的创建步骤</strong></p><ol><li>判断对象对应的类是否加载、链接、初始化<ul><li>如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class 文件。</li><li>如果没有找到文件，则抛出ClassNotFoundException 异常。</li><li>如果找到，则进行类加载，并生成对应的Class类对象。</li></ul></li><li>为对象分配内存<ul><li>指针碰撞。内存规整时使用；一般垃圾回收器选择Serial、ParNew这种基于压缩算法或者带有整理过程的垃圾回收器，JVM会选择这种分配方法。</li><li>空闲列表。内存不规整时，虚拟机需要维护一个列表，使用空闲列表分配。虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li></ul></li><li>处理并发安全问题<ul><li>CAS</li><li>TLAB</li></ul></li><li>初始化分配到的空间<ul><li>内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，</li></ul></li><li>设置对象的对象头<ul><li>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。</li></ul></li><li>执行init方法进行初始化<ul><li>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</li></ul></li></ol><h2 id="对象的内存布局">对象的内存布局</h2><p><img src="../image/post/image-20240421174041955.png" alt="image-20240421174041955"></p><h3 id="对象头">对象头</h3><p>对象头主要包括两部分</p><ul><li>运行时元数据<ul><li>哈希值(hashcode)：对象在堆空间中都有一个首地址值，栈空间的引用根据这个地址指向堆中的对象，这就是哈希值起的作用</li><li>GC分代年龄：对象首先是在Eden中创建的，在经过多次GC后，如果没有被进行回收，就会在survivor中来回移动，其对应的年龄计数器会发生变化，达到阈值后会进入老年代</li><li>锁状态标志，在同步中判断该对象是否是锁</li><li>线程持有的锁</li><li>线程偏向ID</li><li>偏向时间戳</li><li>数组的长度的数据：如果是数组时。</li></ul></li><li>类型指针：确定该对象所属的类型</li></ul><h3 id="实例数据">实例数据</h3><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）。</p><blockquote><p>这里需要遵循的一些规则：<br>相同宽度的字段总是被分配在一起<br>父类中定义的变量会出现在子类之前（因为父类的加载是优先于子类加载的）<br>如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙</p></blockquote><h3 id="对齐填充">对齐填充</h3><p>对齐填充：不是必须的，也没特别含义，仅仅起到占位符的作用</p><h2 id="对象的访问定位">对象的访问定位</h2><ul><li><strong>句柄访问</strong></li></ul><p><img src="../image/post/image-20240421174534882.png" alt="image-20240421174534882"></p><ul><li><strong>直接指针</strong></li></ul><p><img src="../image/post/image-20240421174604174.png" alt="image-20240421174604174"></p><p>HotSpot主要使用直接指针访问</p><h1>面试题</h1><p><strong>new对象流程？（龙湖地产）<br>对象创建方法，对象的内存分配。（360安全）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象的创建步骤</span><br></pre></td></tr></table></figure><p><strong>Java对象头里有什么  (蚂蚁金服)</strong><br><strong>对象头信息里面有哪些东西？ (美团)</strong></p><p><strong>对象在JVM中是怎么存储的</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象的内存布局</span><br></pre></td></tr></table></figure><p><strong>对象的访问定位。（360安全）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象的访问定位</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-3.3模式分解-事务并发-封锁协议</title>
      <link href="/posts/59db49b7.html"/>
      <url>/posts/59db49b7.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li><p>模式分解</p><ul><li>保持函数依赖分解</li><li>无损分解</li></ul></li><li><p>事务并发</p></li><li><p>封锁协议</p></li></ul><h1>中论</h1><h2 id="模式分解">模式分解</h2><h3 id="保持函数依赖分解">保持函数依赖分解</h3><p>对于关系模式R，有依赖集F，<strong>若对R进行分解，分解出来的多个关系模式，保持原来的依赖集不变</strong>，则称为保持函数依赖分解。</p><p>保持函数依赖的判断：</p><ol><li><p>如果F上的每一个函数依赖都在其分解后的某一个关系上成立，则这分解就是保持函数依赖分解。（充分条件）</p><blockquote><p>看分解后的集合，每一个集合是否都能推出函数依赖集，如果都能则是保持函数依赖，反之不保持。</p><p>（注意：这个推出不包含<strong>传递依赖推导出</strong>。比如A–&gt;B，B–&gt;C。则分解的U={A,B}，就不是保持函数依赖分解。因为A–&gt;B，但是没有A–&gt;C。</p></blockquote></li><li><p>如果1不能确定是保持函数依赖分解，有方法2。略。</p></li></ol><h2 id="无损分解">无损分解</h2><p>分解后的关系模式能够还原出原关系模式，就是无损分解，不能还原的就是有损。</p><p>无损分解的判断：</p><ol><li><code>分解为两个关系模式时</code>，如果R分解为p={R1,R2}，F为R所满足的函数依赖集合，分解p具有无损连接性的充分必要条件是<code>R1∩R2--&gt;(R1-R2)或者R1∩R2--&gt;(R2-R1)</code>。</li><li><code>分解为三个或三个以上关系模式时</code>，表格法。<ol><li>构建初始表。行为每个分解的表，列为分解后的列取并集</li><li>首先根据分解后的表，在对应格子打钩</li><li>然后根据函数依赖打钩</li><li>最后只要有一列全是钩，则是无损分解</li></ol></li></ol><h2 id="并发控制">并发控制</h2><h3 id="事务">事务</h3><ul><li>原子性：要么全做，要么不做</li><li>隔离性：任一事务的更新操作直到成功提交之前对其他事务不可见</li><li>一致性：事务发生后数据一致</li><li>持续性：事务操作结果是持续的</li></ul><p><strong>并发控制的问题</strong></p><ul><li>丢失更新</li><li>不可重复读</li><li>读脏数据</li></ul><p><img src="../image/post/image-20240419211430996.png" alt="image-20240419211430996"></p><h2 id="封锁协议">封锁协议</h2><ul><li>X锁是排他锁（写锁）。某事务对数据A加此锁，其他事务都不可对A加任何锁。</li><li>S锁是共享锁（读锁）。某事务对数据A加此锁，其他事务只可以对A加S锁。</li></ul><p><strong>一级封锁协议</strong></p><p>在事务修改数据A之前先对其加X锁，直到事务结束释放。<strong>可解决丢失更新问题。</strong></p><p><img src="../image/post/image-20240419211755086.png" alt="image-20240419211755086"></p><p><strong>二级封锁协议</strong></p><p>在一级封锁协议的基础上，事务在读数据R之前必须先对其加S锁，读完后即可释放S锁。<strong>可解决读脏数据、丢失更新的问题。</strong></p><p><img src="../image/post/image-20240419211927173.png" alt="image-20240419211927173"></p><p><strong>三级封锁协议</strong></p><p>在一级封锁协议的基础上，事务在读取数据R之前先对其加S锁，知道事务结束才释放。<strong>可解决丢失更新、读脏数据、数据重复读的问题。</strong></p><p><img src="../image/post/image-20240419212047920.png" alt="image-20240419212047920"></p><blockquote><p>一级：侧重写的时候加X锁。</p><p>二级：在一级的基础上，侧重读的时候加S锁，读完即释放。</p><p>三级：在一级的基础上，侧重读的时候加S锁，事务结束释放。</p></blockquote><h1>后记</h1><blockquote><p>真的要自己争气，人一旦做出成绩来，全世界都和颜悦色。——————佚名</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-3.2关系代数-函数依赖-范式</title>
      <link href="/posts/108d9810.html"/>
      <url>/posts/108d9810.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>关系代数</li><li>函数依赖</li><li>键与约束</li><li>范式</li></ul><h1>中论</h1><h2 id="关系代数">关系代数</h2><p>并(∪)：两张表中所有记录数合并，<strong>相同记录只显示一次</strong></p><p>交(∩)：两张表中相同的记录数</p><p>差(S1-S2)：s1表中有但s2表中没有的记录</p><p>笛卡尔积(S1×S2)：S1中每条记录依次和S2中的所有记录组合成一条记录，最终形成一张S1+S2个属性列，S1*S2个记录数</p><p>投影(π)：根据条件选择某关系模式中的<strong>某列</strong></p><p>选择(σ)：根据条件选择某关系模式中的<strong>某条记录</strong></p><p>自然连接(∞)：显示两表全部的属性列，相同属性列只显示一次；显示属性相同且值相同的记录。</p><h2 id="函数依赖">函数依赖</h2><p>给定一个X，能唯一确定一个Y，则称X确定Y；或者Y依赖于X。</p><ul><li>部分函数依赖：A确定C，(A,B)也能确定C，则称部分函数依赖。(A,B)的一部分能确定C</li><li>传递函数依赖：<strong>A和B不等价时</strong>，A可以确定B，B确定C，则A确定C，则成为传递函数依赖。</li></ul><h2 id="键与约束">键与约束</h2><p>超键：能唯一标识此表属性的<strong>组合</strong></p><p>候选键：超键中去掉冗余的属性，剩余的属性就是候选键</p><p>主键：任选一个候选键，即可作为主键</p><p>外键：其他表中的主键</p><p>主属性（码）：候选键内的属性为主属性，其他属性为非主属性</p><blockquote><p>实体完整性约束：主键约束。主键值不能为空，也不能重复</p><p>参照完整性约束：外键约束。外键必须是其他表中已经存在的主键的值或者空。</p><p>用户自定义完整性约束：自定义表达式约束</p></blockquote><h2 id="范式">范式</h2><h3 id="第一范式（1NF）"><strong>第一范式（1NF）</strong></h3><p>关系中的每一个分量必须是一个不可分的数据项。<strong>即表中不允许有更小的表。</strong></p><h3 id="第二范式（2NF）"><strong>第二范式（2NF）</strong></h3><p>如果关系R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。<strong>即表中每一个非主属性不会依赖复合主键中的某一列。</strong></p><h3 id="第三范式（3NF）"><strong>第三范式（3NF）</strong></h3><p>在满足1NF的基础上，表中不存在非主属性对主属性的传递依赖。</p><h3 id="BC范式（BCNF）">BC范式（BCNF）</h3><p>在第三范式的基础上，进一步消除主属性对码的部分函数依赖和传递依赖。即每个依赖的左边决定因素都必然包含候选键。</p><blockquote><p>2NF、3NF都是非主属性对主属性</p><p>BCNF是主属性对主属性</p></blockquote><h1>后记</h1><blockquote><p>不够真诚是危险的，太过真诚是致命的。</p><p>——————王尔德</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-字符编码</title>
      <link href="/posts/a68a97fd.html"/>
      <url>/posts/a68a97fd.html</url>
      
        <content type="html"><![CDATA[<h1>字符编码</h1><h2 id="ASCII码">ASCII码</h2><p>使用 7 位二进制数（一个字节的低 7 位）表示一个字符，最多能够表示 128 个不同的字符。</p><blockquote><p>仅能够表示英文</p></blockquote><h2 id="GBK码">GBK码</h2><p>GB2312字符集收录了汉字，GBK码是GB2313的拓展。</p><blockquote><p>在 GBK 的编码方案中，ASCII 字符使用一个字节表示，汉字使用两个字节表示。</p></blockquote><h2 id="Unicode码">Unicode码</h2><p>国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。</p><blockquote><p>每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应，这里的二进制数值也叫 <strong>码点</strong></p></blockquote><h2 id="UTF-8编码">UTF-8编码</h2><p>一种可变长度的编码，使用1到4字节来表示一个字符，根据字符的复杂性而变。</p><ul><li><p>ASCII字符1字节</p></li><li><p>拉丁字母和希腊字母2字节</p></li><li><p>常用的中文字符3字节</p></li><li><p>其他的一些生僻字符4字节。</p></li></ul><blockquote><p>UTF-8编码是Unicode码的一种实现方式</p></blockquote><h2 id="UTF-16编码">UTF-16编码</h2><p>使用2或4字节来表示一个字符。</p><h2 id="UTF-32编码">UTF-32编码</h2><p>每个字符都使用4字节。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-3.1三级模式-数据库设计-数据模型</title>
      <link href="/posts/463edc9a.html"/>
      <url>/posts/463edc9a.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>三级模式</li><li>数据库设计</li><li>数据模型<ul><li>数据模型三要素</li><li>E-R模型</li><li>关系模型</li><li>两种模型之间的转换</li></ul></li></ul><h1>中论</h1><h2 id="三级模式-两级映像">三级模式-两级映像</h2><p><img src="../image/post/image-20240416222927031.png" alt="image-20240416222927031"></p><p>自上而下：</p><p><strong>三级模式</strong></p><ul><li><p>外模式（子模式、用户模式）：某个或某几个用户所看到的数据库的<code>数据视图</code>，是与某一应用有关的数据的逻辑表示。<em>用户可以用外模式描述语言来表述和定义对应的用户的数据，也可以利用数据操纵语言（DML）来对这些数据记录进行描述和定义</em></p><blockquote><p>DML：数据操纵语言，比如增、删、改、查，对数据库进行一些基本操作。</p></blockquote></li><li><p>模式（概念模式、逻辑模式）：是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的<code>全局视图</code>，<em>它由数据库管理系统提供的数据模式描述语言(DDL)来描述和定义</em></p><blockquote><p>DDL：数据模式定义语言。比如创建、修改、删除表操作，用来定义或者改变表的结构。</p></blockquote></li><li><p>内模式（存储模式、物理结构）：是数据库中全体数据的内部表示或者底层描述，描述了数据在存储介质上的存储方式和物理结构。</p><blockquote><p>一个数据库系统中，只有一个唯一的数据库。</p></blockquote></li></ul><p><strong>两级映像</strong>：保证逻辑数据独立性和物理数据独立性</p><p>外模式-模式映像（逻辑数据独立性）：视图和基本表之间的映射，存在于概念级和外部级之间，若表中数据发生了修改，只需要修改此映射，无需修改应用程序就可以保持外模式不变（仍旧是某个记录）。</p><p>模式-内模式映像（物理数据独立性）：基本表和物理存储文件之间的映射，存在于概念级和内部级之间，若修改了数据存储方式，只需要修改此映射，而不需要去修改应用程序就可以保持模式不变（仍旧是某个表）。</p><h2 id="数据库设计">数据库设计</h2><p><img src="../image/post/image-20240416224512176.png" alt="image-20240416224512176"></p><ol><li><p>需求分析：分析数据存储要求。产出：数据流图、数据字典、需求说明书。</p></li><li><p>概念结构设计：设计E-R图，包括设计分E-R图、合并E-R图。产出：E-R图。</p><blockquote><p>E-R图合并时可能会有3种冲突</p><ul><li>属性冲突</li><li>命名冲突</li><li>结构冲突</li></ul></blockquote></li><li><p>逻辑结构设计：将E-R图转换成关系模式。</p></li><li><p>物理设计</p></li><li><p>数据图实施阶段</p></li><li><p>数据库运行和维护阶段</p></li></ol><h2 id="数据模型">数据模型</h2><p>数据模型三要素：数据结构、数据操作、数据的约束条件</p><p><strong>E-R模型</strong></p><p>E-R模型描述概念数据模型</p><ul><li>椭圆：属性，通常没有属性</li><li>长方形：实体，长方形内俩竖线表示<code>弱实体</code></li><li>菱形：联系，联系的两端填写联系类型</li></ul><p>术语：</p><ul><li>实体：客观存在并可相互区别的事物。可以是具体的人、事、物或者抽象概念。</li><li>弱实体和强实体：弱实体依赖于强实体的存在而存在。</li><li>实体集：相同类型和共享相同属性的实体的集合，比如学生、课程</li><li>属性：实体所具有的特征。</li><li>属性分类：简单属性、复合属性；单值属性、多值属性。</li><li>域：属性的取值范围</li><li>码：唯一标识实体的属性集</li><li>联系：事物内部以及事物之间的联系</li><li>联系类型：一对一、一对多、多对多</li></ul><p><strong>关系模型</strong></p><p>关系模型中的数据逻辑结构是一张二维表。</p><p><strong>模型转换</strong></p><p>主要指E-R模型转换成关系模型</p><ul><li>每一个实体都对应一个关系模式</li><li>联系的转化<ul><li>一对一，联系可以放到任意两端的实体中，作为一个属性，也可以转换为一个单独的关系模式</li><li>一对多，联系可以单独作为一个关系模式，也可以在N端加入1端实体的主键</li><li>多对多：联系必须作为一个单独的关系模式，其主键是M端和N端的联合主键</li></ul></li></ul><h1>后记</h1><blockquote><p>不要同情自己，同情自己是卑劣懦夫干的勾当。</p><p>​———— 树上春树《挪威的森林》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-运行时内存篇</title>
      <link href="/posts/2feec107.html"/>
      <url>/posts/2feec107.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><p><strong>HotSpotVM内存结构</strong></p><p><img src="../image/post/image-20240416071244726.png" alt="image-20240416071244726"></p><p>或者和第一篇-字节码篇的HotSpotVM图一样即可。</p><p><strong>哪些内存结构和线程一一对应</strong></p><p>和线程一一对应即<em>线程私有</em>：程序计数器、本地方法栈、虚拟机栈都是线程私有。</p><h2 id="程序计数器">程序计数器</h2><p><strong>作用</strong></p><p>程序计数器用来存储指向<code>下一条指令的地址</code>。CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p><img src="../image/post/image-20240416071939773.png" alt="image-20240416071939773"></p><p>指令地址即PC程序计数器存放的地址。执行Native方法时程序计数器为undefined，因为native方法为C语言实现，没有被编译成字节码指令。</p><p><strong>基本特征</strong></p><ul><li>很小的一块内存空间，几乎可以忽略不计，也是运行速度最快的存储区域，大小不会随着程序的运行而变化。</li><li>线程私有，生命周期和线程的生命周期相同。</li><li>唯一一个在JVM规范中没有规定任何OutOfMemoryError场景的区域。</li></ul><h2 id="虚拟机栈">虚拟机栈</h2><p>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。</p><ul><li>线程私有</li><li>生命周期和线程生命周期相同</li><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>栈中不存在GC，但存在OOM</li><li>Java栈的大小是动态的或者是固定不变的(抛出的异常也不同)</li></ul><blockquote><p>栈和堆：</p><p>栈管运行：保存局部变量（8中基本数据类型、对象的引用地址）、部分结果、方法调用和返回</p><p>堆管存储：保存成员变量、属性、引用类型变量（类、数组、接口）</p></blockquote><p><strong>可能抛出的异常</strong></p><p>StackOverFlowError：如果采用固定大小的Java虚拟机栈，超过最大容量，将会抛出一个StackOverflowError异常</p><p>OutOfMemoryError：如果Java虚拟机栈可以动态扩展，在尝试扩展或者创建新的线程时,没有足够的内存去创建对应的虚拟机栈，将会抛出—个OutOfMemoryError异常。</p><blockquote><p>原因：1.局部变量表占用大</p><p>2.栈调用次数过多</p></blockquote><p><strong>如何设置栈大小</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss <span class="title function_">size</span> <span class="params">(即：-XX:ThreadStackSize)</span></span><br></pre></td></tr></table></figure><p>jdk5.0之前，默认栈大小：256k<br>jdk5.0之后，默认栈大小：1024k</p><blockquote><p>栈大小不能设置过大，否则会导致系统用于创建线程的数量减少。（栈大，导致线程变大）</p></blockquote><h3 id="栈帧">栈帧</h3><p>即栈的单位。每个栈帧对应代码中的一个方法。</p><ul><li>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</li></ul><p><strong>内部结构</strong></p><ul><li>局部变量表</li><li>操作数栈</li><li>动态链接</li><li>方法返回地址</li><li>附加信息</li></ul><h4 id="局部变量表"><strong>局部变量表</strong></h4><ul><li>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</li><li>局部变量表所需的容量大小是在编译期确定下来的，在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小决定</li><li>局部变量表中的变量只在当前方法（栈帧）调用中有效</li></ul><p><strong>是否会有线程安全问题</strong></p><p>基本数据类型（栈私有）不会有线程安全问题，引用数据类型（局部变量表存放的地址）实际在堆中，会有线程安全问题</p><p><strong>局部变量表的Slot</strong></p><ul><li>参数值的存放总是在局部变量数组的index为0开始，到数组长度-1的索引结束。</li><li>局部变量表，最基本的存储单元是Slot（变量槽）</li><li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double)占用两个slot。</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</li><li>如果当前帧是由<code>构造方法</code>或者<code>实例方法</code>创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li><li>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</li></ul><p><strong>局部变量和静态变量的区别</strong></p><p>系统会给静态变量初始化初值，但不会给局部变量初始化初值，使用时必须初始化。</p><p><strong>和GC Roots的关系</strong></p><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h4 id="操作数栈">操作数栈</h4><ul><li>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</li><li>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了</li><li>栈中的任何一个元素都是可以任意的Java数据类型，32bit的类型占用一个栈单位深度，64bit的类型占用两个栈单位深度</li><li>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据来完成一次数据访问。<em>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作</em></li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</li></ul><p><strong>操作数栈和局部变量表对比</strong></p><p>局部变量首先从内存放入操作数栈，然后再存入局部变量表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码分析：</p><p><img src="../image/post/image-20240421080145919.png" alt="image-20240421080145919"></p><p><img src="../image/post/image-20240421080154467.png" alt="image-20240421080154467"></p><p><img src="../image/post/image-20240421080201508.png" alt="image-20240421080201508"></p><p><img src="../image/post/image-20240421080208260.png" alt="image-20240421080208260"></p><p><img src="../image/post/image-20240421080219900.png" alt="image-20240421080219900"></p><p><img src="../image/post/image-20240421080227652.png" alt="image-20240421080227652"></p><p><img src="../image/post/image-20240421080235350.png" alt="image-20240421080235350"></p><p><img src="../image/post/image-20240421080242276.png" alt="image-20240421080242276"></p><p><strong>栈顶缓存技术</strong></p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p><h4 id="动态链接">动态链接</h4><p>动态链接即指向运行时常量池的方法引用。</p><ul><li>描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。比如：invokedynamic指令。</li></ul><blockquote><p>静态链接、动态链接、早期绑定、晚期绑定</p><hr><ul><li>静态连接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在<code>编译期可知</code>，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li><li>动态链接：如果被调用的方法在<code>编译期无法被确定下来</code>，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li></ul><hr><p>绑定：链接对应的绑定机制。是一个字段、方法或者类在符号引用被替换为直接引用的<code>过程</code>，仅仅发生一次。</p><ul><li><p>早期绑定：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p></li><li><p>晚期绑定：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p></li></ul></blockquote><blockquote><p>非虚方法、虚方法</p><p>如果一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><ul><li>非虚方法：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。比如：静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>虚方法：运行时确定调用版本，除非虚以外的其他方法称为虚方法。</li></ul></blockquote><blockquote><p>方法重写的本质</p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li><li>如果在过程结束；类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过，则返回 java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常。</li></ol></blockquote><blockquote><p>虚方法表</p><ul><li>在面向对象的编程中，会很频繁的使用到动态分派。为了提高性能，JVM采用在类的<code>方法区</code>建立一个<code>虚方法表</code></li><li>非虚方法不会出现在表中来实现。使用<code>索引表</code>来代替查找。</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>虚方法表会在类加载的<code>链接阶段</code>被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</li></ul></blockquote><h4 id="方法返回地址">方法返回地址</h4><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；<ul><li>在字节码指令中，返回指令包含ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</li></ul></li><li>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。<ul><li>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</li></ul></li></ol><h2 id="本地方法栈">本地方法栈</h2><p><strong>本地方法</strong></p><p>一个Java调用非Java代码的接口</p><ul><li>通过native关键字修饰<ul><li>System.currentTimeMillis()方法</li><li>Thread类的start()内部</li></ul></li><li>标识符native可以与所有其它的java标识符连用，但是abstract除外。</li></ul><p><strong>本地方法栈</strong></p><ul><li>线程私有</li><li>大小可配置</li></ul><h2 id="堆">堆</h2><ul><li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li><li>Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</li><li>堆内存的大小是可以调节的。</li><li>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</li></ul><h4 id="堆的内部结构">堆的内部结构</h4><p><img src="../image/post/image-20240421083827197.png" alt="image-20240421083827197"></p><p>JDK7及之前：新生代、老年代、永久代</p><p>JDK8及之后：新生代、老年代、元空间</p><p><strong>新生代和老年代</strong></p><ul><li><p>新生代：生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</p><ul><li>新生代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</li><li>几乎所有的Java对象都是在Eden区被new出来的</li><li>绝大部分的Java对象的销毁都在新生代进行了。</li></ul></li><li><p>老年代：生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</p></li></ul><h4 id="堆的参数设置">堆的参数设置</h4><p><strong>设置堆内存大小</strong></p><ul><li>&quot;-Xms&quot;用于表示堆区的起始内存，等价于-XX:InitialHeapSize</li><li>&quot;-Xmx&quot;则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</li><li>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError:heap异常。</li><li>通常会将 -Xms 和 -Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</li><li>堆默认最大值计算方式：如果物理内存少于192M,那么heap最大值为物理内存的一半。如果物理内存大于等于1G，那么heap的最大值为物理内存的1/4。</li><li>堆默认最小值计算方式：最少不得少于8M，如果物理内存大于等于1G，那么默认值为物理内存的1/64，即1024/64=16M。最小堆内存在jvm启动的时候就会被初始化。</li></ul><p><strong>设置新生代和老年代的比例</strong></p><p><code>-XX:NewRatio=参数</code></p><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p><p>可以使用选项”-Xmn”设置新生代最大内存大小。这个参数一般使用默认值就可以了。</p><p><strong>设置Eden、幸存者区比例</strong></p><p><code>-XX:SurvivorRatio=参数</code></p><p>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1。可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8</p><p><strong>设置新生代垃圾的最大年龄</strong></p><p><code>-XX:MaxTenuringThreshold=参数</code></p><p><strong>设置空间分配担保（已失效）</strong></p><p><code>-XX:HandlePromotionFailure=参数</code></p><h4 id="空间分配担保">空间分配担保</h4><blockquote><p>幸存者s0,s1区：复制之后有交换，谁空谁是to</p><p>垃圾回收：频繁在新生区收集；很少在养老区收集；几乎不在永久区/元空间收集</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>new的对象先放伊甸园区。此区有大小限制。</span><br><span class="line"><span class="number">2.</span>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/YGC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</span><br><span class="line"><span class="number">3.</span>然后将伊甸园中的剩余对象移动到幸存者<span class="number">0</span>区。</span><br><span class="line"><span class="number">4.</span>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者<span class="number">0</span>区的，如果没有回收，就会放到幸存者<span class="number">1</span>区。</span><br><span class="line"><span class="number">5.</span>如果再次经历垃圾回收，此时会重新放回幸存者<span class="number">0</span>区，接着再去幸存者<span class="number">1</span>区。</span><br><span class="line"><span class="number">6.</span>啥时候能去养老区呢？可以设置次数。默认是<span class="number">15</span>次。</span><br><span class="line">可以设置参数：-XX:MaxTenuringThreshold=&lt;N&gt; 设置对象晋升老年代的年龄阈值。</span><br><span class="line"><span class="number">7.</span>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</span><br><span class="line"><span class="number">8.</span>若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><p><strong>内存分配策略</strong></p><p>如果对象在Eden 出生并经过第一次MinorGC 后仍然存活，并且能被Survivor 容纳的话，将被移动到Survivor 空间中，并将对象年龄设为1 。对象在Survivor 区中每熬过一次MinorGC ， 年龄就增加1岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中。</p><p><strong>内存分配原则</strong></p><ul><li>优先分配到Eden</li><li>大对象直接分配到老年代<ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</li></ul></li><li>空间分配担保<br>-XX:HandlePromotionFailure</li></ul><h4 id="MinorGC、MajorGC、FullGC">MinorGC、MajorGC、FullGC</h4><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li>部分收集：<ul><li>新生代收集（Minor GC / Young GC）：只是新生代（Eden\S0,S1）的垃圾收集</li><li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集<ul><li>目前，只有CMS GC会有单独收集老年代的行为</li><li>很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC)：收集整个新生代以及部分老年代的垃圾收集<ul><li>目前，只有G1 GC会有这种行为</li></ul></li></ul></li><li>整堆收集（Full GC)：收集整个java堆和方法区的垃圾收集</li></ul><p><strong>MinorGC触发机制</strong></p><ul><li>当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)</li><li>因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li><li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li></ul><p><strong>老年代GC（Major GC/Full GC）触发机制</strong></p><ul><li>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。<ul><li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</li><li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li></ul></li><li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li><li>如果Major GC 后，内存还不足，就报OOM了。</li></ul><p><strong>FullGC触发机制</strong></p><ul><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul><p><code>说明：full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。</code></p><p><strong>堆中出现OOM如何解决</strong></p><ul><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul><p><strong>为什么需要把Java堆分代？</strong></p><p>优化GC性能。</p><h4 id="TLAB">TLAB</h4><p><strong>为什么需要TLAB</strong></p><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li></ul><p><strong>什么是TLAB</strong></p><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</li><li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选</li><li>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</li><li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。</li></ul><p><img src="../image/post/image-20240421090222960.png" alt="image-20240421090222960"></p><h2 id="方法区">方法区</h2><blockquote><p>存放内容：用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</p><ul><li>存放类型信息。① 这个类型的完整有效名称（全名=包名.类名）② 这个类型直接父类的完整有效名(对于interface或是java.lang.Object，都没有父类) ③ 这个类型的修饰符(public,abstract, final的某个子集) ④ 这个类型直接接口的一个有序列表</li><li>域信息。域名称、域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)</li><li>方法信息。名称、返回类型、参数数量和类型、修饰符、字节码、异常表</li><li>运行时常量池。用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。【运行时常量池：数量值、字符串值、类引用、字段引用、方法引用】</li></ul></blockquote><p>方法区看作是一块独立于堆的内存空间，逻辑上是堆的一部分。</p><ul><li>方法区与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li><strong>方法区的大小决定了系统可以保存多少个类</strong><ul><li>方法区也会报OOM。通常因为创建的类过多且没有销毁；加载大量第三方jar包。</li></ul></li><li>关闭JVM就会释放这个区域的内存</li></ul><p><strong>堆、栈、方法区的关系</strong></p><p><img src="../image/post/image-20240421090304190.png" alt="image-20240421090304190"></p><p><strong>元空间和方法代的区别</strong></p><p>元空间不在虚拟机设置的内存中，而是使用本地内存。</p><p><strong>方法区参数设置</strong></p><p>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定</p><p><strong>为什么永久代要被元空间替换</strong></p><ul><li>为永久代设置空间大小是很难确定的。</li><li>对永久代进行调优是很困难的。</li></ul><p><strong>为什么StringTable要调整</strong></p><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><p><strong>方法区是否存在GC</strong></p><p>主要回收两部分内容：常量池中废弃的常量和不再使用的类型。只要常量池中的常量/类型没有被任何地方引用，就可以被回收。</p><ul><li>判断常量和判断Java堆中的对象类似</li><li>判断类比较麻烦<ul><li>该类所有的实例（父子类）都已经被回收</li><li>加载该类的类加载器已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li><li><code>有以上三种条件是回收的充分条件，不一定都满足就一定被回收。</code></li></ul></li></ul><h2 id="直接内存">直接内存</h2><p>直接内存是在Java堆外的、直接向系统申请的内存区间</p><p>特点：</p><ul><li>来源于<code>NIO</code>，通过存在堆中的DirectByteBuffer操作Native内存<ul><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul></li><li>访问直接内存的速度会优于Java堆。即读写性能高</li><li>出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li><li>直接内存大小可以通过MaxDirectMemorySize设置</li><li>如果不指定，默认与堆的最大值-Xmx参数值一致</li></ul><p>缺点：</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li><li>也可能导致OutOfMemoryError异常</li></ul><h1>面试题</h1><h2 id="程序计数器-2">程序计数器</h2><p><strong>程序计数器如何计数</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code"></span>## 虚拟机栈</span><br><span class="line"></span><br><span class="line"><span class="strong">**堆和栈的区别、谁的性能更高（艾绒软件）**</span></span><br><span class="line"><span class="strong">**为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？  (阿里)**</span></span><br><span class="line"><span class="strong">**Java 中堆和栈有什么区别？（国美）**</span></span><br><span class="line"><span class="strong">**栈和堆的区别？（蚂蚁金服）**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角度一：GC;OOM<br>角度二：栈、堆执行效率<br>角度三：内存大小；数据结构<br>角度四：栈管运行；堆管存储。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**什么情况下会发生栈内存溢出（<span class="number">360</span>）</span><br><span class="line">栈存在内存溢出吗 <span class="comment">(京东)</span></span><br><span class="line">说一下什么情况发生栈溢出 <span class="comment">(滴滴)</span>**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虚拟机栈-可能抛出的异常。<br>场景：<br>一、局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。<br>二、递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**栈是如何运行的（OPPO）**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**JVM有哪些组成，堆，栈各放了什么东西。（新浪）**</span></span><br><span class="line"><span class="strong">**怎么理解栈、堆？堆中存什么？栈中存什么？(阿里)**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆的内部结构、栈帧的内部结构</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 堆</span></span><br><span class="line"></span><br><span class="line">**<span class="keyword">Java </span>堆的结构是什么样子的？（猎聘）</span><br><span class="line"><span class="keyword">JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor（字节跳动）</span></span><br><span class="line"><span class="keyword"></span>堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。（京东-物流）</span><br><span class="line">堆的结构？为什么两个survivor区？  (蚂蚁金服)</span><br><span class="line">Eden和Survior的比例分配  (蚂蚁金服)</span><br><span class="line"><span class="keyword">JVM内存分区，为什么要有新生代和老年代 </span>(小米)</span><br><span class="line"><span class="keyword">JVM的内存结构，Eden和Survivor比例。 </span> (京东)</span><br><span class="line"><span class="keyword">JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 </span> (京东)</span><br><span class="line"><span class="keyword">JVM内存分区，为什么要有新生代和老年代？ </span> (美团)</span><br><span class="line"><span class="keyword">JVM的内存结构，Eden和Survivor比例。 </span> (京东)**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆的内部结构</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**堆大小通过什么参数设置？  (阿里)**</span></span><br><span class="line"><span class="strong">**初始堆大小和最大堆大小一样，问这样有什么好处？（亚信）**</span></span><br><span class="line"><span class="strong">**JVM中最大堆大小有没有限制？ (阿里)**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆的参数设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**什么是空间分配担保策略？（渣打银行）</span></span><br><span class="line"><span class="strong">什么是空间分配担保策略？（顺丰）</span></span><br><span class="line"><span class="strong">什么是空间分配担保策略？（腾讯、百度）**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>空间分配担保</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**什么时候对象会进入老年代？（渣打银行）</span><br><span class="line">什么时候对象会进入老年代？（顺丰）</span><br><span class="line">问什么幸存者区<span class="number">15</span>次进入老年区，懂原理吗？（<span class="number">58</span>）</span><br><span class="line">JVM的伊甸园区，from区，to区的比例是否可调？（花旗银行）</span><br><span class="line">JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代（字节跳动）</span><br><span class="line">什么时候对象会进入老年代？  <span class="comment">(字节跳动)</span></span><br><span class="line">对象在堆内存创建的生命周期  <span class="comment">(蚂蚁金服)</span></span><br><span class="line">重点讲讲对象如何晋升到老年代，几种主要的JVM参数  <span class="comment">(蚂蚁金服)</span></span><br><span class="line">新生代和老年代的内存回收策略 <span class="comment">(蚂蚁金服)</span></span><br><span class="line">什么时候对象可以被收回？ <span class="comment">(蚂蚁金服)</span>**</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MinorGC、MajorGC、FullGC</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**JVM的永久代中会发生垃圾回收么?（腾讯）**</span></span><br><span class="line"><span class="strong">**JVM的永久代中会发生垃圾回收吗？(美团)**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>永久代</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**<span class="keyword">new</span> <span class="built_in">string</span>()是放在哪里，还放在哪里？（搜狐、万达集团）**</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Java 6及以前，字符串常量池存放在永久代。</li><li>Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内。</li><li>Java 8 中，字符串常量仍然在堆。</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="strong">**讲一下为什么JVM要分为堆、方法区等？原理是什么？（UC、智联）**</span></span><br><span class="line"><span class="strong">**JVM的分区了解吗，内存溢出发生在哪个位置 （亚信、BOSS）**</span></span><br><span class="line"><span class="strong">**简述各个版本内存区域的变化？（猎聘）**</span></span><br><span class="line"><span class="strong">**Java8的内存分代改进  (蚂蚁金服)**</span></span><br><span class="line"><span class="strong">**JVM的内存模型，Java8做了什么修改  (天猫)**</span></span><br><span class="line"><span class="strong">**OOM的错误，StackOverFlow错误，permgen space的错误  (蚂蚁金服)**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>综上</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-2.3节设备管理-文件管理</title>
      <link href="/posts/93ff32be.html"/>
      <url>/posts/93ff32be.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li><p>设备管理</p><ul><li>IO设备管理软件层级</li></ul></li><li><p>文件管理</p><ul><li>文件的物理结构</li><li>文件目录</li><li>文件存储空间管理</li></ul></li></ul><h1>中论</h1><h2 id="设备管理">设备管理</h2><p>设备分类（了解）：</p><ul><li>按数据组织分类：块设备、字符设备</li><li>按设备功能分类：输入设备、输出设备、存储设备、网络联网设备、供电设备</li><li>按资源分配分类：独占设备、共享设备、虚拟设备</li><li>按数据传输速度：低速设备、中速设备、高速设备</li></ul><p>设备管理：分配和管理各种设备，动态掌握并记录设备的状态</p><p><strong>IO设备管理软件层级（重要）</strong></p><p><img src="../image/post/image-20240415220909847.png" alt="image-20240415220909847"></p><blockquote><p>层级：用户进程–&gt;设备无关软件–&gt;设备驱动程序–&gt;中断处理程序–&gt;硬件</p></blockquote><p>以用户读取硬盘文件为例：</p><p>用户进程读取硬盘文件时，操作系统中与设备无关软件检查高速缓存Cache中有无要读的数据块，没有则调用设备驱动程序向I/O硬件发出一个请求。之后，用户进程阻塞并等待磁盘操作的完成。当磁盘操作完成时，硬件产生一个中断，转入中断处理程序。中断处理程序检查中断产生原因，如果是磁盘读取操作已经完成，则唤醒用户进程读取信息，最后结束此次I/O请求。</p><p><strong>SPOOLING技术</strong></p><p>SPOOLING（外围设备联机操作）。一台独占设备（比如打印机），在同一时间只能由一个进程使用，其他进程只能等待，却不知道什么时候可以使用。引入SPOOLING技术，在外设上建立两个数据缓冲区，分别称为输入井和输出井。无论多少进程，只要发出打印命令，数据就会排队存储在缓冲区中，打印机按照顺序打印。</p><h2 id="文件管理">文件管理</h2><p>文件管理：操作系统中实现文件统一管理的一组软件和相关数据的集合，专门负责管理和存取文件信息的软件机构。</p><p><strong>文件的逻辑结构</strong></p><ul><li><p>流式文件：指文件中的数据不再组成记录，只是由一串依次的字节组成的信息流序列。<br>这种文件常按照长度来读取所需的信息，也可以用插入的特殊字符作为分界。</p></li><li><p>记录式文件：是一种有结构的文件，它是若干逻辑记录信息所组成的记录流文件<br>逻辑记录式文件中按信息在逻辑上的独立含义所划分的信息单位，如每个职工的工资信息是一个逻辑记录，整个单位的工资信息便组成了该单位工资信息的记录式文件。</p></li></ul><blockquote><p><strong>记录式文件与数据库的区别</strong><br>数据库管理系统也支持逻辑记录，但数据库有别于记录式文件，数据库中的记录之间可以通过数据冗余构成某种联系，数据库管理系统支持基于联系的数据查询，文件系统则不行。</p></blockquote><p><strong>文件的物理结构</strong>（掌握计算）</p><ul><li>连续结构：存放在连续编号的物理块上</li><li>链接结构：每一个物理块有一个指针指向下一个物理块</li><li>索引结构：为每个文件信息建立一张索引表，表记录了文件信息所在的逻辑块号对应的物理块号。</li></ul><p><strong>文件目录（掌握文件路径）</strong></p><p>文件目录：文件控制块的有序集合</p><p>文件控制块：</p><ul><li>基本信息。文件名、物理地址、长度、块数等</li><li>存取控制信息类。文件的存取权限</li><li>使用信息类。文件建立日期、最后一次修改日期等</li></ul><p>相对路径：从当前路径开始的路径（注意，通常相对路径开头不带<code>\</code>）。</p><p>绝对路径：从根目录开始的路径</p><p>全文件名：绝对路径 + 文件名。</p><p><strong>文件存储空间管理（掌握计算）</strong></p><p>文件存取：读/写文件存储器上的一个物理块的方法。有顺序存取和随机存取两种方法。</p><p><strong>管理方法</strong></p><ul><li>空闲区表</li><li><strong>位示图</strong>（掌握计算方法）：在外存上建立一张位示图（Bitmap），记录文件存储器的使用情况。每一位对应文件存储器上的一个物理块，取值0或1，分别表示空闲或占用。</li><li>空闲块链</li><li>成组链接法</li></ul><h1>后记</h1><blockquote><p>我们是被时间放牧的羊群，埋首生活，忘记抬头看云。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-算法复杂度</title>
      <link href="/posts/6a270633.html"/>
      <url>/posts/6a270633.html</url>
      
        <content type="html"><![CDATA[<h1>算法复杂度</h1><h2 id="递归和迭代">递归和迭代</h2><p><strong>递归比迭代更加耗费内存空间</strong>，因为函数的上下文数据都存储在栈空间中，直到函数返回才被释放。</p><p><strong>递归比迭代更加耗费时间</strong>，因为递归调用函数会有额外的开销。</p><blockquote><p>如果函数递归调用为尾递归，则经过编译器、解释器优化可以在空间效率上和迭代差不多。</p><p><strong>尾递归</strong>：<code>return 递归函数</code>，即返回递归的函数。</p></blockquote><h2 id="复杂度简单判断">复杂度简单判断</h2><p><strong>O(1)</strong></p><p>运行时间/空间不随输入变化而变化。</p><p><strong>O(n)</strong></p><p>以线性级别增长。eg：单层循环，循环长度与输入数据有关。</p><p><strong>O(n²)</strong></p><p>以平方级别增长。eg：多层循环，循环长度与输入数据有关。</p><p><strong>O(2^n)</strong></p><p>以指数级别增长。eg：类似于&quot;细胞分裂&quot;，一个函数体内运行同样的两个函数（递归）。</p><p><strong>O(logN)</strong></p><p>以对数级别增长。eg：类似于&quot;每次循环缩减到上次的一半&quot;，分治。</p><p><strong>O(nlogN)</strong></p><p>以线性对数级别增长。eg：线性和指数级别的组合，快速排序、归并排序。</p><p><strong>O(n!)</strong></p><p>以阶乘级别增长。eg：全排列。</p>]]></content>
      
      
      <categories>
          
          <category> 算法inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-栈和队列</title>
      <link href="/posts/c017b5df.html"/>
      <url>/posts/c017b5df.html</url>
      
        <content type="html"><![CDATA[<h1>栈和队列</h1><h2 id="栈">栈</h2><p><strong>声明方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;V&gt; stack = <span class="keyword">new</span> <span class="title class_">stack</span>();</span><br></pre></td></tr></table></figure><p><strong>使用方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push()：入队</span><br><span class="line">peek()：返回队首元素</span><br><span class="line">pop()：返回队首元素并删除</span><br><span class="line">size()：返回队列长度</span><br><span class="line">isEmpty()：队列是否为空</span><br></pre></td></tr></table></figure><h2 id="队列">队列</h2><p><strong>声明方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;V&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>使用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offer()：入队</span><br><span class="line">peek()：返回队首元素</span><br><span class="line">poll()：返回队首元素并删除</span><br><span class="line">size()：返回队列长度</span><br><span class="line">isEmpty()：队列是否为空</span><br></pre></td></tr></table></figure><h2 id="优先队列">优先队列</h2><p>通常用优先队列<code>PriorityQueue</code>实现大小顶堆。默认是小顶堆。</p><p><strong>声明方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小顶堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大顶堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br></pre></td></tr></table></figure><p><strong>使用方法</strong></p><p>使用方法队列。</p><blockquote><p>队列、堆只能获取队首或者堆顶的元素，不能获取其他位置的原始。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-2.2进程调度-死锁-存储管理-固定分页分段</title>
      <link href="/posts/e0695fce.html"/>
      <url>/posts/e0695fce.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>进程调度</li><li>死锁</li><li>线程</li><li>存储</li></ul><h1>中论</h1><h2 id="进程调度">进程调度</h2><p>进程调度方式指当有更高优先级的进程到来时如何分配CPU。分为可剥夺和不可剥夺。区别是是否会强制将正在运行其他进程的CPU分配给更高优先级进程。</p><p>在某些操作系统中，一个作业从提交到完成需要经历高、中、低三级调度。</p><ul><li>高级调度：又称长调度、作业调度、接纳调度。决定处于输入池中的哪个后备作业可以调入主系统做好运行的准备。</li><li>中级调度：又称中程调度、对换调度。决定处于交换区中的哪个就绪进程可以调入内存。</li><li>低级调度：又称短程调度、进程调度。决定处于内存中的哪个就绪进程可以占用CPU。<code>是系统最活跃、最重要的调度程序</code></li></ul><p><strong>进程调度算法</strong></p><ul><li>先来先服务FCFS</li><li>时间片轮转</li><li>优先级调度</li><li>多级反馈调度</li></ul><h2 id="死锁"><strong>死锁</strong></h2><p>产生原因：当一个进程在等待永远不可能发生的事件时，就会产生死锁，如果系统中多个进程处于死锁，就会造成系统死锁。</p><p>产生死锁的四个必要条件</p><ul><li>资源互斥</li><li>不可剥夺</li><li>每个进程占有资源并且等待其他资源</li><li>进程资源图是个环路</li></ul><p>打破死锁的方法</p><ul><li>死锁预防。破坏死锁的四个必要条件</li><li>死锁避免。银行家算法</li><li>死锁检测。系统定时运行一个检测死锁的程序</li><li>死锁解除。系统强制剥夺资源，关闭进程等</li></ul><blockquote><p>死锁资源计算：系统内有n个进程，每个进程都要R个资源</p><ul><li>发生死锁的最大资源数 = n*(R-1)</li><li>不发生死锁的最小资源数 = n*(R-1)+1</li></ul></blockquote><h2 id="线程">线程</h2><p>进程特点：拥有资源的独立单位；<s>独立调度和分配的基本单位</s>。</p><p>线程特点：共享资源；独调度和分配的基本单位。线程基本上不拥有私人资源，只拥有一点运行中必不可少的资源（程序计数器、寄存器、栈）。</p><p>引入线程的原因：进程在创建、撤销和切换中，系统会有额外开销，因此在系统中设置的进程数目不宜过多，进程切换的频率不宜太高。引入线程后，可以减少额外开销。</p><h2 id="存储">存储</h2><p><strong>分区存储</strong></p><p>分区存储就是整存，将某进程运行所需的内存整体一起分配给他，然后再执行。</p><p><strong>分区方式</strong></p><ul><li>固定分区：主存分为若干个固定分区，会产生内部碎片</li><li>可变分区：作业转入时划分，整好划分为作业需要的大小，会产生外部分区</li><li>可重定位分区：移动所有已经分配好的分区，使其成为一个连续的区域。只有在外部作业请求空间得不到满足时进行。</li></ul><p><strong>分区存储算法</strong></p><ul><li>首次是适应法：按内存地址，从头查找满足的空闲块</li><li>最佳适应法：将空闲块从小到大排序查找</li><li>最差适应法：将空闲块从大到小排序查找</li><li>循环首次适应法：按内存地址顺序查找，若后续还需分配则继续查找下一个</li></ul><p><strong>分页存储管理</strong></p><p>逻辑页分为页号和页内地址。</p><p>地址页则为页帧号和页内地址。</p><p>需要查表得出逻辑页的页号所对应的页帧号。逻辑页和地址页的页内地址相同，<strong>所以需要两者的页大小保持一致</strong></p><p>优点：利用率高，碎片小，分配及管理简单。</p><p>缺点：增加了系统开销，可能产生抖动现象。</p><blockquote><p>抖动现象：分配给进程的存储块数量小于进程所需要的最小值，导致进程运行频繁地产生<strong>缺页中断</strong>。具体表现为，对刚被替换出去的页面，立即又要被访问，需要将它调入，但因为无空闲内存又要替换另一页，而后者又是即将被访问的页，造成了系统需花费大量的时间忙于进行这种频繁的页面交换。</p></blockquote><p><strong>分页存储算法（页面置换算法）</strong></p><ul><li>最优算法：理论上的算法，无法实现</li><li>先进先出FIFO</li><li>最近最少使用LRU</li><li>淘汰原则：优先淘汰最近未访问的，而后淘汰最近未修改的页面。</li></ul><p>快表：一块小容量的相联存储器，由快速存储器组成，按内容访问、速度快，<strong>并且可以从硬件上保证按内容并行查找，一般用来存放当前访问最频繁的少数多动页面的页号。</strong></p><blockquote><p>块表将页表存于Cache中，慢表则将页表存在内存中。</p><p>慢表访问两次内存才能取出页，块表则是访问一次Cache和一次内存。</p></blockquote><p><strong>分段存储管理</strong></p><p>将进程空间分成一段一段，每段有段号和段长。<strong>和分页存储不同，分段不需要段内地址统一（因为用的段长长度而不是地址）</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分段和分页：</span><br><span class="line"><span class="bullet">- </span>页是物理单位，分页的目的是离散分配，提高内存利用率。分页完全只是为了系统的需要，对用户不可见。</span><br><span class="line"><span class="bullet">- </span>段是逻辑单位，分段是为了更好满足用户需求，分段用户是可见的。</span><br><span class="line"><span class="bullet">- </span>分段比分页容易实现信息共享和保护。因为分页跟逻辑没有关系，可能会将多个逻辑块放在一个页面。而分段会将一个逻辑块为一个段。每个逻辑块都是独立的。</span><br></pre></td></tr></table></figure><p><strong>段页式存储管理</strong></p><p><strong>对进程空间先分段，后分页</strong></p><p>优点：空间浪费小，存储共享容易、能动态链接</p><p>缺点：复杂性和开销也随之增加。</p><blockquote><p>段页式地址转换</p><ol><li>先从逻辑地址中的段号与段寄存器里的段长进行比较，越界发生中断</li><li>然后根据段寄存器中的段表地址找到段表，这时候段表存储内容发生改变，每一个内容应该为页表项的长度，以及页表起始地址</li><li>然后根据页号与该段进行比较，如果越界就发生中断</li><li>进入内存查询页表，查询页框</li><li>最后获得物理地址</li></ol><p>一共访问三次内存：第一次访问段表，第二次访问页表，第三次访问数据</p></blockquote><blockquote><p>为何先分段后分页：因为页是物理，段是逻辑。<strong>先分页后分段和直接分段没有本质区别。</strong></p></blockquote><h1>后记</h1><blockquote><p>世界不过是身外之物</p><p>​   ————— 马尔克斯《百年孤独》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-2.1节操作系统概述-进程管理-同步互斥</title>
      <link href="/posts/b0be319c.html"/>
      <url>/posts/b0be319c.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>操作系统概述</li><li>进程管理</li><li>同步互斥</li></ul><h1>中论</h1><h2 id="操作系统概述">操作系统概述</h2><p>操作系统的四个特征：并发性、共享性、虚拟性和不确定性（异步性）。</p><p>操作系统的功能</p><ul><li>进程管理：本质上对CPU的工作进行管理，包括进程控制、同步、通信、调度。</li><li>文件管理：包括对文件存储空间管理、目录管理、文件的读/写管理和存取控制。</li><li>存储管理：对主存储器空间进行管理，包括存储分配与回收、存储保护、地址映射（变换）和主存扩充。</li><li>设备管理：对输入/输出设备的分配、启动、完成和回收。</li><li>作业管理：包括任务、界面管理、人机交互、语音控制、虚拟现实等。</li></ul><p>操作系统的分类</p><ul><li>批处理操作系统：单道批处理和多道批处理</li><li>分时操作系统：一个计算机系统和多个终端设备连接，轮流为各个终端的用户服务。</li><li>实时操作系统：计算机对于外来信息能够足够快的速度进行处理，并在被控对象允许的时间范围内做出快速反应。对交互能力要求不高，但要求可靠性、速度。</li><li>网络操作系统：共享网络资源、为网络用户提供各种软件服务的系统。主要有集中模式、客户端/服务器模式、对等模式。</li><li>分布式操作系统：多个分散的计算机经连接而成的计算机系统。</li><li>微型计算机操作系统：Windows、Mac OS、Linux</li></ul><p>嵌入式操作系统的特点：</p><ul><li>微型化</li><li>可定制</li><li>实时性</li><li>可靠性</li><li>易移植性</li></ul><blockquote><p>嵌入式系统初始化过程：片级初始化–&gt;板级初始化–&gt;系统初始化。</p><p>操作系统初始化过程：硬件初始化–&gt;BIOS初始化–&gt;OS初始化</p></blockquote><h2 id="进程">进程</h2><p>进程的组成：进程控制块PCB（唯一标志）、程序（描述进程工作内容）、数据（进程执行时所需的数据）</p><p><strong>进程三态图</strong></p><p><img src="../image/post/image-20240410215224492.png" alt="image-20240410215224492"></p><p><strong>前驱图</strong></p><p>前驱图：用来表示那些任务可以并行执行，那些任务之间有顺序关系。</p><p><img src="../image/post/image-20240410215320001.png" alt="image-20240410215320001"></p><p>比如上图：ABC可以并行执行，但需要ABC都执行完以后D才能执行。</p><p><strong>进程资源图</strong></p><p>进程资源图：用来表示进程和资源之间的分配和请求关系。</p><p><img src="../image/post/image-20240410215430313.png" alt="image-20240410215430313"></p><ul><li>P表示进程，R表示资源。R方框内有几个圆球表示有几个这种资源，出去的箭头表示分配给哪个进程某个资源；进来的箭头表示某个进程需要某个资源。</li><li>阻塞节点：某进程所请求的资源已经全部分配完，无法获取所需资源，该进程被阻塞。比如P2</li><li>非阻塞节点：P1、P3</li><li>当一个进程资源图中<strong>所有进程都是阻塞节点时，即陷入死锁状态</strong></li></ul><blockquote><p>进程资源图可化简，化简顺序：指的是进程完成顺序。</p></blockquote><h2 id="进程同步与互斥"><strong>进程同步与互斥</strong></h2><p>临界资源：各进程间需要以<strong>互斥方式对其进行访问</strong>的资源</p><p>临界区：进程中对<strong>临界资源实施操作的那段程序</strong>。一段程序代码。</p><p>信号量：通常用S表示</p><ul><li><p>互斥信号量：对临界资源采用互斥访问，使用互斥信号量后其他进程无法访问，初值为1。</p></li><li><p>同步信号量：对共享资源的访问控制，初值一般是共享资源的数量。</p></li></ul><p>P操作：申请资源，S=S-1。若S&gt;=0，执行P操作的进程继续执行；若S&lt;0，则该进程为阻塞状态，并将其插入阻塞队列。</p><p>V操作：释放资源，S=S+1。若S&gt;0，则执行V操作的进程继续执行；若S&lt;=0，则从阻塞状态唤醒一个进程，并将其插入就绪队列，然后执行V操作的进程继续。</p><h1>后记</h1><blockquote><p>旁观拍手笑疏狂，疏又何妨，狂又何妨？</p><p>​  ————— 刘克庄《一剪梅》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-1.3节磁盘-输入输出技术-总线</title>
      <link href="/posts/b174557d.html"/>
      <url>/posts/b174557d.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>磁盘</li><li>输入输出（数据交互方式）</li><li>总线</li></ul><h1>中论</h1><h2 id="磁盘">磁盘</h2><p><strong>磁道（柱面）</strong>：磁盘有正反两个盘面，每个盘面有多个同心圆，<strong>每个同心圆是一个磁道</strong>。</p><p>扇区：每个同心圆被划分为多个扇区，数据就被存放在一个个扇区中。</p><p>磁头首先要寻找对应的磁道，然后等待磁盘进行周期旋转，旋转到指定的扇区，才能读取相应的数据。（即寻道+旋转）</p><blockquote><p>注意：是读取相应数据，不是处理。【考试真题P14】</p></blockquote><p><strong>磁盘调度算法</strong>：主要针对寻道</p><ul><li>先来先服务FCFS：根据进程请求访问磁盘的先后顺序进行调度</li><li>最短寻道时间优先SSTF：请求访问的磁道与当前磁道最近的进程优先调度。会产生&quot;饥饿现象&quot;，某个远处进程永远不会被访问。</li><li>扫描算法SCAN：“电梯算法”。<em>磁头在磁盘上双向移动，会选择离磁头最近的磁道，并且与磁头移动方向一致，一直移动到低才掉头。</em></li><li>单向扫描调度算法CSCAN：只做单向移动。</li></ul><h2 id="输入输入技术">输入输入技术</h2><p>内存与接口地址的编址方法：</p><ul><li>内存与接口地址独立编址方法。缺点是接口指令少，功能弱。</li><li>内存与接口地址统一编址方法。缺点是整个地址空间被分成两部分。</li></ul><p><strong>计算机和外设间的数据交互方式</strong></p><ul><li>无条件传送方式：默认设备处于准备好的状态，不需要查询外设的空闲状态，但是<strong>仍需要CPU执行程序指令传送数据</strong></li><li>程序控制（查询方式）：CPU主动查询外设是否完成数据传输，效率极低。</li><li>程序中断方式：外设完成数据传输后向CPU发送中断，等待CPU处理数据。<ul><li>中断响应时间：从发送中断请求到开始进入中断处理程序</li><li>中断处理时间：从中断处理开始到中断处理结束。</li><li>中断向量：提供中断服务程序的入口地址。</li></ul></li><li>DMA方式（直接主存存取）：CPU只需完成必要的初始化操作，数据传输的整个过程都由DMA控制器完成，在主存和外设之间建立直接的数据链路。</li></ul><blockquote><p>在一个总线周期结束以后，CPU会响应DMA请求开始读取数据。</p><p>在一条指令执行结束时，CPU响应程序中断方式请求。</p></blockquote><h2 id="总线">总线</h2><p>总线（Bus）：计算机设备和设备之间传输信息的公共数据通道。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">广义上的总线：任何连接两个以上电子元器件的导线都可以成为总线。</span><br><span class="line"><span class="bullet">- </span>内部总线：内部芯片级别的总线，芯片与处理器之间通信的总线。</span><br><span class="line"><span class="bullet">- </span>系统总线：板级总线，用于计算机内各部分之间的连接。PCI、EISA、ISA等。</span><br><span class="line"><span class="bullet">- </span>外部总线：设备一级的总线，微机和外部设备的总线。RE232、SCSI、USB等</span><br></pre></td></tr></table></figure><p><strong>系统总线</strong></p><ul><li>数据总线：并行数据传输位数</li><li>地址总线：系统可管理的内存空间的大小</li><li>控制总线：传送控制命令</li></ul><h1>后记</h1><blockquote><p>世界太吵，别听，别看，别管，超前走。</p><p>​ —————佚名</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-1.2节指令系统-存储系统</title>
      <link href="/posts/7d3b98d9.html"/>
      <url>/posts/7d3b98d9.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>内容：</p><ul><li>指令系统</li><li>存储系统</li></ul><h1>中论</h1><h2 id="指令系统">指令系统</h2><p>计算机的指令由操作数和操作码组成</p><ul><li>操作数：参加运算的数据以及所在的单元地址</li><li>操作码：决定要完成的操作</li></ul><p>计算机指令执行过程：</p><p>​取指令–&gt;分析指令–&gt;执行指令</p><p><strong>指令寻址的方式</strong>[指令寻址：下一条<strong>欲执行</strong>指令的地址（始终由程序计数器PC给出）]</p><p>顺序寻址：PC = ( PC ) + 1，1指的是一个指令的字长</p><p>跳跃寻址：由转移指令指出 PC 的值</p><p><strong>数据寻址（指令操作数）的方式</strong>[数据寻址：确定本条指令的地址码指明的真实地址]</p><p>==立即寻址==：指令的地址码字段不是地址，而是操作数本身。</p><p>==直接寻址==：在指令的地址字段中直接指出操作数在主存的地址。【操作数的地址】</p><p>==间接寻址==：指令地址码字段指向的存储单元中存储的是操作数的地址。【操作数的地址的地址】</p><p>==寄存器寻址==：地址码是寄存器的编号</p><p>基址寻址：基址寄存器的内容机上指令中形式地址而形成操作数的有效地址</p><p>变址寻址：变址寄存器的内容机上指令中形式地址而形成操作数的有效地址。</p><p><strong>CISC和RISC</strong></p><p>CISC：复杂指令系统。由微程序实现。</p><p>RISC：简单指令系统。由硬件实现（通用寄存器、硬布线逻辑控制）。==适合采用流水线==</p><p><strong>流水线</strong></p><p>流水线原理：将指令分成不同段，每段由不同的部分去处理。</p><p><strong>RISC的流水线技术</strong></p><ol><li>超流水线技术。增加级数、提高主频，以时间换取空间。</li><li>超标量技术。多条流水线，以空间换取时间。</li><li>超长指令字。软硬结合。</li></ol><p><strong>流水线时间计算</strong></p><p>流水线周期：执行最长的时间段为流水线周期。</p><p>流水线执行时间：一条指令总时间+(总指令数-1)*流水线周期。</p><p>流水线吞吐率计算：指令条数/流水线执行时间。</p><p>流水线加速比计算：不使用流水线执行时间/使用流水线执行时间。</p><h2 id="存储系统">存储系统</h2><p>两级存储：Cache-主存、主存-辅存（虚拟存储体系）</p><p>局部性原理：总的来说，CPU在运行时所访问的数据会趋向于一个较小的局部空间地址内</p><ul><li>时间局部性：相邻的时间会访问一个数据项</li><li>空间局部性：相邻的地址空间被连续访问</li></ul><p><strong>高速缓存Cache</strong></p><ul><li>由控制部分和存储器组成。前者判断是否命中Cache，后者存储数据。</li><li>直接与CPU交互，位于CPU和主存之间。</li><li>地址映射：CPU传输的是主存单元的地址，不是Cache的地址，所以需要将主存地址转成Cache地址进行判断。==这种转换由硬件自动完成映射==<ul><li>直接映像：将Cache分成等块，主存也分成等块。数据只能放在相同块号的Cache中。地址变换简单，但容易造成资源浪费。</li><li>全相联映射：主存中任意一块都能与Cache中的任意一块对应。地址变化复杂，最不容易发生块冲突。</li><li>组组相连映像：前两种的结合。先分块（直接映像）后分组（权向量映像），即主存和Cache中的组号相同才能命中，同一组号内的所有块可以任意调换。</li></ul></li><li>替换算法：是Cache尽可能高的命中<ul><li>随机替换算法</li><li>先进先出算法（FIFO）</li><li>近期最少使用算法（LRU）</li><li>优化替换算法</li></ul></li><li>CPU读取一次数据的平均时间 = Cache命中率×读取Cache时间+未命中率×读取主存时间</li></ul><h1>后记</h1><p>补充：</p><p>Flyynn分类法根据计算机在执行程序的过程中的==指令流和数据流==的不同组合，将计算机分为4类。多核计算机属于MIMD（多指令、多数据）。</p><blockquote><p>连伟人的一生都充满了那么大的艰辛，一个平凡的人吃点苦又算得了什么呢？  ——————《平凡的世界》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考-1.1计算机硬件-CPU-校验码</title>
      <link href="/posts/55152f69.html"/>
      <url>/posts/55152f69.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>重点内容：</p><ul><li>计算机硬件组成</li><li>校验码</li></ul><h1>中论</h1><h2 id="计算机硬件组成">计算机硬件组成</h2><p>计算机的基本硬件系统由运算器、控制器、存储器、输入设备和输出设备5大部件组成。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">中央处理单元（<span class="meta">CPU</span>）：由运算器和控制器等部件集成，用于数据的加工处理、完成算数、逻辑运算以及控制功能。</span><br><span class="line"></span><br><span class="line">存储器：分为内部存储器和外部存储器。</span><br><span class="line"></span><br><span class="line">输入设备和输出设备（外设）：输入、输出数据。</span><br></pre></td></tr></table></figure><h2 id="中央处理单元">中央处理单元</h2><p>CPU功能：</p><ul><li>程序控制</li><li>操作控制</li><li>时间控制</li><li>数据处理</li><li>中断（异常）处理</li></ul><p>CPU组成：运算器、控制器、寄存器组、内部总线等</p><p>==运算器==：执行所有算数运算、逻辑运算并进行逻辑测试</p><ul><li>算数逻辑单元ALU：对数据进行算数和逻辑运算</li><li>累加寄存器AC：源操作数或运算结果的存放区</li><li>数据缓冲寄存器DR：暂时存放内存的指令或数据</li><li>状态条件寄存器PSW：保存指令运行结果的条件码内容</li></ul><p>==控制器==：控制整个CPU的工作</p><ul><li>指令寄存器IR：暂存CPU执行指令</li><li>程序计数器PC：存放指令执行地址</li><li>地址寄存器AR：保存当前CPU所访问的内存地址</li><li>指令译码器ID：分析指令操作码</li></ul><blockquote><p>CPU依据指令周期的不同阶段来区分二进制的指令和数据。（在不同阶段取指令或数据）</p></blockquote><p><strong>掌握：哪些属于运算器，哪些属于控制器。各自名字以及简写和相关功能</strong></p><h2 id="校验码">校验码</h2><p>码距：在两个编码中，从A码到B码转换所需要改变的位数称为码距。码距越大，越利于纠错和检错。</p><p><strong>奇偶校验码</strong></p><p>在编码中增加1为校验位来使编码中1的个数为奇数（奇校验）或者偶数（偶校验）。<strong>奇偶校验码码距为2，因为从A码变为B码要改变校验位和一个非校验位。</strong></p><p>奇偶校验只能检1位错，并且无法纠错。</p><p><strong>循环冗余校验码CRC</strong></p><p>CRC只能检错，不能纠错。</p><p>步骤：</p><ol><li>题干给出原始信息串S和CRC生成的多项式G(x)。</li><li>多项式G(x)的最高阶数m，则在S后添加m个0为被除数。</li><li>根据多项式x的次数，得到除数。</li><li>被除数和除数进行模2除法运算取余（不进位也不借位）生成CRC校验码（余数）。如果余数位数不足m位，则在余数前补0。</li><li>将余数添加在原始信息串S后，发送给接收方。</li><li>接收方用相同的方法求余数，余数为0即相同信息。</li></ol><p><code>注意</code>：发送/接受方需要用相同的多项式G(x)</p><h1>后记</h1><blockquote><p>穷则独善其身，达则兼善天下  ——————《孟子》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软考inG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考 </tag>
            
            <tag> 文老师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TED演讲-拖延症人群的内心世界</title>
      <link href="/posts/7b5c74af.html"/>
      <url>/posts/7b5c74af.html</url>
      
        <content type="html"><![CDATA[<h1>Preface</h1><p>致社恐、不善交流的你，在演讲中给出了10个建议教你怎样和别人更好的交谈。</p><h1>Content</h1><blockquote><p><strong>Number one: Don’t multitask</strong></p></blockquote><p><strong>第一条：不要三心二意</strong>。如果你想退出交谈，就退出交谈。但不要身在曹营心在汉。</p><blockquote><p><strong>Number two: Don’t pontificate</strong></p></blockquote><p><strong>第二条：不要好为人师</strong>。真正的倾听需要把自己放在一边。</p><blockquote><p><strong>Number three: Use open-ended questions</strong></p></blockquote><p><strong>第三点：使用开放式问题</strong>。</p><blockquote><p><strong>Number four: Go with the flow.</strong></p></blockquote><p><strong>第四点：顺其自然</strong>。</p><blockquote><p><strong>Number five: If you don’t know, say that you don’t know</strong></p></blockquote><p><strong>第五点：如果你不知道，就说你不知道。</strong></p><blockquote><p><strong>Number six: Don’t equate your experience with theirs.</strong></p></blockquote><p><strong>第六条：不要把自己的经历和他人比较。</strong></p><blockquote><p><strong>Number seven: Try not to repeat yourself</strong></p></blockquote><p><strong>第七条：尽量别重复自己的话</strong>。</p><blockquote><p><strong>Number eight: Stay out of the weeds</strong></p></blockquote><p><strong>第八条：少说废话</strong>。</p><blockquote><p><strong>Number nine: This is not the last one, but it is the most important one. Listen.</strong></p></blockquote><p><strong>第九条：这不是最后一条，但是最重要的一条。认真倾听。</strong></p><blockquote><p><strong>One more rule, number 10, and it’s this one: Be brief.</strong></p></blockquote><p><strong>最后一条，第十条：简明扼要。</strong></p><hr><h1>Original</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">All</span> right, I want <span class="keyword">to</span> see a <span class="keyword">show</span> <span class="keyword">of</span> hands: how many <span class="keyword">of</span> you have unfriended someone <span class="keyword">on</span> Facebook because they said something offensive about politics <span class="keyword">or</span> religion, childcare, food? <span class="keyword">And</span> how many <span class="keyword">of</span> you know at least one person that you avoid because you just don<span class="string">&#x27;t want to talk to them? </span></span><br><span class="line"><span class="string">好的，我想让大家举手示意一下，有多少人曾经在Facebook上拉黑过好友，因为他们发表过关于政治、宗教、儿童权益，或者食物等不恰当的言论？有多少人至少有一个不想见的人，因为你就是不想和对方说话？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You know, it used to be that in order to have a polite conversation, we just had to follow the advice of Henry Higgins in &quot;My Fair Lady&quot;: Stick to the weather and your health. But these days, with climate change and anti-vaxxing, those subjects —are not safe either. </span></span><br><span class="line"><span class="string">要知道，在过去想要一段礼貌的交谈，我们只要遵循亨利·希金斯在《窈窕淑女》中的忠告：只谈论天气和你的健康状况就行了。但这些年随着气候变化以及反对疫苗运动的开展 ——这招也不怎么管用了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">So this world that we live in, this world in which every conversation has the potential to devolve into an argument, where our politicians can&#x27;</span>t speak <span class="keyword">to</span> one another <span class="keyword">and</span> <span class="keyword">where</span> even the most trivial <span class="keyword">of</span> issues have someone fighting <span class="keyword">both</span> passionately <span class="keyword">for</span> it <span class="keyword">and</span> against it, it<span class="string">&#x27;s not normal.</span></span><br><span class="line"><span class="string">因此，在我们生活的这个世界，这个每一次交谈都有可能发展为争论的世界，政客无法彼此交谈，甚至为那些鸡毛蒜皮的事情都有人群情激昂地赞成或反对，这太不正常了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Pew Research did a study of 10,000 American adults, and they found that at this moment, we are more polarized, we are more divided, than we ever have been in history. We&#x27;</span>re less likely <span class="keyword">to</span> compromise, which means w<span class="string">e&#x27;re not listening to each other.</span></span><br><span class="line"><span class="string">皮尤研究中心对一万名美国成年人做了一次调查，发现此刻我们的偏激程度，我们立场鲜明的程度，比历史上任何时期都要高。我们更不倾向于妥协，这意味着我们没有倾听彼此。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">And we make decisions about where to live, who to marry and even who our friends are going to be, based on what we already believe. Again, that means we&#x27;</span>re <span class="keyword">not</span> listening <span class="keyword">to</span> <span class="keyword">each</span> other. A conversation requires a balance <span class="keyword">between</span> talking <span class="keyword">and</span> listening, <span class="keyword">and</span> somewhere along the way, we lost that balance. </span><br><span class="line">我们做的各种决定、选择生活在何处、与谁结婚甚至和谁交朋友，都只基于我们已有的信念。再重复一遍，这说明我们没有倾听彼此。交谈需要平衡讲述和倾听，而不知怎么的，我们却渐渐失掉了这种平衡。</span><br><span class="line"></span><br><span class="line">Now, part <span class="keyword">of</span> that <span class="keyword">is</span> due <span class="keyword">to</span> technology. The smartphones that you <span class="keyword">all</span> either have <span class="keyword">in</span> your hands <span class="keyword">or</span> <span class="keyword">close</span> enough that you could grab them really quickly. According <span class="keyword">to</span> Pew Research, about a third <span class="keyword">of</span> American teenagers send more than a hundred texts a day. </span><br><span class="line">技术进步是部分原因。比如智能手机，现在就在你们手里，或者就在旁边，随手就能拿到。据皮尤的研究称，大约三分之一的美国青少年每天发送超过一百条短信。</span><br><span class="line"></span><br><span class="line"><span class="keyword">And</span> many <span class="keyword">of</span> them, almost most <span class="keyword">of</span> them, are more likely <span class="keyword">to</span> <span class="type">text</span> their friends than they are <span class="keyword">to</span> talk <span class="keyword">to</span> them face <span class="keyword">to</span> face. Ther<span class="string">e&#x27;s this great piece in The Atlantic. It was written by a high school teacher named Paul Barnwell. And he gave his kids a communication project. </span></span><br><span class="line"><span class="string">而这中间很多人，几乎是所有人，更倾向于给朋友发短信，而不是面对面的交谈。《大西洋》杂志登过一篇很棒的文章，作者是高中教师保罗·巴恩韦尔。他给自己的学生一项交流任务，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">He wanted to teach them how to speak on a specific subject without using notes. And he said this: &quot;I came to realize...&quot; &quot;I came to realize that conversational competence might be the single most overlooked skill we fail to teach. Kids spend hours each day engaging with ideas and each other through screens, </span></span><br><span class="line"><span class="string">希望教会他们如何不借助笔记针对某一话题发表演讲。然后他说：“我开始意识到……”“我开始意识到交流能力可能是最被我们忽视的，没有好好教授的技能。孩子每天花费数小时通过屏幕接触创意和其他伙伴，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">but rarely do they have an opportunity to hone their interpersonal communications skills.  It might sound like a funny question, but we have to ask ourselves: Is there any 21st-century skill more important than being able to sustain coherent, confident conversation?&quot;</span></span><br><span class="line"><span class="string">但很少有机会去发掘自己的人际交往技能。”这听起来很好笑，但我们必须问问自己：21世纪，有什么技能会比维持一段连贯、自信的谈话更为重要？”</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Now, I make my living talking to people: Nobel Prizewinners, truck drivers, billionaires, kindergarten teachers, heads of state, plumbers. I talk to people that I like. I talk to people that I don&#x27;</span>t <span class="keyword">like</span>. I talk <span class="keyword">to</span> <span class="keyword">some</span> people that I disagree <span class="keyword">with</span> deeply <span class="keyword">on</span> a personal <span class="keyword">level</span>. But Istill have a great conversation <span class="keyword">with</span> them.</span><br><span class="line">现在，我的职业就是跟别人谈话。诺贝尔奖获得者、卡车司机、亿万富翁、幼儿园老师、州长、水管工。我和我喜欢的人交谈，也和我不喜欢的人交谈。我和在个人层面非常不认同的人交谈。但我仍旧和他们有很好的交流。</span><br><span class="line"></span><br><span class="line">So I<span class="string">&#x27;d like to spend the next 10 minutes or so teaching you how to talk and how to listen. Many of you have already heard a lot of advice on this, things like look the person in the eye, think of interesting topics to discuss in advance, look, nod and smile to show that you&#x27;</span>re paying attention, repeat back what you just heard <span class="keyword">or</span> summarize it.</span><br><span class="line">所以我希望用接下来的<span class="number">10</span>分钟教你们如何谈话，以及如何倾听。你们中间很多人已经听过无数建议，比如看着对方的眼睛，提前想好可以讨论的有趣话题、注视、点头并且微笑来表明你的专注，重复你刚才听到的，或者做总结。</span><br><span class="line"></span><br><span class="line">So I want you <span class="keyword">to</span> forget <span class="keyword">all</span> <span class="keyword">of</span> that. It <span class="keyword">is</span> crap. There <span class="keyword">is</span> <span class="keyword">no</span> reason <span class="keyword">to</span> learn how <span class="keyword">to</span> <span class="keyword">show</span> you<span class="string">&#x27;re paying attention if you are in fact paying attention. Now, I actually use the exact same skills as a professional interviewer that I do in regular life. </span></span><br><span class="line"><span class="string">我想让你们忘掉所有这些，全都没用。根本没必要去学习如何表现你很专心，如果你确实很专心。我其实是把作为职业访谈者一模一样的技巧用在了日常生活中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">So, I&#x27;</span>m going <span class="keyword">to</span> teach you how <span class="keyword">to</span> interview people, <span class="keyword">and</span> that<span class="string">&#x27;s actually going to help you learn how to be better conversationalists. Learn to have a conversation without wasting your time, without getting bored, and, please God, without offe We&#x27;</span>ve <span class="keyword">all</span> had really great conversations.</span><br><span class="line">好，我要来教你们如何采访他人，这其实会帮助你们学习如何成为更好的沟通者。学习开始一段交谈，不浪费时间、不感到无聊，以及，最重要的是，不冒犯任何人。我们都曾有过很棒的交谈。</span><br><span class="line"></span><br><span class="line">W<span class="string">e&#x27;ve had them before. We know what it&#x27;</span>s <span class="keyword">like</span>. The kind <span class="keyword">of</span> conversation <span class="keyword">where</span> you walk away feeling engaged <span class="keyword">and</span> inspired, <span class="keyword">or</span> <span class="keyword">where</span> you feel <span class="keyword">like</span> you<span class="string">&#x27;ve made a real connection or you&#x27;</span>ve been perfectly understood. There <span class="keyword">is</span> <span class="keyword">no</span> reason why most <span class="keyword">of</span> your interactions can<span class="string">&#x27;t be like that.</span></span><br><span class="line"><span class="string">我们都曾有过。我们知道那是什么感觉。那种结束之后令你感到很享受、很受鼓舞的交谈，或者令你觉得你和别人建立了真实的连接，或者让你完全得到了他人的理解。没有理由说你大部分人际互动不能成为那样。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">So I have 10 basic rules. I&#x27;</span>m going <span class="keyword">to</span> walk you through <span class="keyword">all</span> <span class="keyword">of</span> them, but honestly, <span class="keyword">if</span> you just choose one <span class="keyword">of</span> them <span class="keyword">and</span> master it, you<span class="string">&#x27;ll already enjoy better conversations. Number one: Don&#x27;</span>t multitask. <span class="keyword">And</span> I don<span class="string">&#x27;t mean just set down your cell phone or your tablet or your car keys or whatever is in your hand. </span></span><br><span class="line"><span class="string">我有10条基本规则。我会一条条给你们解释，但说真的，如果你选择一条并且熟练掌握，你就已经可以享受更愉快的交谈了。第一条：不要三心二意。我不是说单纯放下你的手机、平板电脑、车钥匙，或者随便什么握在手里的东西。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I mean, be present. Be in that moment. Don&#x27;</span>t think about your argument you had <span class="keyword">with</span> your boss. Don<span class="string">&#x27;t think about what you&#x27;</span>re going <span class="keyword">to</span> have <span class="keyword">for</span> dinner. <span class="keyword">If</span> you want <span class="keyword">to</span> <span class="keyword">get</span> <span class="keyword">out</span> <span class="keyword">of</span> the conversation, <span class="keyword">get</span> <span class="keyword">out</span> <span class="keyword">of</span> the conversation, but don<span class="string">&#x27;t be half in it and half out of it.</span></span><br><span class="line"><span class="string">我的意思是，处在当下，进入那个情境中去。不要想着你之前和老板的争吵、不要想着你晚饭吃什么，如果你想退出交谈，就退出交谈。但不要身在曹营心在汉。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Number two: Don&#x27;</span>t pontificate. <span class="keyword">If</span> you want <span class="keyword">to</span> state your opinion <span class="keyword">without</span> <span class="keyword">any</span> opportunity <span class="keyword">for</span> response <span class="keyword">or</span> argument <span class="keyword">or</span> pushback <span class="keyword">or</span> growth, <span class="keyword">write</span> a blog. Now, ther<span class="string">e&#x27;s a really good reason why I don&#x27;</span>t allow pundits <span class="keyword">on</span> my <span class="keyword">show</span>: Because they<span class="string">&#x27;re really boring. If they&#x27;</span>re conservative, they<span class="string">&#x27;re going to hate Obama and food stamps and abortion. </span></span><br><span class="line"><span class="string">第二条：不要好为人师。如果你想要表达自己的看法，又不想留下任何机会让人回应、争论、反驳或阐发，写博客去。有个很好的理由来说明我的谈话里为什么不允许有“专家说教”：因为真的很无聊。如果对方是个保守派，那一定讨厌奥巴马、食品券和堕胎。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If they&#x27;</span>re liberal, they<span class="string">&#x27;re going to hate big banks and oil corporations and Dick Cheney. Totally predictable. And you don&#x27;</span>t want <span class="keyword">to</span> be <span class="keyword">like</span> that. You need <span class="keyword">to</span> enter every conversation assuming that you have something <span class="keyword">to</span> learn. The famed therapist M. Scott Peck said that <span class="keyword">true</span> listening requires a setting aside <span class="keyword">of</span> oneself. </span><br><span class="line">如果对方是个自由派，那一定会讨厌大银行、石油公司和迪克·切尼。完全可以预测的。你肯定不希望那样。你需要在进入每一次交流时都假定自己可以学习到一些东西。著名的治疗师M.斯科特·派克说过，真正的倾听需要把自己放在一边。</span><br><span class="line"></span><br><span class="line"><span class="keyword">And</span> sometimes that means setting aside your personal opinion. He said that sensing this acceptance, the speaker will become less <span class="keyword">and</span> less vulnerable <span class="keyword">and</span> more <span class="keyword">and</span> more likely <span class="keyword">to</span> <span class="keyword">open</span> up the <span class="keyword">inner</span> recesses <span class="keyword">of</span> his <span class="keyword">or</span> her mind <span class="keyword">to</span> the listener. Again, assume that you have something <span class="keyword">to</span> learn.</span><br><span class="line">有时候，这意味着把你的个人观点放在一边。他说感受到这种接纳，说话的人会变得越来越不脆弱敏感，因而越来越有可能打开自己的内心世界，呈现给倾听者。再强调一遍，假定你需要学习新东西。</span><br><span class="line"></span><br><span class="line">Bill Nye: &quot;Everyone you will ever meet knows something that you don&#x27;t.&quot; I put it this way: Everybody <span class="keyword">is</span> an expert <span class="keyword">in</span> something. Number three: Use <span class="keyword">open</span>-ended questions. <span class="keyword">In</span> this <span class="keyword">case</span>, take a cue <span class="keyword">from</span> journalists. <span class="keyword">Start</span> your questions <span class="keyword">with</span> who, what, <span class="keyword">when</span>, <span class="keyword">where</span>, why <span class="keyword">or</span> how. </span><br><span class="line">比尔·奈伊说：“每一个你将要见到的人都有你不知道的东西。”我来复述一下：每个人都是某方面的专家。第三点：使用开放式问题。关于这一点，请参考记者采访的提问方式。以“谁”、“什么”、“何时”、“何地”、 “为什么”或“如何”开始提问。</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you put <span class="keyword">in</span> a complicated question, you<span class="string">&#x27;re going to get a simple answer out. If I ask you, &quot;Were you terrified?&quot; you&#x27;</span>re going <span class="keyword">to</span> respond <span class="keyword">to</span> the most powerful word <span class="keyword">in</span> that sentence, which <span class="keyword">is</span> &quot;terrified,&quot; <span class="keyword">and</span> the answer <span class="keyword">is</span> &quot;Yes, I was&quot; <span class="keyword">or</span> &quot;No, I wasn&#x27;t.&quot;</span><br><span class="line">如果你询问一个复杂的问题将会得到一个简单的回答。如果我问你：“你当时恐惧吗？” 你会回应那句话中最有力的词，即“恐惧”，而答案将是 “是的”或者“不是”。</span><br><span class="line"></span><br><span class="line">&quot;Were you angry?&quot; &quot;Yes, I was very angry.&quot; Let them describe it. They<span class="string">&#x27;re the ones that know. Try asking them things like, &quot;What was that like?&quot; &quot;How did that feel?&quot; Because then they might have to stop for a moment and think about it, and you&#x27;</span>re going <span class="keyword">to</span> <span class="keyword">get</span> a much more interesting response.</span><br><span class="line">“你当时气愤吗？”“是的，我当时气得很。”让对方去描述，对方才是了解情境的人。试着这样问对方：“那是什么样子？”“你感觉怎么样？”因为这样一来，对方可能需要停下来想一想，而你会得到更有意思的回答。</span><br><span class="line"></span><br><span class="line">Number four: Go <span class="keyword">with</span> the flow. That means thoughts will come <span class="keyword">into</span> your mind <span class="keyword">and</span> you need <span class="keyword">to</span> let them go <span class="keyword">out</span> <span class="keyword">of</span> your mind. W<span class="string">e&#x27;ve heard interviews often in which a guest is talking for several minutes and then the host comes back in and asks a question which seems like it comes out of nowhere, or it&#x27;</span>s already been answered.</span><br><span class="line">第四点：顺其自然。也就是说，想法会自然流入你的头脑，而你需要将它们表达出来。我们常听到采访中嘉宾说了几分钟，然后主持人回过来问问题，这问题好像不知道从何而来，或者已经被回答过了。</span><br><span class="line"></span><br><span class="line">That means the host probably stopped listening two minutes ago because he thought <span class="keyword">of</span> this really clever question, <span class="keyword">and</span> he was just bound <span class="keyword">and</span> determined <span class="keyword">to</span> say that. <span class="keyword">And</span> we <span class="keyword">do</span> the exact same thing. W<span class="string">e&#x27;re sitting there having a conversation with someone, and then we remember that time that we met Hugh Jackman in a coffee shop.</span></span><br><span class="line"><span class="string">这说明主持人可能两分钟前就没在听，因为他想到了这个非常机智的问题，于是就心心念念想着问这个问题。我们同样也会这么干。当我们和某人坐在一起交谈时，我们突然想起那次和休·杰克曼在咖啡店的偶遇。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">And we stop listening. Stories and ideas are going to come to you. You need to let them come and let them go. Number five: If you don&#x27;</span>t know, say that you don<span class="string">&#x27;t know. Now, people on the radio, especially on NPR, are much more aware that they&#x27;</span>re going <span class="keyword">on</span> the <span class="type">record</span>, </span><br><span class="line">然后我们就不再听了。故事和想法总会不断向你涌来，但即便无法阻止，也不要让它们过多地在头脑中逗留。第五点：如果你不知道，就说你不知道。广播节目里的人，尤其在全国公共广播电台（NPR）中，非常明白他们的谈话会被播放出去。</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> so they<span class="string">&#x27;re more careful about what they claim to be an expert in and what they claim to know for sure. Do that. Err on the side of caution. Talk should not be cheap. Number six: Don&#x27;</span>t equate your experience <span class="keyword">with</span> theirs. <span class="keyword">If</span> they<span class="string">&#x27;re talking about having lost a family member, don&#x27;</span>t <span class="keyword">start</span> talking about the <span class="type">time</span> you lost a <span class="keyword">family</span> member. </span><br><span class="line">所以他们对自己声称专业的地方以及言之凿凿的东西会更加小心。要学着这样做。谨言慎行。谈话应该是负责任的行为。第六条：不要把自己的经历和他人比较。如果对方谈论失去了家人，不要就势开始说你失去家人的事情。</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> they<span class="string">&#x27;re talking about the trouble they&#x27;</span>re <span class="keyword">having</span> at <span class="keyword">work</span>, don<span class="string">&#x27;t tell them about how much you hate your job. It&#x27;</span>s <span class="keyword">not</span> the same. It <span class="keyword">is</span> never the same. <span class="keyword">All</span> experiences are individual. <span class="keyword">And</span>, more importantly, it <span class="keyword">is</span> <span class="keyword">not</span> about you. You don<span class="string">&#x27;t need to take that moment to prove how amazing you are or how much you&#x27;</span>ve suffered.</span><br><span class="line">如果对方在说工作上的困扰，不要告诉他们你多么讨厌你的工作。这不一样的，永远不可能一样。任何经历都是独一无二的。而且，更重要的是，这不是在谈论你的事。你不需要在此刻证明你多么能干，或者你经受了多少痛苦。</span><br><span class="line"></span><br><span class="line">Somebody asked Stephen Hawking once what his IQ was, <span class="keyword">and</span> he said, &quot;I have no idea. People who brag about their IQs are losers. &quot;Conversations are <span class="keyword">not</span> a promotional opportunity.</span><br><span class="line">有人曾问史蒂芬·霍金他的智商是多少，他回答道：“我不知道。拿智商吹牛的人都是屌丝。”交谈不是用来推销自己的。</span><br><span class="line"></span><br><span class="line">Number seven: Try <span class="keyword">not</span> <span class="keyword">to</span> repeat yourself. It<span class="string">&#x27;s condescending, and it&#x27;</span>s really boring, <span class="keyword">and</span> we tend <span class="keyword">to</span> <span class="keyword">do</span> it a lot. Especially <span class="keyword">in</span> <span class="keyword">work</span> conversations <span class="keyword">or</span> <span class="keyword">in</span> conversations <span class="keyword">with</span> our kids, we have a <span class="type">point</span> <span class="keyword">to</span> make, so we just keep rephrasing it <span class="keyword">over</span> <span class="keyword">and</span> <span class="keyword">over</span>. Don<span class="string">&#x27;t do that.</span></span><br><span class="line"><span class="string">第七条：尽量别重复自己的话。这很咄咄逼人，也很无聊。但我们很容易这样做。尤其是在工作交谈中，或者和孩子的交谈中。我们想声明一个观点，于是换着方式不停地说。别这样。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Number eight: Stay out of the weeds. Frankly, people don&#x27;</span>t care about the years, the names, the dates, <span class="keyword">all</span> those details that you<span class="string">&#x27;re struggling to come up with in your mind. They don&#x27;</span>t care. What they care about <span class="keyword">is</span> you. They care about what you<span class="string">&#x27;re like, what you have in common. So forget the details. Leave them out.</span></span><br><span class="line"><span class="string">第八条：少说废话。说白了，没人在乎那些年份，名字，日期等等这些你努力试图在脑中回想的种种细节，别人不在乎，他们关注的是你，对方关心你是什么样的人，和你有什么共同点。所以忘掉细节吧，别管它们。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Number nine: This is not the last one, but it is the most important one. Listen. I cannot tell you how many really important people have said that listening is perhaps the most, the number one most important skill that you could develop. Buddha said, and I&#x27;</span>m paraphrasing, &quot;If your mouth is open, you&#x27;re not learning.&quot;</span><br><span class="line">第九条：这不是最后一条，但是最重要的一条。认真倾听。我说不上来到底有多少重要人士都说过倾听可能是最重要的，第一重要的你可以提升的技能。佛曰——我转述一下，“如果你嘴不停，你就学不到东西。” </span><br><span class="line"></span><br><span class="line"><span class="keyword">And</span> Calvin Coolidge said, &quot;No man ever listened his way out of a job. &quot;Why <span class="keyword">do</span> we <span class="keyword">not</span> <span class="keyword">listen</span> <span class="keyword">to</span> <span class="keyword">each</span> other? Number one, w<span class="string">e&#x27;d rather talk. When I&#x27;</span>m talking, I<span class="string">&#x27;m in control. I don&#x27;</span>t have <span class="keyword">to</span> hear anything I<span class="string">&#x27;m not interested in. I&#x27;</span>m the center <span class="keyword">of</span> attention. I can bolster my own <span class="keyword">identity</span>. But ther<span class="string">e&#x27;s another reason: We get distracted. </span></span><br><span class="line"><span class="string">卡尔文·柯立芝曾说：“从没有人是因为听太多而被开除的。”为什么我们不愿倾听彼此？首先，我们更喜欢说。我在说话时一切在我的掌控之中。我不用去听任何我不感兴趣的东西。我是焦点、我可以强化自己的认同感。但还有一个原因：我们会受到干扰。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The average person talks at about 225 word per minute, but we can listen at up to 500 words per minute. So our minds are filling in those other 275 words. And look, I know, it takes effort and energy to actually pay attention to someone, but if you can&#x27;</span>t <span class="keyword">do</span> that, you<span class="string">&#x27;re not in a conversation. </span></span><br><span class="line"><span class="string">人平均每分钟说大约225个单词，但我们每分钟可以听将近500个单词。所以我们的脑子被这另外275个单词占据了。我知道这很耗费精力去真正注意听别人讲。但如果你不这么做，你们就不是在交谈。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You&#x27;</span>re just two people shouting <span class="keyword">out</span> barely related sentences <span class="keyword">in</span> the same place. You have <span class="keyword">to</span> <span class="keyword">listen</span> <span class="keyword">to</span> one another. Stephen Covey said it very beautifully. He said, &quot;Most of us don&#x27;t listen with the intent to understand. We listen with the intent to reply.&quot;</span><br><span class="line">你们只不过是两个人在同一个地方彼此嚷嚷毫不相关的话。你们必须相互倾听。史蒂芬·柯维对此有精彩的论述。他说：“我们大多数人都不是为了理解而倾听，我们为了回应而听。”</span><br><span class="line"></span><br><span class="line">One more <span class="keyword">rule</span>, number <span class="number">10</span>, <span class="keyword">and</span> it<span class="string">&#x27;s this one: Be brief. [A good conversation is like a miniskirt; short enough to retain interest, but long enough to cover the subject. — My Sister] All of this boils down to the same basic concept, and it is this one: Be interested in other people. </span></span><br><span class="line"><span class="string">最后一条，第十条：简明扼要。“好的交谈就像恰到好处的迷你裙，足够短，能够吸引人，又足够长，能够包纳（盖住）主体——我妹妹的比喻”所有这些都浓缩成同一个概念，那就是：对他人产生兴趣。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You know, I grew up with a very famous grandfather, and there was kind of a ritual in my home. People would come over to talk to my grandparents, and after they would leave, my mother would come over to us, and she&#x27;</span>d say, &quot;Do you know who that was? She was the runner-up to Miss America. </span><br><span class="line">我在一个名人外公的身边长大，我家里宾客络绎不绝。访客会前来和我的外祖父母交谈，而那些人离开后，我母亲会过来对我们说：“你们知道那是谁吗？她是美国小姐的亚军。</span><br><span class="line"></span><br><span class="line">He was the mayor of Sacramento. She won a Pulitzer Prize. He&#x27;s a Russian ballet dancer.&quot; <span class="keyword">And</span> I kind <span class="keyword">of</span> grew up assuming everyone has <span class="keyword">some</span> hidden, amazing thing about them. <span class="keyword">And</span> honestly, I think it<span class="string">&#x27;s what makes me a better host. </span></span><br><span class="line"><span class="string">他是萨克拉门托市长。她拿过普利策奖。他是俄罗斯芭蕾舞蹈家。”我在成长中默认了每个人都有不为人知的精彩。说真的，我想是这一切让我成为了更好的主持人。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I keep my mouth shut as often as I possibly can, I keep my mind open, and I&#x27;</span>m <span class="keyword">always</span> <span class="keyword">prepared</span> <span class="keyword">to</span> be amazed, <span class="keyword">and</span> I<span class="string">&#x27;m never disappointed. You do the same thing. Go out, talk to people, listen to people, and, most importantly, be prepared to be amazed. </span></span><br><span class="line"><span class="string">我尽量少说话，但开放自己的思想，永远准备着大吃一惊，而我从不会感到失望。你们也可以这样。走出门去，和别人交谈，听别人说，以及最重要的，准备好大吃一惊。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thanks.</span></span><br><span class="line"><span class="string">谢谢。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TEDinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TED </tag>
            
            <tag> 演讲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TED演讲-只需20小时，你就可以学会任何技能</title>
      <link href="/posts/e724fa48.html"/>
      <url>/posts/e724fa48.html</url>
      
        <content type="html"><![CDATA[<h1>Preface</h1><p>这篇演讲提供了四个步骤，告诉我们只需要20个小时就可以快速学会想学但一直没有时间学的技能。</p><h1>Content</h1><blockquote><p>The first is to deconstruct the skill</p></blockquote><p>第一是解构这个技能，确切地决定你想要做什么，并将它拆解成许多小单元。<strong>你越能够决定技能的哪些部分是可以真正协助达成目标的，你将越有可能在最短的时间内来提升你的成果。</strong></p><blockquote><p>The second is learn enough to self-correct.</p></blockquote><p>第二是学到足以自我矫正。准备3-5个关于你正试着要学的东西的资源，可以是书籍、可以是课程任何东西都可以。你要做的就是学到让自己确实可以独自练习和自我修正。</p><blockquote><p>The third is to remove barriers to practice</p></blockquote><p>第三是移除任何练习时的障碍，让人分心的东西、电视、网路。</p><blockquote><p>第四项就是至少练习20个小时。</p></blockquote><p>第四项就是至少练习20个小时。学习新事物的主要障碍并不是智能上的问题，主要障碍是情绪化。</p><hr><h1>Original</h1><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">Hi everyone.</span><br><span class="line">大家好。</span><br><span class="line"> </span><br><span class="line">One <span class="keyword">of</span> the things that I enjoy <span class="built_in">is</span> learning <span class="built_in">new</span> things.How <span class="type">long</span> does it <span class="keyword">take</span> <span class="keyword">to</span> acquire a <span class="built_in">new</span> skill?</span><br><span class="line">我有许多喜欢做的事，而学习新事物就是其中一件。习得一个新的才艺需要多久呢？</span><br><span class="line"> </span><br><span class="line">You know what I found? <span class="number">10</span>,<span class="number">000</span> hours?!</span><br><span class="line">你知道我的发现吗？<span class="number">1</span>万个小时？</span><br><span class="line"> </span><br><span class="line">Nooooooo!</span><br><span class="line">不不不不不！</span><br><span class="line"> </span><br><span class="line">I am never going <span class="keyword">to</span> be able <span class="keyword">to</span> learn anything <span class="built_in">new</span> ever again.</span><br><span class="line">这样我再也不可能学习到任何新的东西。</span><br><span class="line"> </span><br><span class="line">But that<span class="comment">&#x27;s not true.</span></span><br><span class="line">事实并非如此。</span><br><span class="line"> </span><br><span class="line">The <span class="number">10</span>,<span class="number">000</span> hour rule came out <span class="keyword">of</span> studies <span class="keyword">of</span> expert level performance.</span><br><span class="line">一万小时法则出自于一些达到专家级成就的研究结果。</span><br><span class="line"> </span><br><span class="line">Professional athletes, world <span class="keyword">class</span> musicians.</span><br><span class="line"> 职业运动选手、世界级音乐大师。</span><br><span class="line"> </span><br><span class="line">The folks at the tippy top <span class="keyword">of</span> their fields put <span class="keyword">in</span> around <span class="number">10</span>,<span class="number">000</span> hours <span class="keyword">of</span> practice.</span><br><span class="line">这些在各领域中的顶尖人物都投入了约<span class="number">1</span>万个小时来演练学习，</span><br><span class="line"> </span><br><span class="line">But that last statement- it takes <span class="number">10</span>,<span class="number">000</span> hours <span class="keyword">to</span> learn something?</span><br><span class="line">但是真的需要<span class="number">1</span>万个小时来学新的技能吗？</span><br><span class="line"> </span><br><span class="line">It<span class="comment">&#x27;s not true.</span></span><br><span class="line">其实不然。</span><br><span class="line"> </span><br><span class="line">This <span class="built_in">is</span> the learning curve, <span class="built_in">and</span> the story <span class="keyword">of</span> the learning curve <span class="built_in">is</span></span><br><span class="line">这是学习曲线，而这说明了，</span><br><span class="line"> </span><br><span class="line"><span class="keyword">when</span> you start you<span class="comment">&#x27;re grossly incompetent and you know it.</span></span><br><span class="line">在刚开始学习时你是完全不会的，我想你也知道。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">With</span> a little bit <span class="keyword">of</span> practice,</span><br><span class="line">而再来一点点的练习，</span><br><span class="line"> </span><br><span class="line">you <span class="keyword">get</span> really good really quick</span><br><span class="line">你很快就可以达到相当好的水准，</span><br><span class="line"> </span><br><span class="line"><span class="built_in">and</span> <span class="keyword">then</span> at a certain point you reach a plateau</span><br><span class="line">然后在某个点之后你会到达稳定时期，</span><br><span class="line"> </span><br><span class="line"><span class="built_in">and</span> the subsequent gains become much harder <span class="keyword">to</span> <span class="keyword">get</span>.</span><br><span class="line">且随后水准的提升将变得更难。</span><br><span class="line"> </span><br><span class="line">How <span class="type">long</span> does it <span class="keyword">take</span> <span class="keyword">from</span> starting something <span class="built_in">and</span> being grossly incompetent</span><br><span class="line">那需要多久时间来让我们从一个完全不会的状态</span><br><span class="line"> </span><br><span class="line"><span class="built_in">and</span> knowing it <span class="keyword">to</span> being reasonably good?</span><br><span class="line">到表现出合理的好水平呢？</span><br><span class="line"> </span><br><span class="line">Here<span class="comment">&#x27;s what my research says: 20 hours, that&#x27;s it.</span></span><br><span class="line">我的研究告诉我：<span class="number">20</span>个小时而已。</span><br><span class="line"> </span><br><span class="line">You can go <span class="keyword">from</span> knowing <span class="literal">nothing</span>-<span class="keyword">if</span> you put <span class="number">20</span> hours <span class="keyword">of</span> focused deliberate practice <span class="keyword">into</span> that thing,you will be astounded at how good you are.</span><br><span class="line">你可以完全不懂某件事——如果你投入<span class="number">20</span>个小时刻意地完全专注于某件事的练习，你将惊讶于自己的提升水平。</span><br><span class="line"> </span><br><span class="line"><span class="number">20</span> hours <span class="built_in">is</span> <span class="keyword">do</span>-able,it<span class="comment">&#x27;s about 45 minutes a day for about a month.</span></span><br><span class="line"><span class="number">20</span>个小时是可行的，这大约是每天<span class="number">45</span>分钟，持续约一个月。</span><br><span class="line"> </span><br><span class="line">There<span class="comment">&#x27;s a method to doing this.</span></span><br><span class="line">做这个是有诀窍的，</span><br><span class="line"> </span><br><span class="line">The first <span class="built_in">is</span> <span class="keyword">to</span> deconstruct the skill,decide exactly what you want <span class="keyword">to</span> be able <span class="keyword">to</span> <span class="keyword">do</span> <span class="built_in">and</span> break it down <span class="keyword">into</span> smaller <span class="built_in">and</span> smaller pieces.</span><br><span class="line">第一是解构这个技能，确切地决定你想要做什么，并将它拆解成许多小单元。</span><br><span class="line"> </span><br><span class="line">The more you<span class="comment">&#x27;re able to decide what are the parts of this skill that will actually help me get to what I want,</span></span><br><span class="line">你越能够决定技能的哪些部分是可以真正协助达成目标的，</span><br><span class="line"> </span><br><span class="line">you<span class="comment">&#x27;ll be able to improve your performance in the least amount of time possible.</span></span><br><span class="line">你将越有可能在最短的时间内来提升你的成果。</span><br><span class="line"> </span><br><span class="line">The second <span class="built_in">is</span> learn enough <span class="keyword">to</span> self-correct.</span><br><span class="line">第二是学到足以自我矫正。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">Get</span> <span class="number">3</span> <span class="keyword">to</span> <span class="number">5</span> resources about what it <span class="built_in">is</span> you<span class="comment">&#x27;re trying to learn-</span></span><br><span class="line">准备<span class="number">3</span>-<span class="number">5</span>个关于你正试着要学的东西的资源 -</span><br><span class="line"> </span><br><span class="line">it could be books, could be courses, could be anything.</span><br><span class="line">可以是书籍、可以是课程任何东西都可以。</span><br><span class="line"> </span><br><span class="line">What you want <span class="keyword">to</span> <span class="keyword">do</span> <span class="built_in">is</span> learn just enough that you can actually practice <span class="built_in">and</span> self-correct.</span><br><span class="line">你要做的就是学到让自己确实可以独自练习和自我修正。</span><br><span class="line"> </span><br><span class="line">Noticing <span class="keyword">when</span> you<span class="comment">&#x27;re making a mistake and then doing something a little different.</span></span><br><span class="line">注意自己所犯的错误，然后一点一点改变。</span><br><span class="line"> </span><br><span class="line">The third <span class="built_in">is</span> <span class="keyword">to</span> remove barriers <span class="keyword">to</span> practice-</span><br><span class="line">第三是移除任何练习时的障碍 -</span><br><span class="line"> </span><br><span class="line">distractions, television, internet.</span><br><span class="line">让人分心的东西、电视、网路。</span><br><span class="line"> </span><br><span class="line"><span class="built_in">And</span> the fourth <span class="built_in">is</span> <span class="keyword">to</span> practice <span class="keyword">for</span> at least <span class="number">20</span> hours.</span><br><span class="line">第四项就是至少练习<span class="number">20</span>个小时。</span><br><span class="line"> </span><br><span class="line">Now, most skills have what I <span class="keyword">call</span> a frustration barrier.</span><br><span class="line">注意，大部份的技能学习时都会出现我所谓的挫折障碍。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">By</span> pre-committing <span class="keyword">to</span> practicing whatever it <span class="built_in">is</span> that you want <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">for</span> at least <span class="number">20</span> hours,you will be able <span class="keyword">to</span> overcome that initial frustration barrier <span class="built_in">and</span> stick <span class="keyword">with</span> the practice <span class="type">long</span> enough <span class="keyword">to</span> actually reap the rewards.</span><br><span class="line">无论想学什么，自我许诺至少练习<span class="number">20</span>个小时，你将能克服一开始的的挫折障碍，而能继续练习，坚持到时间长度确实足以获得回馈。</span><br><span class="line"> </span><br><span class="line">That<span class="comment">&#x27;s it, it&#x27;s not rocket science.</span></span><br><span class="line">就是这样，这并不难。</span><br><span class="line"> </span><br><span class="line">The major barrier <span class="keyword">to</span> learning something <span class="built_in">new</span> <span class="built_in">is</span> <span class="built_in">not</span> intellectual.</span><br><span class="line">学习新事物的主要障碍并不是智能上的问题，</span><br><span class="line"> </span><br><span class="line">The major barrier <span class="built_in">is</span> emotional.</span><br><span class="line">主要障碍是情绪化。</span><br><span class="line"> </span><br><span class="line">Feeling stupid doesn<span class="comment">&#x27;t feel good and the beginning of learning anything new and the beginning of learning anything new... you feel really stupid.</span></span><br><span class="line">愚蠢的感觉让人很不舒服，而在刚开始新的学习时，你会觉得自己真的愚不可及。</span><br><span class="line"> </span><br><span class="line">But, put <span class="number">20</span> hours <span class="keyword">into</span> anything.</span><br><span class="line">但是就投入<span class="number">20</span>个小时吧。</span><br><span class="line"> </span><br><span class="line"><span class="keyword">Do</span> you want <span class="keyword">to</span> learn a language?</span><br><span class="line">想要学新的语言？</span><br><span class="line"></span><br><span class="line"><span class="keyword">Do</span> you want <span class="keyword">to</span> learn how <span class="keyword">to</span> cook?</span><br><span class="line">想要练习厨艺？</span><br><span class="line"> </span><br><span class="line"><span class="keyword">Do</span> you want <span class="keyword">to</span> learn how <span class="keyword">to</span> draw?</span><br><span class="line">想要学习绘画？</span><br><span class="line"> </span><br><span class="line">Go out <span class="built_in">and</span> <span class="keyword">do</span> that thing.</span><br><span class="line">跨出那一步，努力去做吧！</span><br><span class="line"> </span><br><span class="line">It only takes <span class="number">20</span> hours.</span><br><span class="line">这只需要<span class="number">20</span>个小时。</span><br><span class="line"> </span><br><span class="line">Have fun. </span><br><span class="line">祝大家学得开心！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TEDinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TED </tag>
            
            <tag> 演讲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TED演讲-拖延症人群的内心世界</title>
      <link href="/posts/7b5c74af.html"/>
      <url>/posts/7b5c74af.html</url>
      
        <content type="html"><![CDATA[<h1>Preface</h1><p>这篇演讲带我们走进内心世界，了解拖延的本质，并提供方法来克服它。</p><h1>Content</h1><blockquote><p>the procrastinator’s brain also has an Instant Gratification Monkey. He lives entirely in the present moment.</p></blockquote><p>拖延症者大脑里有一只即时满足的猴子。他完全活在当下。</p><blockquote><p>He has no memory of the past, no knowledge of the future, and he only cares about two things: easy and fun.</p></blockquote><p>他没有过去的记忆，没有对未来的了解，他只关心两件事：简单和快乐。</p><hr><h1>Original</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br></pre></td><td class="code"><pre><span class="line">A couple <span class="keyword">of</span> years ago, I decided <span class="keyword">to</span> <span class="built_in">write</span> <span class="keyword">about</span> procrastination.</span><br><span class="line">几年前，我决定写一篇关于拖延症的文章。</span><br><span class="line"></span><br><span class="line">My behavior has always perplexed <span class="keyword">the</span> non-procrastinators <span class="keyword">around</span> <span class="keyword">me</span>,</span><br><span class="line">我的拖延行为总是让我身边那些不拖延的人感到困惑，</span><br><span class="line"><span class="keyword">and</span> I wanted <span class="keyword">to</span> explain <span class="keyword">to</span> <span class="keyword">the</span> non-procrastinators <span class="keyword">of</span> <span class="keyword">the</span> world what goes <span class="keyword">on</span> <span class="keyword">in</span> <span class="keyword">the</span> heads <span class="keyword">of</span> procrastinators, <span class="keyword">and</span> why we are <span class="keyword">the</span> way we are.</span><br><span class="line">所以我想向不拖延的人解释一下拖延者脑袋里到底是怎么想的，还有为什么我们这些拖延者会这样。</span><br><span class="line"></span><br><span class="line">Now, I had a hypothesis <span class="keyword">that</span> <span class="keyword">the</span> brains <span class="keyword">of</span> procrastinators were actually different than <span class="keyword">the</span> brains <span class="keyword">of</span> other people.</span><br><span class="line">我的假设是拖延者的大脑和不拖延者的大脑是不同的。</span><br><span class="line"></span><br><span class="line">And <span class="keyword">to</span> test this, I found an MRI lab <span class="keyword">that</span> actually let <span class="keyword">me</span> scan both <span class="keyword">my</span> brain <span class="keyword">and</span> <span class="keyword">the</span> brain <span class="keyword">of</span> a proven non-procrastinator, so I could compare them.</span><br><span class="line">为了证明这一点，我找到一个核磁共振实验室让我可以扫描自己的大脑和一个经证实不是拖延者的大脑，然后我就可以对比这两种大脑。</span><br><span class="line"></span><br><span class="line">I actually brought them here <span class="keyword">to</span> show you today.</span><br><span class="line">今天我把它们都带来了。</span><br><span class="line"></span><br><span class="line">I want you <span class="keyword">to</span> take a look carefully <span class="keyword">to</span> see <span class="keyword">if</span> you can notice a difference.</span><br><span class="line">我希望大家能认真比较这二者之间是否有什么差别。</span><br><span class="line"></span><br><span class="line">I know <span class="keyword">that</span> <span class="keyword">if</span> you&#x27;re <span class="keyword">not</span> a trained brain expert, <span class="keyword">it</span>&#x27;s <span class="keyword">not</span> <span class="keyword">that</span> obvious, <span class="keyword">but</span> just take a look, OK?</span><br><span class="line">我知道大家不是受过训练的脑科专家，看起来可能不明显，但是让我们来看一下，好吗？</span><br><span class="line">So here&#x27;s <span class="keyword">the</span> brain <span class="keyword">of</span> a non-procrastinator.</span><br><span class="line">这是一个不拖延者的大脑。</span><br><span class="line"></span><br><span class="line">Now ...</span><br><span class="line">现在...</span><br><span class="line">here&#x27;s <span class="keyword">my</span> brain.</span><br><span class="line">这是我的大脑。</span><br><span class="line"></span><br><span class="line">There <span class="keyword">is</span> a difference.</span><br><span class="line">这二者之间有一个区别。</span><br><span class="line"></span><br><span class="line">Both brains have a Rational Decision-Maker <span class="keyword">in</span> them, <span class="keyword">but</span> <span class="keyword">the</span> procrastinator&#x27;s brain also has an Instant Gratification Monkey.</span><br><span class="line">两种大脑里头都有一个理性的决策制定者，但是拖延者的大脑里，还有一只叫即时满足的猴子。</span><br><span class="line"></span><br><span class="line">Now, what <span class="keyword">does</span> this mean <span class="keyword">for</span> <span class="keyword">the</span> procrastinator?</span><br><span class="line">那么，这对拖延症患者意味着什么呢？</span><br><span class="line">Well, <span class="keyword">it</span> means everything&#x27;s fine <span class="keyword">until</span> this happens.</span><br><span class="line">它意味着在这件事发生之前一切都挺好的。</span><br><span class="line"></span><br><span class="line">So <span class="keyword">the</span> Rational Decision-Maker will make <span class="keyword">the</span> rational decision <span class="keyword">to</span> do something productive, <span class="keyword">but</span> <span class="keyword">the</span> Monkey doesn&#x27;t like <span class="keyword">that</span> plan,</span><br><span class="line">于是当理性的决策制定者做出理性的决策，想做一些富有成效的事时，猴子不想这么做，</span><br><span class="line">so he actually takes <span class="keyword">the</span> wheel, <span class="keyword">and</span> he says, <span class="string">&quot;Actually, let&#x27;s read the entire Wikipedia page of the Nancy Kerrigan/ Tonya Harding scandal,</span></span><br><span class="line"><span class="string">而且他说：“实际上，让我们来读一下维基百科上关于南茜·克里根或者汤妮·雅哈丁的丑闻案吧，</span></span><br><span class="line"><span class="string">because I just remembered that that happened.&quot;</span></span><br><span class="line">因为我刚想起来那件事。</span><br><span class="line">”</span><br><span class="line">Then <span class="comment">--</span></span><br><span class="line">然后<span class="comment">--</span></span><br><span class="line">Then we&#x27;re going <span class="keyword">to</span> go <span class="keyword">over</span> <span class="keyword">to</span> <span class="keyword">the</span> fridge, <span class="keyword">to</span> see <span class="keyword">if</span> there&#x27;s anything new <span class="keyword">in</span> there <span class="keyword">since</span> <span class="number">10</span> minutes ago.</span><br><span class="line">然后让我们走到冰箱，翻翻看这<span class="number">10</span>分钟以来有没什么新东西。</span><br><span class="line"></span><br><span class="line">After <span class="keyword">that</span>, we&#x27;re going <span class="keyword">to</span> go <span class="keyword">on</span> a YouTube spiral <span class="keyword">that</span> <span class="keyword">starts with</span> videos <span class="keyword">of</span> Richard Feynman talking <span class="keyword">about</span> magnets <span class="keyword">and</span> ends much,</span><br><span class="line">之后，让我们继续在视频网站上浏览，从理查德·费曼谈磁性的视频开始看，</span><br><span class="line">much later <span class="keyword">with</span> us watching interviews <span class="keyword">with</span> Justin Bieber&#x27;s mom.</span><br><span class="line">一直看到对贾斯汀·比伯老妈的采访看到地老天荒。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;All of that&#x27;s going to take a while, so we&#x27;re not going to really have room on the schedule for any work today.</span></span><br><span class="line"><span class="string">“这一切都花时间，所以我们今天的日程安排没办法抽空干活。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sorry!&quot;</span></span><br><span class="line">对不起！”</span><br><span class="line">Now, what <span class="keyword">is</span> going <span class="keyword">on</span> here?</span><br><span class="line">这是怎么回事？</span><br><span class="line"></span><br><span class="line">The Instant Gratification Monkey <span class="keyword">does</span> <span class="keyword">not</span> seem like a guy you want <span class="keyword">behind</span> <span class="keyword">the</span> wheel.</span><br><span class="line">即时满足猴子似乎不是那个你想让他操控方向盘的人。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">He lives entirely <span class="keyword">in</span> <span class="keyword">the</span> present moment.</span><br><span class="line">他完全活在当下。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">He has no memory <span class="keyword">of</span> <span class="keyword">the</span> past, no knowledge <span class="keyword">of</span> <span class="keyword">the</span> future, <span class="keyword">and</span> he only cares <span class="keyword">about</span> two things: easy <span class="keyword">and</span> fun.</span><br><span class="line">他没有过去的记忆，没有对未来的了解，他只关心两件事：简单和快乐。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, <span class="keyword">in</span> <span class="keyword">the</span> animal world, <span class="keyword">that</span> works fine.</span><br><span class="line">在动物世界里，这样没问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">If you&#x27;re a dog <span class="keyword">and</span> you spend your whole life doing nothing other than easy <span class="keyword">and</span> fun things, you&#x27;re a huge success!</span><br><span class="line">如果你是一条狗，你简单、快乐地度过这一生，就已经是巨大的成功！</span><br><span class="line"></span><br><span class="line">And <span class="keyword">to</span> <span class="keyword">the</span> Monkey, humans are just another animal species.</span><br><span class="line">而对于猴子来说，人类是另外一种动物。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">You have <span class="keyword">to</span> keep well-slept, well-fed <span class="keyword">and</span> propagating <span class="keyword">into</span> <span class="keyword">the</span> next generation, which <span class="keyword">in</span> tribal <span class="keyword">times</span> might have worked OK.</span><br><span class="line">你睡好、吃饱、繁殖下一代，这么做在部落时代或许没问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">But, <span class="keyword">if</span> you haven&#x27;t noticed, now we&#x27;re <span class="keyword">not</span> <span class="keyword">in</span> tribal <span class="keyword">times</span>.</span><br><span class="line">但是，假如你还没注意到，我们现在不是生活在部落时代。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We&#x27;re <span class="keyword">in</span> an advanced civilization, <span class="keyword">and</span> <span class="keyword">the</span> Monkey <span class="keyword">does</span> <span class="keyword">not</span> know what <span class="keyword">that</span> <span class="keyword">is</span>.</span><br><span class="line">我们处于一个先进的文明，而猴子根本不懂那是什么。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Which <span class="keyword">is</span> why we have another guy <span class="keyword">in</span> our brain, <span class="keyword">the</span> Rational Decision-Maker, who gives us <span class="keyword">the</span> ability <span class="keyword">to</span> do things no other animal can do.</span><br><span class="line">这就是为什么我们脑袋里还有另外一个家伙，理性的决策制定者，他让我们有能力去做其他动物无法做到的事情。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We can visualize <span class="keyword">the</span> future.</span><br><span class="line">我们可以预见未来。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We can see <span class="keyword">the</span> big picture.</span><br><span class="line">我们可以顾全大局。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We can make long-term plans.</span><br><span class="line">我们可以做长期打算。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And he wants <span class="keyword">to</span> take all <span class="keyword">of</span> <span class="keyword">that</span> <span class="keyword">into</span> account.</span><br><span class="line">而且他想把这些都考虑进去。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And he wants <span class="keyword">to</span> just have us do whatever makes sense <span class="keyword">to</span> be doing right now.</span><br><span class="line">他想让我们做任何值得现在去做的事儿。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, sometimes <span class="keyword">it</span> makes sense <span class="keyword">to</span> be doing things <span class="keyword">that</span> are easy <span class="keyword">and</span> fun,</span><br><span class="line">有时做简单快乐的事是有意义的，</span><br><span class="line"></span><br><span class="line">like when you&#x27;re having dinner <span class="keyword">or</span> going <span class="keyword">to</span> bed <span class="keyword">or</span> enjoying well-earned leisure <span class="built_in">time</span>.</span><br><span class="line">比如吃饭、睡觉或者享受应得的休闲时光。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">That&#x27;s why there&#x27;s an overlap.</span><br><span class="line">这就是为什么即时满足猴子和理性的决策制定者之间有重合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sometimes they agree.</span><br><span class="line">有时他们意见一致。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">But other <span class="keyword">times</span>, <span class="keyword">it</span> makes much more sense <span class="keyword">to</span> be doing things <span class="keyword">that</span> are harder <span class="keyword">and</span> less pleasant, <span class="keyword">for</span> <span class="keyword">the</span> sake <span class="keyword">of</span> <span class="keyword">the</span> big picture.</span><br><span class="line">但是有时，更有意义的是去做那些比较难而且不那么让人享受的事情，这是出于全局的考虑。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And <span class="keyword">that</span>&#x27;s when we have a conflict.</span><br><span class="line">此时二者之间会产生冲突。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And <span class="keyword">for</span> <span class="keyword">the</span> procrastinator, <span class="keyword">that</span> conflict tends <span class="keyword">to</span> <span class="keyword">end</span> a certain way <span class="keyword">every</span> <span class="built_in">time</span>, leaving him spending a lot <span class="keyword">of</span> <span class="built_in">time</span> <span class="keyword">in</span> this orange zone,</span><br><span class="line">对于拖延者来说，每次冲突都以这种方式结束，就是他在橙色区域花费了大量时间，</span><br><span class="line"></span><br><span class="line">an easy <span class="keyword">and</span> fun place <span class="keyword">that</span>&#x27;s entirely <span class="keyword">out of</span> <span class="keyword">the</span> Makes Sense circle.</span><br><span class="line">这是那个简单又快乐，但是又没有意义的那个区域。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I call <span class="keyword">it</span> <span class="keyword">the</span> Dark Playground.</span><br><span class="line">我把这片区域称为黑暗的操场。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, <span class="keyword">the</span> Dark Playground <span class="keyword">is</span> a place <span class="keyword">that</span> all <span class="keyword">of</span> you procrastinators out there know very well.</span><br><span class="line">黑暗的操场是一个所有拖延者都很了解的地方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">It&#x27;s <span class="keyword">where</span> leisure activities happen <span class="keyword">at</span> <span class="keyword">times</span> when leisure activities are <span class="keyword">not</span> supposed <span class="keyword">to</span> be happening.</span><br><span class="line">这里是在本来不应该休闲的时候的休闲娱乐的活动场所。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The fun you have <span class="keyword">in</span> <span class="keyword">the</span> Dark Playground <span class="keyword">isn&#x27;t</span> actually fun, because <span class="keyword">it</span>&#x27;s completely unearned,</span><br><span class="line">在黑暗的操场得到的快乐其实并不是快乐，因为它完全是不劳而获的，</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">the</span> air <span class="keyword">is</span> filled <span class="keyword">with</span> guilt, dread, anxiety, self-hatred <span class="comment">-- all of those good procrastinator feelings.</span></span><br><span class="line">这会带来内疚、恐惧、焦虑、自我憎恨这是所有拖延者的感受。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And <span class="keyword">the</span> question <span class="keyword">is</span>, <span class="keyword">in</span> this situation, <span class="keyword">with</span> <span class="keyword">the</span> Monkey <span class="keyword">behind</span> <span class="keyword">the</span> wheel,</span><br><span class="line">而且问题是，在这种情况下，由猴子掌控着方向盘，</span><br><span class="line"></span><br><span class="line">how <span class="keyword">does</span> <span class="keyword">the</span> procrastinator ever <span class="keyword">get</span> himself <span class="keyword">over</span> here <span class="keyword">to</span> this blue zone, a less pleasant place, <span class="keyword">but</span> <span class="keyword">where</span> really important things happen?</span><br><span class="line">怎么能让拖延者把自己带去蓝色区域那边呢，那边虽然没那么舒适，但是有很多重要的事情要做。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Well, turns out <span class="keyword">the</span> procrastinator has a guardian angel,</span><br><span class="line">其实拖延者有个守护天使，</span><br><span class="line"></span><br><span class="line">someone who&#x27;s always looking down <span class="keyword">on</span> him <span class="keyword">and</span> watching <span class="keyword">over</span> him <span class="keyword">in</span> his darkest moments <span class="comment">-- someone called the Panic Monster.</span></span><br><span class="line">总是看不起他并且看守着他，在那些最黑暗的时刻它被称为恐慌怪兽。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, <span class="keyword">the</span> Panic Monster <span class="keyword">is</span> dormant most <span class="keyword">of</span> <span class="keyword">the</span> <span class="built_in">time</span>,</span><br><span class="line">恐慌怪兽大部分时间都在冬眠，</span><br><span class="line"></span><br><span class="line"><span class="keyword">but</span> he suddenly wakes up anytime a deadline gets too close <span class="keyword">or</span> there&#x27;s danger <span class="keyword">of</span> public embarrassment,</span><br><span class="line">但是截止期很靠近的时候或者处于在公众面前出丑的危险中时，</span><br><span class="line"></span><br><span class="line">a career disaster <span class="keyword">or</span> <span class="keyword">some</span> other scary consequence.</span><br><span class="line">或面临事业灾难时，或有其他可怕的后果时，它就会突然醒来。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And importantly, he&#x27;s <span class="keyword">the</span> only thing <span class="keyword">the</span> Monkey <span class="keyword">is</span> terrified <span class="keyword">of</span>.</span><br><span class="line">而且重要的是，他是猴子唯一害怕的东西。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, he became very relevant <span class="keyword">in</span> <span class="keyword">my</span> life pretty recently,</span><br><span class="line">最近在我的生活里，恐慌怪兽变得相当重要，</span><br><span class="line"></span><br><span class="line">because <span class="keyword">the</span> people <span class="keyword">of</span> TED reached out <span class="keyword">to</span> <span class="keyword">me</span> <span class="keyword">about</span> six months ago <span class="keyword">and</span> invited <span class="keyword">me</span> <span class="keyword">to</span> do a TED Talk.</span><br><span class="line">因为TED的工作人员<span class="number">6</span>个月之前联络过我，邀请我做一次演讲。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, <span class="keyword">of</span> course, I said yes.</span><br><span class="line">当然，我答应啦。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">It&#x27;s always been a dream <span class="keyword">of</span> mine <span class="keyword">to</span> have done a TED Talk <span class="keyword">in</span> <span class="keyword">the</span> past.</span><br><span class="line">我以前一直梦想着可以做一次TED演讲。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">But <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">middle</span> <span class="keyword">of</span> all this excitement, <span class="keyword">the</span> Rational Decision-Maker seemed <span class="keyword">to</span> have something <span class="keyword">else</span> <span class="keyword">on</span> his mind.</span><br><span class="line">但是在这种兴奋中，理性的决策制定者似乎在想别的事。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">He was saying, <span class="string">&quot;Are we clear on what we just accepted?</span></span><br><span class="line"><span class="string">他会说：“我们清楚刚才答应了什么吗？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Do we get what&#x27;s going to be now happening one day in the future?</span></span><br><span class="line"><span class="string">我们现在具有完成将来那个任务所需的能力吗？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">We need to sit down and work on this right now.&quot;</span></span><br><span class="line">我们得坐下来开始干活。</span><br><span class="line">”</span><br><span class="line"></span><br><span class="line">And <span class="keyword">the</span> Monkey said, <span class="string">&quot;Totally agree, but let&#x27;s just open Google Earth and zoom in to the bottom of India, like 200 feet above the ground,</span></span><br><span class="line"><span class="string">猴子说：“完全同意，但是让我们打开谷歌地球，把镜头推进到印度地下200尺，</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">and scroll up for two and a half hours til we get to the top of the country, so we can get a better feel for India.&quot;</span></span><br><span class="line">然后花两个半小时向上滚动到这个国家的地表，让我们更好地感受一下印度。</span><br><span class="line">”</span><br><span class="line"></span><br><span class="line">So <span class="keyword">that</span>&#x27;s what we did <span class="keyword">that</span> <span class="built_in">day</span>.</span><br><span class="line">那天我就是这么做的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">As six months turned <span class="keyword">into</span> four <span class="keyword">and</span> <span class="keyword">then</span> two <span class="keyword">and</span> <span class="keyword">then</span> one, <span class="keyword">the</span> people <span class="keyword">of</span> TED decided <span class="keyword">to</span> release <span class="keyword">the</span> speakers.</span><br><span class="line">当<span class="number">6</span>个月变成<span class="number">4</span>个月，然后<span class="number">2</span>个月，然后<span class="number">1</span>个月时，TED工作人员开始发布演讲者。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And I opened up <span class="keyword">the</span> website, <span class="keyword">and</span> there was <span class="keyword">my</span> face staring right <span class="keyword">back</span> <span class="keyword">at</span> <span class="keyword">me</span>.</span><br><span class="line">我打开网站看到自己的脸盯着自己看。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And guess who woke up?</span><br><span class="line">你猜这个时候谁醒了？</span><br><span class="line"></span><br><span class="line">So <span class="keyword">the</span> Panic Monster starts losing his mind, <span class="keyword">and</span> a few seconds later, <span class="keyword">the</span> whole system&#x27;s <span class="keyword">in</span> mayhem.</span><br><span class="line">于是恐慌怪兽开始发疯，几秒钟之后，整个系统一片混乱。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And <span class="keyword">the</span> Monkey <span class="comment">-- remember, he&#x27;s terrified of the Panic Monster -- boom, he&#x27;s up the tree!</span></span><br><span class="line">而猴子，还记得吗？他害怕恐慌怪兽嘣的一声，他爬到树上去了！</span><br><span class="line"></span><br><span class="line">And finally, finally, <span class="keyword">the</span> Rational Decision-Maker can take <span class="keyword">the</span> wheel <span class="keyword">and</span> I can start working <span class="keyword">on</span> <span class="keyword">the</span> talk.</span><br><span class="line">于是终于，理性的决策制定者终于可以操控方向盘，我可以开始准备这次演讲。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, <span class="keyword">the</span> Panic Monster explains all kinds <span class="keyword">of</span> pretty insane procrastinator behavior,</span><br><span class="line">现在，恐慌怪兽解释了各种疯狂的拖延者行为，</span><br><span class="line"></span><br><span class="line">like how someone like <span class="keyword">me</span> could spend two weeks unable <span class="keyword">to</span> start <span class="keyword">the</span> opening sentence <span class="keyword">of</span> a paper,</span><br><span class="line">就比如我这样的人花了两个星期还没办法开始写论文的开头语，</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">then</span> miraculously find <span class="keyword">the</span> unbelievable work ethic <span class="keyword">to</span> stay up all night <span class="keyword">and</span> <span class="built_in">write</span> eight pages.</span><br><span class="line">然后奇迹般地又拥有了令人难以置信的工作热情整晚熬夜写了<span class="number">8</span>页。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And this entire situation, <span class="keyword">with</span> <span class="keyword">the</span> three <span class="built_in">characters</span> <span class="comment">-- this is the procrastinator&#x27;s system.</span></span><br><span class="line">整个情况中的三种角色构建了拖延者的系统。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">It&#x27;s <span class="keyword">not</span> pretty, <span class="keyword">but</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">end</span>, <span class="keyword">it</span> works.</span><br><span class="line">不美好，但是至少还有用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This <span class="keyword">is</span> what I decided <span class="keyword">to</span> <span class="built_in">write</span> <span class="keyword">about</span> <span class="keyword">on</span> <span class="keyword">the</span> blog a couple <span class="keyword">of</span> years ago.</span><br><span class="line">这是我几年前决定在博客写的东西。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">When I did, I was amazed <span class="keyword">by</span> <span class="keyword">the</span> response.</span><br><span class="line">发布之后，收到的回应让我大吃一惊。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Literally thousands <span class="keyword">of</span> emails came <span class="keyword">in</span>, <span class="keyword">from</span> all different kinds <span class="keyword">of</span> people <span class="keyword">from</span> all <span class="keyword">over</span> <span class="keyword">the</span> world, doing all different kinds <span class="keyword">of</span> things.</span><br><span class="line">我收到几千封邮件，来自世界各地不同地方的人，他们做着各种不同的事儿。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">These are people who were nurses, bankers, painters, engineers <span class="keyword">and</span> lots <span class="keyword">and</span> lots <span class="keyword">of</span> PhD students.</span><br><span class="line">有护士、银行家、画家、工程师还有很多很多博士生。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And they were all writing, saying <span class="keyword">the</span> same thing: <span class="string">&quot;I have this problem too.&quot;</span></span><br><span class="line">内容基本上差不多：“我也有这个问题。</span><br><span class="line">”</span><br><span class="line"></span><br><span class="line">But what struck <span class="keyword">me</span> was <span class="keyword">the</span> contrast <span class="keyword">between</span> <span class="keyword">the</span> light tone <span class="keyword">of</span> <span class="keyword">the</span> post <span class="keyword">and</span> <span class="keyword">the</span> heaviness <span class="keyword">of</span> these emails.</span><br><span class="line">但是让我印象深刻的是那种反差，帖子的轻松口吻和那些邮件的沉重语气的反差。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">These people were writing <span class="keyword">with</span> intense frustration <span class="keyword">about</span> what procrastination had done <span class="keyword">to</span> their lives, <span class="keyword">about</span> what this Monkey had done <span class="keyword">to</span> them.</span><br><span class="line">这些人有强烈的挫败感因为拖延影响到他们的生活，因为猴子控制了他们的想法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And I thought <span class="keyword">about</span> this, <span class="keyword">and</span> I said, well, <span class="keyword">if</span> <span class="keyword">the</span> procrastinator&#x27;s system works, <span class="keyword">then</span> what&#x27;s going <span class="keyword">on</span>?</span><br><span class="line">思考之后，我的问题是如果拖延者的系统是有效的，那么到底是怎么回事？</span><br><span class="line"></span><br><span class="line">Why are all <span class="keyword">of</span> these people <span class="keyword">in</span> such a dark place?</span><br><span class="line">为什么这些人身陷如此灰暗的境地？</span><br><span class="line"></span><br><span class="line">Well, <span class="keyword">it</span> turns out <span class="keyword">that</span> there&#x27;s two kinds <span class="keyword">of</span> procrastination.</span><br><span class="line">结果我发现原来有两种拖延。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Everything I&#x27;ve talked <span class="keyword">about</span> today, <span class="keyword">the</span> examples I&#x27;ve <span class="keyword">given</span>, they all have deadlines.</span><br><span class="line">我今天谈到的，上面举过的例子都有截止期。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And when there&#x27;s deadlines, <span class="keyword">the</span> effects <span class="keyword">of</span> procrastination are contained <span class="keyword">to</span> <span class="keyword">the</span> short term because <span class="keyword">the</span> Panic Monster gets involved.</span><br><span class="line">有截止期的时候，拖延的影响被限制在一个较短的期限内，因为恐慌怪兽会介入。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">But there&#x27;s a <span class="keyword">second</span> kind <span class="keyword">of</span> procrastination <span class="keyword">that</span> happens <span class="keyword">in</span> situations when there <span class="keyword">is</span> no deadline.</span><br><span class="line">但是对于第二种拖延来说，它发生在没有截止期的情况下。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So <span class="keyword">if</span> you wanted a career <span class="keyword">where</span> you&#x27;re a self-starter <span class="comment">-- something in the arts,</span></span><br><span class="line">比如你想自己创业或者从事艺术类的工作，</span><br><span class="line"></span><br><span class="line">something entrepreneurial <span class="comment">-- there&#x27;s no deadlines on those things at first,</span></span><br><span class="line">起初并没有截止期，</span><br><span class="line"></span><br><span class="line">because nothing&#x27;s happening, <span class="keyword">not</span> <span class="keyword">until</span> you&#x27;ve gone out <span class="keyword">and</span> done <span class="keyword">the</span> hard work <span class="keyword">to</span> <span class="keyword">get</span> momentum, <span class="keyword">get</span> things going.</span><br><span class="line">因为在你还没有开始努力干活之前。</span><br><span class="line">不会有任何事情发生，产生不了推进力让事情继续进行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">There&#x27;s also all kinds <span class="keyword">of</span> important things outside <span class="keyword">of</span> your career <span class="keyword">that</span> don&#x27;t involve any deadlines,</span><br><span class="line">除了事业之外那些重要的事情也没有截止期，</span><br><span class="line"></span><br><span class="line">like seeing your family <span class="keyword">or</span> exercising <span class="keyword">and</span> taking care <span class="keyword">of</span> your health,</span><br><span class="line">比如看望你的家庭，或者锻炼身体保持身体健康，</span><br><span class="line"></span><br><span class="line">working <span class="keyword">on</span> your relationship <span class="keyword">or</span> getting <span class="keyword">out of</span> a relationship <span class="keyword">that</span> <span class="keyword">isn&#x27;t</span> working.</span><br><span class="line">努力改善恋人关系或者离开一段不满意的关系。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now <span class="keyword">if</span> <span class="keyword">the</span> procrastinator&#x27;s only mechanism <span class="keyword">of</span> doing these hard things <span class="keyword">is</span> <span class="keyword">the</span> Panic Monster, <span class="keyword">that</span>&#x27;s a problem,</span><br><span class="line">如果拖延者做这些困难的事只有一种机制即恐慌怪兽，那么问题来了，</span><br><span class="line"></span><br><span class="line">because <span class="keyword">in</span> all <span class="keyword">of</span> these non-deadline situations, <span class="keyword">the</span> Panic Monster doesn&#x27;t show up.</span><br><span class="line">因为在这些没有截止期的情况下，恐慌怪兽根本不会出现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">He has nothing <span class="keyword">to</span> wake up <span class="keyword">for</span>, so <span class="keyword">the</span> effects <span class="keyword">of</span> procrastination, they&#x27;re <span class="keyword">not</span> contained; they just extend outward forever.</span><br><span class="line">他没有需要醒来的时候，于是拖延的后果是不受限制的，他们只会无限延期。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And <span class="keyword">it</span>&#x27;s this long-term kind <span class="keyword">of</span> procrastination <span class="keyword">that</span>&#x27;s much less visible <span class="keyword">and</span> much less talked <span class="keyword">about</span> than <span class="keyword">the</span> funnier, short-term deadline-based kind.</span><br><span class="line">而这种长期的拖延比起更有趣、更短期、基于截止期的那种拖延来说，不那么明显，也不经常被谈论。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">It&#x27;s usually suffered quietly <span class="keyword">and</span> privately.</span><br><span class="line">它通常是安静地、悄悄地影响我们。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And <span class="keyword">it</span> can be <span class="keyword">the</span> source <span class="keyword">of</span> a huge amount <span class="keyword">of</span> long-term unhappiness, <span class="keyword">and</span> regrets.</span><br><span class="line">它可能是大量长期不快乐、内疚的来源。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">And I thought, <span class="keyword">that</span>&#x27;s why those people are emailing, <span class="keyword">and</span> <span class="keyword">that</span>&#x27;s why they&#x27;re <span class="keyword">in</span> such a bad place.</span><br><span class="line">我觉得，这才是那些人发来邮件的原因，这才是他们处于如此糟糕状况的原因。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">It&#x27;s <span class="keyword">not</span> <span class="keyword">that</span> they&#x27;re cramming <span class="keyword">for</span> <span class="keyword">some</span> project.</span><br><span class="line">不是因为他们为了某个项目狂赶，</span><br><span class="line"></span><br><span class="line">It&#x27;s <span class="keyword">that</span> long-term procrastination has made them feel like a spectator, <span class="keyword">at</span> <span class="keyword">times</span>, <span class="keyword">in</span> their own lives.</span><br><span class="line">而是这种长期拖延使他们感觉在他们自己的生活中有时好像只是一个旁观者。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The frustration <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">that</span> they couldn&#x27;t achieve their dreams; <span class="keyword">it</span>&#x27;s <span class="keyword">that</span> they weren&#x27;t even able <span class="keyword">to</span> start chasing them.</span><br><span class="line">他们的沮丧不是因为他们无法实现自己的梦想；而是他们甚至无法开始去追逐自己的梦想。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So I <span class="built_in">read</span> these emails <span class="keyword">and</span> I had a little bit <span class="keyword">of</span> an epiphany <span class="comment">-- that I don&#x27;t think non-procrastinators exist.</span></span><br><span class="line">所以读完这些邮件之后，我有一点领悟：我认为不存在不拖延的人。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">That&#x27;s right <span class="comment">-- I think all of you are procrastinators.</span></span><br><span class="line">没错，我认为大家都是拖延者。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, you might <span class="keyword">not</span> all be a mess, like <span class="keyword">some</span> <span class="keyword">of</span> us,</span><br><span class="line">现在，你们可能不会像我们中的一些人一样一团糟，</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">some</span> <span class="keyword">of</span> you may have a healthy relationship <span class="keyword">with</span> deadlines, <span class="keyword">but</span> remember: <span class="keyword">the</span> Monkey&#x27;s sneakiest trick <span class="keyword">is</span> when <span class="keyword">the</span> deadlines aren&#x27;t there.</span><br><span class="line">也许有些人可以很好的面对截止日期，但是请记住：猴子最卑鄙的伎俩在于没有截止日期的部分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now, I want <span class="keyword">to</span> show you one <span class="keyword">last</span> thing.</span><br><span class="line">现在我想给大家最后看一样东西。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">I call this a Life Calendar.</span><br><span class="line">我把它叫做生命日历。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">That&#x27;s one box <span class="keyword">for</span> <span class="keyword">every</span> week <span class="keyword">of</span> a <span class="number">90</span>-<span class="built_in">year</span> life.</span><br><span class="line">假设一个人可以活到<span class="number">90</span>岁，每个星期是一个格子。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">That&#x27;s <span class="keyword">not</span> <span class="keyword">that</span> many boxes, especially <span class="keyword">since</span> we&#x27;ve already used a bunch <span class="keyword">of</span> those.</span><br><span class="line">其实没多少格子，尤其是我们已经活了这么多年。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">So I think we need <span class="keyword">to</span> all take a long, hard look <span class="keyword">at</span> <span class="keyword">that</span> calendar.</span><br><span class="line">我认为我们都需要花些时间，认真看一下这个生命日历。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We need <span class="keyword">to</span> think <span class="keyword">about</span> what we&#x27;re really procrastinating <span class="keyword">on</span>, because everyone <span class="keyword">is</span> procrastinating <span class="keyword">on</span> something <span class="keyword">in</span> life.</span><br><span class="line">我们需要认真思考我们真正拖延的是什么，因为每个人都在拖延某件事。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We need <span class="keyword">to</span> stay aware <span class="keyword">of</span> <span class="keyword">the</span> Instant Gratification Monkey.</span><br><span class="line">我们得时刻意识到即时满足这个猴子的存在。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">That&#x27;s a job <span class="keyword">for</span> all <span class="keyword">of</span> us.</span><br><span class="line">这是我们所有人都应该做的事儿。</span><br><span class="line"></span><br><span class="line">And because there&#x27;s <span class="keyword">not</span> <span class="keyword">that</span> many boxes <span class="keyword">on</span> there, <span class="keyword">it</span>&#x27;s a job <span class="keyword">that</span> should probably start today.</span><br><span class="line">而且因为格子并不多，这项工作也许应该从今天就开始。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Well, maybe <span class="keyword">not</span> today, <span class="keyword">but</span> ... You know.</span><br><span class="line">好吧，也许不是今天，但是……你知道的。</span><br><span class="line"></span><br><span class="line">Sometime soon.</span><br><span class="line">反正是不久的将来。</span><br><span class="line"></span><br><span class="line">Thank you.</span><br><span class="line">谢谢。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TEDinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TED </tag>
            
            <tag> 演讲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TED演讲-如何掌控你的自由时间</title>
      <link href="/posts/d2e0bc8f.html"/>
      <url>/posts/d2e0bc8f.html</url>
      
        <content type="html"><![CDATA[<h1>Preface</h1><p>我们常常抱怨没有时间去做自己想做的事情，但<strong>实际上并非真的没有时间，而是没有好好管理时间</strong>。</p><p>这篇演讲告诉我们，时间管理取决于我们自己的选择，我们应该先建立起自己想要的生活，并合理安排时间。</p><h1>Content</h1><blockquote><p>We don’t build the lives we want by saving time. We build the lives we want, and then time saves itself.</p></blockquote><p>并不是通过节省时间来创造想要的生活，而是先创造想要的生活，时间就会自然而然的节省出来。</p><blockquote><p>“I don’t have time,” often means “It’s not a priority.”</p></blockquote><p>我没有时间 = 这不是首要任务</p><hr><p><strong>如何对待首要任务/重要的事？</strong></p><ol><li>找出最重要的事。想象一下今年（2024）的年底，对自己有什么样的期待/打算/计划，罗列一下。</li><li>将这些事情从：事业、人际关系、个人三个维度进行划分。</li><li>每周有大约7*24(全天时间)-9*5(工作时间)-7*8(睡觉时间)-2*7（吃饭、休息时间）≈ 52 小时。利用这每周52小时（主要是周末时间）做上述的事情。</li></ol><p>==当我们关注在重要的事上时，我们可以用所拥有的时间创造我们想要的生活。==</p><h1>Original</h1><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">When</span> people find out I write about time management, they assume two things. One <span class="built_in">is</span> that I<span class="comment">&#x27;m always on time, and I&#x27;m not. I have four small children, and I would like to blame them for my occasional tardiness, but sometimes it&#x27;s just not their fault. I was once late to my own speech on time management.</span></span><br><span class="line"></span><br><span class="line">当人们发现我写 关于时间管理的文章时， 他们都会假设两件事： 第一，我永远都准时， 但我并不是。 我有四个小孩， 我偶尔将迟到归咎于他们， 不过有时候真的不是因为他们。 我有一次在去我的一个关于 时间管理的演讲时迟到了。</span><br><span class="line"></span><br><span class="line">We all had <span class="keyword">to</span> just <span class="keyword">take</span> a moment together <span class="built_in">and</span> savor that irony.</span><br><span class="line"></span><br><span class="line">我们都需要一点时间去好好地 体味一下这有多么讽刺。</span><br><span class="line"></span><br><span class="line">The second thing they assume <span class="built_in">is</span> that I have lots <span class="keyword">of</span> tips <span class="built_in">and</span> tricks <span class="keyword">for</span> saving bits <span class="keyword">of</span> time here <span class="built_in">and</span> there. Sometimes I<span class="comment">&#x27;ll hear from magazines that are doing a story along these lines, generally on how to help their readers find an extra hour in the day. And the idea is that we&#x27;ll shave bits of time off everyday activities, add it up, and we&#x27;ll have time for the good stuff. I question the entire premise of this piece, but I&#x27;m always interested in hearing what they&#x27;ve come up with before they call me. Some of my favorites: doing errands where you only have to make right-hand turns --</span></span><br><span class="line"></span><br><span class="line">第二，人们总是假设我有很多关于 如何节省时间的贴士和技巧。 有时候我听说一些杂志 在写这方面的故事， 通常都是关于教读者如何 在一天中获得额外一个小时。 基本思路就是从日常的 每个活动中挤出一点时间， 加起来， 然后我们就有时间去做 更有意思的事情了。 我对这个说法持保留意见， 不过我还是愿意听听 他们在找我之前有什么想法。 我最喜欢的几个是： 只完成那些只需要右转的事；</span><br><span class="line"></span><br><span class="line">Being extremely judicious <span class="keyword">in</span> microwave usage: it says three <span class="keyword">to</span> three-<span class="built_in">and</span>-a-half minutes <span class="keyword">on</span> the package, we<span class="comment">&#x27;re totally getting in on the bottom side of that. And my personal favorite, which makes sense on some level, is to DVR your favorite shows so you can fast-forward through the commercials. That way, you save eight minutes every half hour, so in the course of two hours of watching TV, you find 32 minutes to exercise.</span></span><br><span class="line"></span><br><span class="line">在用微波炉时，要极度审慎： 当食物包装上面写了<span class="number">3</span>到<span class="number">3.5</span>分钟时， 我们要挑时间最短的那个。 我个人最喜欢的是， 录下你最喜欢看的电视剧， 然后你就可以跳过广告了。 其实在某个程度上，还是挺有道理的。 这样，你每半个小时就可以挤出八分钟。 那么你葱用来看电视的两个小时中， 可以挤出<span class="number">32</span>分钟锻炼的时间。</span><br><span class="line"></span><br><span class="line">Which <span class="built_in">is</span> <span class="literal">true</span>.You know another way <span class="keyword">to</span> find <span class="number">32</span> minutes <span class="keyword">to</span> exercise? Don<span class="comment">&#x27;t watch two hours of TV a day, right?</span></span><br><span class="line"></span><br><span class="line">倒的确是这么回事儿。你还知道其他可以找到 <span class="number">32</span>分钟锻炼时间的方法吗？ 不要每天都看两个小时 电视就行了，对吧？</span><br><span class="line"></span><br><span class="line">Anyway, the idea <span class="built_in">is</span> we<span class="comment">&#x27;ll save bits of time here and there, add it up, we will finally get to everything we want to do. But after studying how successful people spend their time and looking at their schedules hour by hour, I think this idea has it completely backward. We don&#x27;t build the lives we want by saving time. We build the lives we want, and then time saves itself.</span></span><br><span class="line"></span><br><span class="line">总之，就是要在各处都省点时间，加起来就有时间 做我们想做的事了。 但在我了解成功的人如何分配时间， 并看过了他们的时间表后， 我觉得这个想法是 完全本末倒置的。 我们不是通过节省时间来 打造我们想过的生活。 我们应该先建立我们想要的生活， 时间就会自然而然节省出来。 </span><br><span class="line"></span><br><span class="line">Here<span class="comment">&#x27;s what I mean. I recently did a time diary project looking at 1,001 days in the lives of extremely busy women. They had demanding jobs, sometimes their own businesses, kids to care for, maybe parents to care for, community commitments -- busy, busy people. I had them keep track of their time for a week so I could add up how much they worked and slept, and I interviewed them about their strategies, for my book.</span></span><br><span class="line"></span><br><span class="line">我来解释一下。我最近有个时间日记项目， 观察最忙碌的女士生命中的<span class="number">1001</span>天。 她们工作繁忙， 有时候是自己的生意， 有时候要照顾自己的孩子， 或者是照顾父母， 还有服务社区等等—— 都是一些很忙的人。 我让她们记录了一星期的行程， 计算她们工作和睡觉的时间， 为了我的书，我还采访 了解了她们的常用策略。 </span><br><span class="line"></span><br><span class="line">One <span class="keyword">of</span> the women whose time log I studied goes out <span class="keyword">on</span> a Wednesday night <span class="keyword">for</span> something. She comes home <span class="keyword">to</span> find that her water heater has broken, <span class="built_in">and</span> there <span class="built_in">is</span> now water all over her basement. <span class="keyword">If</span> you<span class="comment">&#x27;ve ever had anything like this happen to you, you know it is a hugely damaging, frightening, sopping mess. So she&#x27;s dealing with the immediate aftermath that night, next day she&#x27;s got plumbers coming in, day after that, professional cleaning crew dealing with the ruined carpet. All this is being recorded on her time log. Winds up taking seven hours of her week. Seven hours. That&#x27;s like finding an extra hour in the day.</span></span><br><span class="line"></span><br><span class="line">其中一个被我研究过时间表的女士，在一个周三晚上出去了一趟， 回家发现她的热水器坏了， 地下室都被水淹了。 如果你也遇到过这种事儿的话， 你会知道眼前的景象 多么令人崩溃和沮丧。 于是那个晚上她立刻着手处理， 第二天她找了一个水管工， 第三天找了专业的清理人员 来处理损坏的地毯。 所有这些都算在了她的时间表内。 总共花了她一周中的七个小时。 七个小时。 这就等于一周七天 每天都要挤出一个小时。</span><br><span class="line"></span><br><span class="line">But I<span class="comment">&#x27;m sure if you had asked her at the start of the week, &quot;Could you find seven hours to train for a triathlon?&quot; &quot;Could you find seven hours to mentor seven worthy people?&quot; I&#x27;m sure she would&#x27;ve said what most of us would&#x27;ve said, which is, &quot;No -- can&#x27;t you see how busy I am?&quot; Yet when she had to find seven hours because there is water all over her basement, she found seven hours. And what this shows us is that time is highly elastic. We cannot make more time, but time will stretch to accommodate what we choose to put into it.</span></span><br><span class="line"></span><br><span class="line">但是假如你在这一周 刚开始时就问她，“你能在这周抽出七个小时 来参加铁人三项吗？”， “你能在这周抽出七个小时 指导七个有潜力的人吗？“ 我确定她会像大多数人一样， 说，”怎么可能，你看不出我有多忙吗？“ 但是她最后不得不抽出七个小时， 因为她的地下室都被水淹了， 她挤出了这七个小时。 这件事告诉我们：时间是有弹性的。 我们不能创造更多时间， 但是时间会自己调整去适应 我们选择去做的事情。 </span><br><span class="line"></span><br><span class="line"><span class="built_in">And</span> so the <span class="keyword">key</span> <span class="keyword">to</span> time management <span class="built_in">is</span> treating our priorities <span class="keyword">as</span> the equivalent <span class="keyword">of</span> that broken water heater. <span class="keyword">To</span> <span class="keyword">get</span> at this, I <span class="built_in">like</span> <span class="keyword">to</span> use language <span class="keyword">from</span> one <span class="keyword">of</span> the busiest people I ever interviewed. <span class="keyword">By</span> busy, I mean she was running a small business <span class="keyword">with</span> <span class="number">12</span> people <span class="keyword">on</span> the payroll, she had six children <span class="keyword">in</span> her spare time. I was getting <span class="keyword">in</span> touch <span class="keyword">with</span> her <span class="keyword">to</span> <span class="keyword">set</span> up an interview <span class="keyword">on</span> how she <span class="string">&quot;had it all&quot;</span> -- that phrase. I remember it was a Thursday morning, <span class="built_in">and</span> she was <span class="built_in">not</span> available <span class="keyword">to</span> speak <span class="keyword">with</span> <span class="keyword">me</span>. <span class="keyword">Of</span> course, right?</span><br><span class="line"></span><br><span class="line">所以时间管理的关键就是对待最重要的事情应该像 对待那个坏了的热水器一样。 要做到这一点， 我要借用我采访过最忙的人的话。 她经营着一个小企业， 请了十二名员工， 空余时间她还要照顾六个孩子。 我联系上了她，想要采访她关于 她是怎么做到“无所不能”的。 我记得那是一个星期四的早晨， 她没时间和我说话。 当然了，她很忙。</span><br><span class="line"></span><br><span class="line">But the reason she was unavailable <span class="keyword">to</span> speak <span class="keyword">with</span> <span class="keyword">me</span> <span class="built_in">is</span> that she was out <span class="keyword">for</span> a hike, because it was a beautiful spring morning, <span class="built_in">and</span> she wanted <span class="keyword">to</span> go <span class="keyword">for</span> a hike. So <span class="keyword">of</span> course this makes <span class="keyword">me</span> even more intrigued, <span class="built_in">and</span> <span class="keyword">when</span> I <span class="keyword">finally</span> <span class="keyword">do</span> <span class="keyword">catch</span> up <span class="keyword">with</span> her, she explains it <span class="built_in">like</span> this. She says, <span class="string">&quot;Listen Laura, everything I do, every minute I spend, is my choice.&quot;</span> <span class="built_in">And</span> rather than say, <span class="string">&quot;I don&#x27;t have time to do x, y or z,&quot;</span> she<span class="comment">&#x27;d say, &quot;I don&#x27;t do x, y or z because it&#x27;s not a priority.&quot; &quot;I don&#x27;t have time,&quot; often means &quot;It&#x27;s not a priority.&quot; If you think about it, that&#x27;s really more accurate language. I could tell you I don&#x27;t have time to dust my blinds, but that&#x27;s not true. If you offered to pay me $100,000 to dust my blinds, I would get to it pretty quickly.</span></span><br><span class="line"></span><br><span class="line">但是她没时间和我说话的原因是，她去远足了。 因为那是春季一个美丽的清晨， 所以她去远足了。 这样的她让我变得更感兴趣了， 当我最终联系上她时， 她说：“听我说，劳拉， 我做的所有的事情， 我花的每分每秒，都是我的选择。” 所以与其说， ”我没有时间做这个，这个，或者那个。” 她会说：”我不做这些事情因为 这些不是我的首要任务。“ “我没有时间”的意思通常是 ”那不是我的首要任务”。 其实你想想， 那的确是更准确的说法。 我可能会告诉你我没有 时间清理百叶窗， 但那不是真的。 假如你愿意付我<span class="number">10</span>万美金 让我给百叶窗除尘， 我会马上就去做。 </span><br><span class="line"></span><br><span class="line">Since that <span class="built_in">is</span> <span class="built_in">not</span> going <span class="keyword">to</span> happen, I can acknowledge this <span class="built_in">is</span> <span class="built_in">not</span> a matter <span class="keyword">of</span> lacking time; it<span class="comment">&#x27;s that I don&#x27;t want to do it. Using this language reminds us that time is a choice. And granted, there may be horrible consequences for making different choices, I will give you that. But we are smart people, and certainly over the long run, we have the power to fill our lives with the things that deserve to be there.</span></span><br><span class="line"></span><br><span class="line">既然那不可能发生，我可以说不是因为时间不够， 而是我不想做。 这么说提醒了我们， 时间是一种选择。 我会告诉你， 当然，不同的选择有时候会 带来可怕的后果。 但是我们都是聪明人， 从长远来看， 我们有能力去选择一些值得做的事， 来填补我们生命中的时间。 </span><br><span class="line"></span><br><span class="line">So how <span class="keyword">do</span> we <span class="keyword">do</span> that? How <span class="keyword">do</span> we treat our priorities <span class="keyword">as</span> the equivalent <span class="keyword">of</span> that broken water heater?</span><br><span class="line"></span><br><span class="line">那么我们应该怎么做呢？我们要如何像对待那个 坏了的热水器一样 对待我们的首要任务？</span><br><span class="line"></span><br><span class="line">Well, first we need <span class="keyword">to</span> figure out what they are. I want <span class="keyword">to</span> give you two strategies <span class="keyword">for</span> thinking about this. The first, <span class="keyword">on</span> the professional side: I<span class="comment">&#x27;m sure many people coming up to the end of the year are giving or getting annual performance reviews. You look back over your successes over the year, your &quot;opportunities for growth.&quot; And this serves its purpose, but I find it&#x27;s more effective to do this looking forward. So I want you to pretend it&#x27;s the end of next year. You&#x27;re giving yourself a performance review, and it has been an absolutely amazing year for you professionally. What three to five things did you do that made it so amazing? So you can write next year&#x27;s performance review now.</span></span><br><span class="line"></span><br><span class="line">首先，我们需要找出哪些事最重要。我想给你们分享两个技巧。 第一个，从职业的角度来说： 我相信许多人在年底的时候 会发出或者收到年度绩效审查。 你回头看看这一年的成功和 “成长的机会”。 这的确起到了它的作用， 但是我发现往前看会更有效。 我想让你们把这当做下一年的年底。 你在给自己做年度绩效审查， 在专业方面，这一年的表现非常出众。 是哪三到五件事使 这一年变得如此出众？ 你现在就可以写明年的绩效审查。 </span><br><span class="line"></span><br><span class="line"><span class="built_in">And</span> you can <span class="keyword">do</span> this <span class="keyword">for</span> your personal life, too. I<span class="comment">&#x27;m sure many of you, like me, come December, get cards that contain these folded up sheets of colored paper, on which is written what is known as the family holiday letter.</span></span><br><span class="line"></span><br><span class="line">你也可以在个人生活方面这么做。我相信你们许多人，包括我，在十二月， 都会收到这种夹着彩色纸的卡片。 上面写着“家庭假日信件”。</span><br><span class="line"></span><br><span class="line">Bit <span class="keyword">of</span> a wretched genre <span class="keyword">of</span> literature, really, going <span class="keyword">on</span> about how amazing everyone <span class="keyword">in</span> the household <span class="built_in">is</span>, <span class="built_in">or</span> even more scintillating, how busy everyone <span class="keyword">in</span> the household <span class="built_in">is</span>. But these letters serve a purpose, which <span class="built_in">is</span> that they tell your friends <span class="built_in">and</span> family what you did <span class="keyword">in</span> your personal life that mattered <span class="keyword">to</span> you over the year. So this year<span class="comment">&#x27;s kind of done, but I want you to pretend it&#x27;s the end of next year, and it has been an absolutely amazing year for you and the people you care about. What three to five things did you do that made it so amazing? So you can write next year&#x27;s family holiday letter now. Don&#x27;t send it.</span></span><br><span class="line"></span><br><span class="line">听起来像是一个挺悲惨的文学题材，谈论家里每个人有多了不起， 或者更精彩点， 家里每个人有多忙。 但是这些信有它们的用处， 它们告诉你的朋友和家人 你这一年里做了什么对 个人生活有意义的事。 那么今年快要结束了， 我想让你假装这是明年的年底， 对你和你在乎的人来说， 这都是无与伦比的一年。 哪三到五件事让你这一年 表现如此出色？ 其实你现在就可以写 明年的家庭假日信件了。 先不要发出去。</span><br><span class="line"></span><br><span class="line">Please, don<span class="comment">&#x27;t send it. But you can write it. And now, between the performance review and the family holiday letter, we have a list of six to ten goals we can work on in the next year.</span></span><br><span class="line"></span><br><span class="line">真的，不要发出去。但是你可以写。 现在，有了绩效评估和写给家人的信， 我们就有了六到十个 明年可以努力的目标。</span><br><span class="line"></span><br><span class="line"><span class="built_in">And</span> now we need <span class="keyword">to</span> break these down <span class="keyword">into</span> doable steps. So maybe you want <span class="keyword">to</span> write a family history. First, you can read some other family histories, <span class="keyword">get</span> a sense <span class="keyword">for</span> the style. <span class="keyword">Then</span> maybe think about the questions you want <span class="keyword">to</span> ask your relatives, <span class="keyword">set</span> up appointments <span class="keyword">to</span> interview them. <span class="built_in">Or</span> maybe you want <span class="keyword">to</span> run a <span class="number">5</span>K. So you need <span class="keyword">to</span> find a race <span class="built_in">and</span> sign up, figure out a training plan, <span class="built_in">and</span> dig those shoes out <span class="keyword">of</span> the back <span class="keyword">of</span> the closet. <span class="built_in">And</span> <span class="keyword">then</span> -- this <span class="built_in">is</span> <span class="keyword">key</span> -- we treat our priorities <span class="keyword">as</span> the equivalent <span class="keyword">of</span> that broken water heater, <span class="keyword">by</span> putting them <span class="keyword">into</span> our schedules first. We <span class="keyword">do</span> this <span class="keyword">by</span> thinking through our weeks before we are <span class="keyword">in</span> them.</span><br><span class="line"></span><br><span class="line">我们需要先把他们分成 可行的阶段性任务。或许你要写一个家族传记。 首先，你可以读读别人的家族历史， 了解一下大概的风格。 然后可以想象你要问亲戚的问题， 约定和他们见面谈话的时间。 或者你想要参加一个 五千米的短程马拉松。 你需要先找一个竞赛报名， 再做一个培训计划， 从衣柜底下翻出你的运动鞋。 然后——这是关键—— 我们将我们的首要事件视为 那个坏掉的热水器， 将它们优先放入我们的日程表里。 我们要在事情发生的几周前就先想好。</span><br><span class="line"></span><br><span class="line">I find a really good time <span class="keyword">to</span> <span class="keyword">do</span> this <span class="built_in">is</span> Friday afternoons. Friday afternoon <span class="built_in">is</span> what an economist might <span class="keyword">call</span> a <span class="string">&quot;low opportunity cost&quot;</span> time. Most <span class="keyword">of</span> us are <span class="built_in">not</span> sitting there <span class="keyword">on</span> Friday afternoons saying, <span class="string">&quot;I am excited to make progress toward my personal and professional priorities right now.&quot;</span></span><br><span class="line"></span><br><span class="line">我发现周五的下午最适合处理这事儿。周五的下午是被经济学家称为 “低机会成本”时间。 我们大部分人不会在周五下午想着， “我要朝我的个人和 职业生涯的首要事件迈进了， 所以很兴奋。“</span><br><span class="line"></span><br><span class="line">But we are willing <span class="keyword">to</span> think about what those should be. So <span class="keyword">take</span> a little bit <span class="keyword">of</span> time Friday afternoon, make yourself a three-category priority list: career, relationships, self. Making a three-category list reminds us that there should be something <span class="keyword">in</span> all three categories. Career, we think about; relationships, self -- <span class="built_in">not</span> so much. But anyway, just a <span class="type">short</span> list, two <span class="keyword">to</span> three items <span class="keyword">in</span> <span class="keyword">each</span>. <span class="keyword">Then</span> look out over the whole <span class="keyword">of</span> the <span class="keyword">next</span> week, <span class="built_in">and</span> see <span class="keyword">where</span> you can plan them <span class="keyword">in</span>.</span><br><span class="line"></span><br><span class="line">但是我们愿意去想那些事是什么。所以在周五下午花一点时间， 为自己做一个分成三类的首要事件的列表： 事业，人际关系，个人。 这样的三项分类列表提醒了我们 每一个类别都应该有一些事。 事业，我们经常考虑； 人际关系，个人—— 很少会想。 无论如何，只要一个短短的列表， 每个都包含两到三件事。 它们会帮助我们看清下周， 如何在下周计划这些事情。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Where</span> you plan them <span class="keyword">in</span> <span class="built_in">is</span> up <span class="keyword">to</span> you. I know this <span class="built_in">is</span> going <span class="keyword">to</span> be more complicated <span class="keyword">for</span> some people than others. I mean, some people<span class="comment">&#x27;s lives are just harder than others. It is not going to be easy to find time to take that poetry class if you are caring for multiple children on your own. I get that. And I don&#x27;t want to minimize anyone&#x27;s struggle. But I do think that the numbers I am about to tell you are empowering.</span></span><br><span class="line"></span><br><span class="line">你可以决定如何计划。这可能对一些人来说会比较困难一点。 我的意思是，有些人的 人生就是比较复杂。 如果你自己有好几个要照顾的小孩， 想要找时间去参加诗歌班一定不容易。 我懂。 我不想轻视任何人的困难。 当是我觉得我接下来要说的数字 是会改变你的想法的。</span><br><span class="line"></span><br><span class="line">There are <span class="number">168</span> hours <span class="keyword">in</span> a week. Twenty-four times seven <span class="built_in">is</span> <span class="number">168</span> hours. That <span class="built_in">is</span> a lot <span class="keyword">of</span> time. <span class="keyword">If</span> you are working a full-time job, so <span class="number">40</span> hours a week, sleeping eight hours a night, so <span class="number">56</span> hours a week -- that leaves <span class="number">72</span> hours <span class="keyword">for</span> other things. That <span class="built_in">is</span> a lot <span class="keyword">of</span> time. You say you<span class="comment">&#x27;re working 50 hours a week, maybe a main job and a side hustle. Well, that leaves 62 hours for other things. You say you&#x27;re working 60 hours. Well, that leaves 52 hours for other things. You say you&#x27;re working more than 60 hours. Well, are you sure?</span></span><br><span class="line"></span><br><span class="line">我们每周都有<span class="number">168</span>个小时。<span class="number">24</span>乘以<span class="number">7</span>是<span class="number">168</span>个小时。 这是一段很长时间。 假如你有一个全职的工作， 一周是<span class="number">40</span>个小时， 每晚睡八个小时， 一周是<span class="number">56</span>个小时， 我们有剩下<span class="number">72</span>个小时来做其他事情。 这是一段很长的时间。 假如你说你每周工作<span class="number">50</span>个小时， 比如一份全职和一份兼职。 这样你还是有<span class="number">60</span>小时去做其他的事情。 假如你说你每周工作<span class="number">60</span>个小时， 你还是有<span class="number">52</span>个小时去做其他的事情。 你说你每周工作超过<span class="number">60</span>个小时， 你确定吗？ </span><br><span class="line"></span><br><span class="line">There was once a study comparing people<span class="comment">&#x27;s estimated work weeks with time diaries. They found that people claiming 75-plus-hour work weeks were off by about 25 hours.</span></span><br><span class="line"></span><br><span class="line">曾经有一个研究对比了 人们估计的工作时间，和实际的工作日记。 他们发现那些表示 工作超过<span class="number">75</span>小时的人， 有<span class="number">25</span>小时的误差。</span><br><span class="line"></span><br><span class="line">You can guess <span class="keyword">in</span> which direction, right? Anyway, <span class="keyword">in</span> <span class="number">168</span> hours a week, I think we can find time <span class="keyword">for</span> what matters <span class="keyword">to</span> you. <span class="keyword">If</span> you want <span class="keyword">to</span> spend more time <span class="keyword">with</span> your kids, you want <span class="keyword">to</span> study more <span class="keyword">for</span> a test you<span class="comment">&#x27;re taking, you want to exercise for three hours and volunteer for two, you can. And that&#x27;s even if you&#x27;re working way more than full-time hours.</span></span><br><span class="line"></span><br><span class="line">你可以猜到这个误差 是多了还是少了吧？无论如何，在一周的<span class="number">168</span>个小时里， 我觉得我们总可以找到时间 做我们想做的事。 如果你想花时间陪陪你的孩子， 或者准备你即将到来的考试， 你想锻炼两三个小时或者 做两个小时志愿者， 你都可以的。即便你的工作时间远超过法定时间。</span><br><span class="line"></span><br><span class="line">So we have plenty <span class="keyword">of</span> time, which <span class="built_in">is</span> great, because guess what? We don<span class="comment">&#x27;t even need that much time to do amazing things. But when most of us have bits of time, what do we do? Pull out the phone, right? Start deleting emails. Otherwise, we&#x27;re puttering around the house or watching TV.</span></span><br><span class="line"></span><br><span class="line"> 所以我们有很多时间，这很好。但是你知道吗？ 我们根本不需要那么多时间 去完成一个大目标。 但当我们有一点空闲时间的时候， 我们会做什么？ 拿出手机，是吧？ 开始删除邮件。 或者在家里闲逛， 看电视。</span><br><span class="line"></span><br><span class="line">But small moments can have great power. You can use your bits <span class="keyword">of</span> time <span class="keyword">for</span> bits <span class="keyword">of</span> joy. Maybe it<span class="comment">&#x27;s choosing to read something wonderful on the bus on the way to work. I know when I had a job that required two bus rides and a subway ride every morning, I used to go to the library on weekends to get stuff to read. It made the whole experience almost, almost, enjoyable. Breaks at work can be used for meditating or praying. If family dinner is out because of your crazy work schedule, maybe family breakfast could be a good substitute.</span></span><br><span class="line"></span><br><span class="line">但是每个不起眼的时刻都潜力无限。你可以用零星的时间， 来获得零星的快乐。 比如说在去上班的公车上 读一些精彩的东西。 当我以前的工作需要我 每天早上乘两趟公车 和一趟地铁的时候， 我周末会去图书馆找东西来读。 这几乎，几乎让我的生活更丰富了。 工作间隙的休息时间可以 用来冥想或者祷告。 如果你因为工作忙 而不能吃家庭晚餐， 试一下家庭早餐。</span><br><span class="line"></span><br><span class="line">It<span class="comment">&#x27;s about looking at the whole of one&#x27;s time and seeing where the good stuff can go. I truly believe this. There is time. Even if we are busy, we have time for what matters. And when we focus on what matters, we can build the lives we want in the time we&#x27;ve got.</span></span><br><span class="line"></span><br><span class="line">这就是看着一个人所有的时间，然后找到什么时候可以做想做的事。 我真的相信， 我们都有充分的时间。 就算我们很忙， 我们仍然有时间去做重要的事。 当我们关注在重要的事上时， 我们可以用所拥有的时间 创造我们想要的生活。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TEDinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TED </tag>
            
            <tag> 演讲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-类的加载篇</title>
      <link href="/posts/e49e9f58.html"/>
      <url>/posts/e49e9f58.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><p><strong>类加载都加载哪些</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</span><br></pre></td></tr></table></figure><p><strong>Java类加载过程/加载Class文件的原理机制</strong></p><p><img src="../image/post/image-20240405145730071.png" alt="image-20240405145730071"></p><p>加载/装载 --&gt; 链接 --&gt; 初始化 --&gt; 使用 --&gt; 卸载</p><p><img src="../image/post/image-20240405150832032.png" alt="image-20240405150832032"></p><h2 id="装载阶段">装载阶段</h2><p><strong>装载阶段都干什么</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">简而言之就是将Java类的二进制数据流加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。</span><br><span class="line"><span class="bullet">- </span>通过类的全限定名，获取类的二进制数据流。</span><br><span class="line"><span class="bullet">- </span>解析类的二进制数据流为方法区内的数据结构（Java类模型）</span><br><span class="line"><span class="bullet">- </span>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</span><br></pre></td></tr></table></figure><p><strong>类模板对象</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类模板对象：类在JVM内存中的快照。JVM解析类字节码文件，将常量池、类字段、类方法等信息存储到类模板中。在JVM运行期从类模板中获取任意类的信息。（反射机制基于这一信息）</span><br></pre></td></tr></table></figure><p><strong>类模板对象的位置</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存储在方法区</span><br><span class="line"><span class="bullet">- </span>JDK1.8之前：永久代</span><br><span class="line"><span class="bullet">- </span>1.8之后：元空间</span><br></pre></td></tr></table></figure><p><strong>二进制流的获取方式</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">只要所读取的二进制流（字节码）符合JVM规范即可</span><br><span class="line"><span class="bullet">- </span>虚拟机可能通过文件系统读入一个class后缀的文件（最常见）</span><br><span class="line"><span class="bullet">- </span>读入jar、zip等归档数据包，提取类文件。</span><br><span class="line"><span class="bullet">- </span>事先存放在数据库中的类的二进制数据</span><br><span class="line"><span class="bullet">- </span>使用类似于HTTP之类的协议通过网络进行加载</span><br><span class="line"><span class="bullet">- </span>在运行时生成一段Class的二进制信息等</span><br><span class="line">在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例。</span><br></pre></td></tr></table></figure><p><strong>Class实例（对象）的位置</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JVM解析类模板（方法区）以后，会在堆中创建一个<span class="keyword">Class</span>对象。外部可以通过访问<span class="keyword">Class</span>对象获取该类模板的数据结构。</span><br><span class="line"><span class="keyword">Class</span>实例的构造方法是私有的，只有JVM能够创建。</span><br></pre></td></tr></table></figure><p><strong>数组类的加载</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。</span><br><span class="line"><span class="bullet">1.</span> 如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型；</span><br><span class="line"><span class="bullet">2.</span> JVM使用指定的元素类型和数组维度来创建新的数组类。</span><br><span class="line"><span class="bullet">3.</span> 如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。</span><br></pre></td></tr></table></figure><h2 id="链接阶段">链接阶段</h2><p><strong>链接过程之验证阶段(Verification)</strong></p><p>目的是保证加载的字节码是合法、合理并符合规范的。</p><ul><li>其中格式验证会和装载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li><li>格式验证之外的验证操作将会在方法区中进行。</li><li>符号引用的验证在链接阶段的解析时进行。</li></ul><p><img src="../image/post/image-20240405155919139.png" alt="image-20240405155919139"></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">格式验证：</span><br><span class="line">是否以魔数 OxCAFEBABE开头，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</span><br><span class="line"></span><br><span class="line">语义检查：</span><br><span class="line"><span class="bullet">-</span> <span class="string">是否所有的类都有父类的存在(在Java里，除了Object外，其他类都应该有父类)</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">是否一些被定义为final的方法或者类被重写或继承了</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">非抽象类是否实现了所有抽象方法或者接口方法</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">是否存在不兼容的方法(比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；abstract情况下的方法，就不能是final的了)</span></span><br><span class="line"></span><br><span class="line">字节码验证（最复杂的一个过程）：</span><br><span class="line">Java虚拟机还会进行字节码验证。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。</span><br><span class="line"><span class="bullet">-</span> <span class="string">在字节码的执行过程中，是否会跳转到一条不存在的指令</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">函数的调用是否传递了正确类型的参数</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">变量的赋值是不是给了正确的数据类型等</span></span><br><span class="line">栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。 </span><br><span class="line">栈映射帧的概念，就是表示在执行某一条字节码指令之前，帧的状态，即局部变量表和操作数栈的状态，不是每条字节码前面都有栈映射帧，通常在有条件跳转或无条件跳转之后或者抛出异常之前。</span><br><span class="line"></span><br><span class="line">符号引用的验证：</span><br><span class="line">Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError,如果一个方法无法被找到，则会抛出NoSuchMethodError。</span><br><span class="line">此阶段在解析环节才会执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>链接过程之准备阶段(Preparation)</strong></p><ul><li>static 修饰的静态<strong>变量</strong>(没有final修饰)分配内存，并将其==初始化为默认值==。默认是都是0，或者\u0000 或者null（引用类型）。</li><li>static final修饰的静态<strong>常量</strong>则会==显式赋值==</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Java并不支持<span class="type">boolean</span>类型，对于<span class="type">boolean</span>类型，内部实现是<span class="type">int</span>,由于<span class="type">int</span>的默认值是<span class="number">0</span>,故对应的，<span class="type">boolean</span>的默认值就是<span class="literal">false</span>。</span><br><span class="line"></span><br><span class="line">- 这里不包含基本数据类型的字段用<span class="type">static</span> <span class="keyword">final</span>修饰的情况，因为<span class="keyword">final</span>在编译的时候就会分配了，准备阶段会显式赋值。</span><br><span class="line"></span><br><span class="line">- 注意这里不会为实例变量分配初始化，实例变量是会随着对象一起分配到Java堆中。</span><br><span class="line"></span><br><span class="line">- 在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</span><br></pre></td></tr></table></figure><p><strong>链接过程之解析阶段(Resolution)</strong></p><p>将类、接口、字段和方法的符号引用转为直接引用。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</span><br><span class="line"><span class="bullet">- </span>如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。</span><br></pre></td></tr></table></figure><h2 id="初始化阶段">初始化阶段</h2><p>为类的静态变量赋予正确的初始值。(显式初始化)</p><blockquote><p>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。（即：到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。）</p></blockquote><p>==初始化阶段的重要工作是执行类的初始化方法:&lt;clinit&gt;()方法。==</p><ul><li>该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。</li><li>它是由类静态成员的赋值语句以及static语句块合并产生的。</li></ul><p>&lt;clinit&gt;() : 只有在类中的==static的变量显式赋值==或在==静态代码块中赋值了==。才会生成此方法。<br>&lt;init&gt;()  一定会出现在Class的method表中。</p><p><strong>子类加载前先加载父类？</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的<span class="tag">&lt;<span class="name">clinit</span>&gt;</span>总是在子类<span class="tag">&lt;<span class="name">clinit</span>&gt;</span>之前被调用。也就是说，父类的static块优先级高于子类。 </span><br></pre></td></tr></table></figure><p><strong>哪些类不会生成&lt;clinit&gt;方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- 一个类中并没有声明任何的类变量，也没有静态代码块时</span><br><span class="line">- 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</span><br><span class="line">- 一个类中包含<span class="keyword">static</span> <span class="keyword">final</span>修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * 哪些场景下，java编译器就不会生成&lt;clinit&gt;()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationTest1</span> &#123;</span><br><span class="line">    <span class="comment">//场景1：对于非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> num1;</span><br><span class="line">    <span class="comment">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法。【已在准备阶段赋值，编译时初始化】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>static和final的搭配问题</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>普通基本数据类型和引用类型（即使是常量）的静态变量，是需要额外调用putstatic等JVM指令的，这些是在显式初始化阶段执行，而不是准备阶段调用</span><br><span class="line"><span class="bullet">- </span>基本数据类型常量(非调用方法的显式赋值)、String类型字面量的定义方式的常量，则不需要这样的步骤，是在准备阶段完成的。</span><br></pre></td></tr></table></figure><p><strong>&lt;clinit&gt;()的调用会死锁吗</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为函数<span class="tag">&lt;<span class="name">clinit</span>&gt;</span>()带锁线程安全的，因此，如果在一个类的<span class="tag">&lt;<span class="name">clinit</span>&gt;</span>()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。</span><br><span class="line"></span><br><span class="line">排查方式：</span><br><span class="line">1. 在控制台用jps指令获取对应线程号</span><br><span class="line">2. 使用jstack 线程号 指令看一下字节码的执行情况</span><br></pre></td></tr></table></figure><p><strong>类的主动使用</strong></p><p>Class只有在必须要<strong>首次使用</strong>的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">主动使用只有下列几种情况：</span><br><span class="line"><span class="number">1.</span> 当创建一个类的实例时，比如使用<span class="keyword">new</span>关键字，或者通过反射、克隆、反序列化。</span><br><span class="line"><span class="number">2.</span> 当调用类的静态方法时，即当使用了字节码invokestatic指令。</span><br><span class="line"><span class="number">3.</span> 当使用类、接口的静态字段时(<span class="keyword">final</span>修饰特殊考虑)，比如，使用getstatic或者putstatic指令。</span><br><span class="line"><span class="number">4.</span> 当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(<span class="string">&quot;com.atguigu.java.Test&quot;</span>)</span><br><span class="line"><span class="number">5.</span> 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</span><br><span class="line"><span class="number">6.</span> 如果一个接口定义了<span class="keyword">default</span>方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</span><br><span class="line"><span class="number">7.</span> 当虚拟机启动时，用户需要指定一个要执行的主类（包含<span class="built_in">main</span>()方法的那个类），虚拟机会先初始化这个主类。</span><br><span class="line"><span class="number">8.</span> 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</span><br><span class="line"></span><br><span class="line">针对<span class="number">5</span>，补充说明：</span><br><span class="line">当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</span><br><span class="line">- 在初始化一个类时，并不会先初始化它所实现的接口</span><br><span class="line">- 在初始化一个接口时，并不会先初始化它的父接口</span><br><span class="line">因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</span><br><span class="line"></span><br><span class="line">针对<span class="number">7</span>，说明：</span><br><span class="line">JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用<span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="built_in">main</span>(<span class="type">String</span>[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</span><br></pre></td></tr></table></figure><p><strong>类的被动使用</strong></p><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。<br>也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。</span><br><span class="line">比如：当通过子类引用父类的静态变量，不会导致子类初始化</span><br><span class="line"><span class="bullet">2.</span> 通过数组定义类引用，不会触发此类的初始化</span><br><span class="line"><span class="bullet">3.</span> 引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</span><br><span class="line"><span class="bullet">4.</span> 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</span><br></pre></td></tr></table></figure><blockquote><p>被动的使用，意味着不需要执行初始化环节，意味着没有&lt;clinit&gt;()的调用。</p></blockquote><p><strong>如何追踪类的加载信息</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置参数-<span class="variable constant_">XX</span><span class="symbol">:+TraceClassLoading</span></span><br></pre></td></tr></table></figure><h2 id="使用阶段">使用阶段</h2><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。</p><h2 id="类的卸载">类的卸载</h2><p><strong>类的Class、类的加载器、类的实例之间的引用关系</strong></p><p>类的Class和类的加载器之间为==双向关联关系==。</p><ul><li>类加载器的内部实现中，用一个Java集合来存放该加载器所加载类的引用</li><li>一个类的Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器</li></ul><p>类的实例引用这个类的Class对象，==单向关系==</p><ul><li>在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用</li><li>所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</li></ul><p><img src="../image/post/image-20240405170433390.png" alt="image-20240405170433390"></p><p><strong>类何时被卸载</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以上图为例，</span><br><span class="line">当代表<span class="keyword">Sample</span>类的<span class="keyword">Class</span>对象不再被引用，即不可触及时，<span class="keyword">Class</span>对象就会结束生命周期，<span class="keyword">Sample</span>类在方法区内的数据也会被卸载，从而结束<span class="keyword">Sample</span>类的生命周期。</span><br><span class="line"></span><br><span class="line">loader1变量和obj变量间接引用代表<span class="keyword">Sample</span>类的<span class="keyword">Class</span>对象，而objClass变量则直接引用它。</span><br><span class="line"> </span><br><span class="line">如果程序运行过程中，将上图左侧三个引用变量都置为null，此时<span class="keyword">Sample</span>对象结束生命周期，MyClassLoader对象结束生命周期，代表<span class="keyword">Sample</span>类的<span class="keyword">Class</span>对象也结束生命周期，<span class="keyword">Sample</span>类在方法区内的二进制数据被卸载。</span><br><span class="line"> </span><br><span class="line">当再次有需要时，会检查<span class="keyword">Sample</span>类的<span class="keyword">Class</span>对象是否存在，如果存在会直接使用，不再重新加载；如果不存在<span class="keyword">Sample</span>类会被重新加载，在Java虚拟机的堆区会生成一个新的代表<span class="keyword">Sample</span>类的<span class="keyword">Class</span>实例(可以通过哈希码查看是否是同一个实例)。</span><br></pre></td></tr></table></figure><p><strong>类卸载在实际生产中的情况如何？</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范)</span><br><span class="line"> </span><br><span class="line">(<span class="number">2</span>) 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</span><br><span class="line"> </span><br><span class="line">(<span class="number">3</span>) 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。</span><br><span class="line"> </span><br><span class="line">综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</span><br></pre></td></tr></table></figure><p><strong>方法区的垃圾回收</strong></p><p>主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">废弃的常量：常量池中的常量没有被任何地方引用，就可以被回收。</span><br><span class="line">不再使用的类型：需要同时满足下面三个条件： </span><br><span class="line"><span class="bullet">-</span> 该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。 </span><br><span class="line"><span class="bullet">-</span> 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 </span><br><span class="line"><span class="bullet">-</span> 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</span><br></pre></td></tr></table></figure><h2 id="类加载器">类加载器</h2><p><strong>类加载器的作用/ClassLoader的作用</strong></p><p>JVM 执行类加载机制的前提。==ClassLoader在整个装载阶段，只能影响到类的加载==</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader是Java的核心组件，所有的<span class="keyword">Class</span>都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将<span class="keyword">Class</span>信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.<span class="keyword">Class</span>对象实例。然后交给Java虚拟机进行链接、初始化等操作。</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20240405171820082.png" alt="image-20240405171820082"></p><p><strong>类的加载分类：显式加载 vs 隐式加载</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>文件的显式加载与隐式加载的方式是指<span class="type">JVM</span>加载<span class="keyword">class</span>文件到内存的方式。</span></span><br><span class="line"><span class="class">- 显式加载：指的是在代码中通过调用<span class="type">ClassLoader</span>加载<span class="keyword">class</span>对象，如直接使用<span class="type">Class</span>.forName(<span class="title">name</span>)或this.getClass().getClassLoader().loadClass()加载<span class="keyword">class</span>对象。</span></span><br><span class="line"><span class="class">- 隐式加载：则是不直接在代码中调用<span class="type">ClassLoader</span>的方法加载<span class="keyword">class</span>对象，而是通过虚拟机自动加载到内存中，如在加载某个类的<span class="keyword">class</span>文件时，该类的<span class="keyword">class</span>文件中引用了另外一个类的对象，此时额外引用的类将通过<span class="type">JVM</span>自动加载到内存中。</span></span><br></pre></td></tr></table></figure><p><strong>加载的类是否唯一</strong></p><p>判断加载类的唯一性：同一个类（字节码文件）、同一个类加载器</p><p><strong>类加载机制的基本特征</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java 中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，+而是利用所谓的上下文加载器。</span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="bullet">- </span>可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="bullet">- </span>单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</span><br></pre></td></tr></table></figure><p><strong>类加载器的种类</strong></p><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>引导类加载器：即Bootstrap ClassLoader，C和C++语言编写。</p><p>自定义类加载器：其他类加载器，Java语言编写。</p><p><img src="../image/post/image-20240405172841285.png" alt="image-20240405172841285"></p><p><strong>引导类加载器</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</span><br><span class="line"><span class="bullet">- </span>它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</span><br><span class="line"><span class="bullet">- </span>并不继承自java.lang.ClassLoader，没有父加载器。</span><br><span class="line"><span class="bullet">- </span>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</span><br><span class="line"><span class="bullet">- </span>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</span><br></pre></td></tr></table></figure><p><strong>扩展类加载器</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</span><br><span class="line">继承于ClassLoader类</span><br><span class="line"><span class="bullet">- </span>父类加载器为启动类加载器</span><br><span class="line"><span class="bullet">- </span>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</span><br></pre></td></tr></table></figure><p><strong>系统类加载器</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>java语言编写，由sun.misc.Launcher$AppClassLoader实现</span><br><span class="line"><span class="bullet">- </span>继承于ClassLoader类</span><br><span class="line"><span class="bullet">- </span>父类加载器为扩展类加载器</span><br><span class="line"><span class="bullet">- </span>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 </span><br><span class="line"><span class="bullet">- </span>应用程序中的类加载器默认是系统类加载器。</span><br><span class="line"><span class="bullet">- </span>它是用户自定义类加载器的默认父加载器</span><br><span class="line"><span class="bullet">- </span>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</span><br></pre></td></tr></table></figure><p><strong>获取类加载器的途径</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">获得当前类的ClassLoader</span><br><span class="line">- clazz<span class="selector-class">.getClassLoader</span>()</span><br><span class="line"></span><br><span class="line">获得当前线程上下文的ClassLoader</span><br><span class="line">- Thread<span class="selector-class">.currentThread</span>()<span class="selector-class">.getContextClassLoader</span>()</span><br><span class="line"></span><br><span class="line">获得系统的ClassLoader</span><br><span class="line">- ClassLoader<span class="selector-class">.getSystemClassLoader</span>()</span><br></pre></td></tr></table></figure><p><strong>深入分析ClassLoader</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">主要方法：</span><br><span class="line"></span><br><span class="line">- <span class="keyword">public</span> <span class="keyword">final</span> ClassLoader getParent()</span><br><span class="line">返回该类加载器的超类加载器</span><br><span class="line"></span><br><span class="line">- <span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String <span class="keyword">name</span>) throws ClassNotFoundException</span><br><span class="line">加载名称为<span class="keyword">name</span>的类，返回结果为java.lang.<span class="keyword">Class</span>类的实例。如果找不到类，则返回 ClassNotFoundException 异常。该方法中的逻辑就是双亲委派模式的实现。</span><br><span class="line"></span><br><span class="line">- <span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; findClass(String <span class="keyword">name</span>) throws ClassNotFoundException</span><br><span class="line">查找二进制名称为<span class="keyword">name</span>的类，返回结果为java.lang.<span class="keyword">Class</span>类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</span><br><span class="line"></span><br><span class="line">-<span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">Class</span>&lt;?&gt; defineClass(String <span class="keyword">name</span>, byte[] b, <span class="built_in">int</span> off, <span class="built_in">int</span> len)</span><br><span class="line">根据给定的字节数组b转换为<span class="keyword">Class</span>的实例，off和len参数表示实际<span class="keyword">Class</span>信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</span><br><span class="line">defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的<span class="keyword">Class</span>对象</span><br><span class="line"></span><br><span class="line">- <span class="keyword">protected</span> <span class="keyword">final</span> void resolveClass(<span class="keyword">Class</span>&lt;?&gt; c)</span><br><span class="line">链接指定的一个Java类。使用该方法可以使用类的<span class="keyword">Class</span>对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</span><br><span class="line"></span><br><span class="line">- rotected <span class="keyword">final</span> <span class="keyword">Class</span>&lt;?&gt; findLoadedClass(String <span class="keyword">name</span>)</span><br><span class="line">查找名称为<span class="keyword">name</span>的已经被加载过的类，返回结果为java.lang.<span class="keyword">Class</span>类的实例。这个方法是<span class="keyword">final</span>方法，无法被修改。</span><br><span class="line"></span><br><span class="line">- <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中,ClassLoader可能会将某些请求交予自己的双亲处理。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">涉及到对如下方法的调用：</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="comment">//resolve:true-加载class的同时进行解析操作。</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123; <span class="comment">//同步操作，保证只能加载一次。</span></span><br><span class="line">        <span class="comment">//首先，在缓存中判断是否已经加载同名的类。</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//获取当前类加载器的父类加载器。</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//parent为null:父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; <span class="comment">//当前类的加载器的父类加载器未加载此类 or 当前类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// 调用当前ClassLoader的findClass()</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>SecureClassLoader 与 URLClassLoader</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SecureClassLoader:</span><br><span class="line">SecureClassLoader扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对<span class="keyword">class</span>源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类<span class="symbol">URLClassLoader</span>有所关联。</span><br><span class="line"></span><br><span class="line"><span class="symbol">URLClassLoader:</span></span><br><span class="line"><span class="symbol"><span class="symbol">ClassLoader</span></span>是一个抽象类，很多方法是空的没有实现，比如 <span class="symbol">findClass</span>()、<span class="symbol">findResource</span>()等。而<span class="symbol">URLClassLoader</span>这个实现类为这些方法提供了具体的实现。并新增了<span class="symbol">URLClassPath</span>类协助取得<span class="symbol">Class</span>字节码流等功能。</span><br></pre></td></tr></table></figure><p>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承<strong>URLClassLoader类</strong>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p><strong>ExtClassLoader 与 AppClassLoader</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ExtClassLoader并没有重写<span class="built_in">loadClass</span>()方法，这足矣说明其遵循双亲委派模式</span><br><span class="line">- AppClassLoader重载了<span class="built_in">loadClass</span>()方法，但最终调用的还是父类<span class="built_in">loadClass</span>()方法，因此依然遵守双亲委派模式。</span><br></pre></td></tr></table></figure><p><strong>Class.forName() 与 ClassLoader.loadClass()</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">Class</span>.forName()：是一个静态方法,最常用的是<span class="keyword">Class</span>.forName(<span class="type">String</span> className);根据传入的类的全限定名返回一个 <span class="keyword">Class</span> 对象。该方法在将 <span class="keyword">Class</span> 文件加载到内存的同时,会执行类的初始化。如: <span class="keyword">Class</span>.forName(<span class="string">&quot;com.atguigu.java.HelloWorld&quot;</span>);</span><br><span class="line"> </span><br><span class="line">- ClassLoader.loadClass()：这是一个实例方法,需要一个 ClassLoader 对象来调用该方法。该方法将 <span class="keyword">Class</span> 文件加载到内存时,并不会执行类的初始化,直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象,所以可以根据需要指定使用哪个类加载器。</span><br></pre></td></tr></table></figure><p><strong>为什么要自定义类加载器</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>隔离加载类</span><br><span class="line">在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。 （类的仲裁--&gt;类冲突）</span><br><span class="line"><span class="bullet">- </span>修改类加载的方式</span><br><span class="line">类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</span><br><span class="line"><span class="bullet">- </span>扩展加载源</span><br><span class="line">比如从数据库、网络、甚至是电视机机顶盒进行加载</span><br><span class="line"><span class="bullet">- </span>防止源码泄漏</span><br><span class="line">Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</span><br></pre></td></tr></table></figure><h2 id="双亲委派机制">双亲委派机制</h2><p><strong>什么是双亲委派机制/双亲委派机制的本质？</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</span><br><span class="line"></span><br><span class="line">本质：</span><br><span class="line">规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</span><br></pre></td></tr></table></figure><p><strong>双亲委派机制的优缺点</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"><span class="bullet">- </span>避免类的重复加载，确保一个类的全局唯一性</span><br><span class="line"><span class="code">Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</span></span><br><span class="line"><span class="bullet">- </span>保护程序安全，防止核心API被随意篡改</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"><span class="bullet">- </span>顶层的ClassLoader无法访问底层的ClassLoader所加载的类。（后来为了解决这个问题，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader））</span><br><span class="line"><span class="code">通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</span></span><br></pre></td></tr></table></figure><p><strong>tomcat的类加载机制</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Tomcat8 和 Tomcat6比较大的区别是 ：</span><br><span class="line">Tomcat8可以通过配置 &lt;Loader <span class="keyword">delegate</span>=<span class="string">&quot;true&quot;</span>/&gt;表示遵循双亲委派机制。</span><br><span class="line"></span><br><span class="line">当tomcat启动时，会创建几种类加载器：</span><br><span class="line"><span class="number">1</span>. Bootstrap 引导类加载器 </span><br><span class="line">加载JVM启动所需的类，以及标准扩展类（位于jre/<span class="keyword">lib</span>/ext下）</span><br><span class="line"><span class="number">2</span>. System 系统类加载器 </span><br><span class="line">加载tomcat启动的类，比如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME/bin下。</span><br><span class="line"><span class="number">3</span>. CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader</span><br><span class="line">这些是Tomcat自己定义的类加载器，它们分别加载/common/*、/server/*、/<span class="keyword">shared</span>/*（在tomcat <span class="number">6</span>之后已经合并到根目录下的<span class="keyword">lib</span>目录下）和/WebApp/WEB-INF/*中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。</span><br><span class="line">- commonLoader：Tomcat最基本的类加载器，加载路径中的<span class="keyword">class</span>可以被Tomcat容器本身以及各个Webapp访问；（加载CATALINA_HOME/<span class="keyword">lib</span>下的结构，比如servlet-api.jar）</span><br><span class="line">- catalinaLoader：Tomcat容器私有的类加载器，加载路径中的<span class="keyword">class</span>对于Webapp不可见；</span><br><span class="line">- sharedLoader：各个Webapp共享的类加载器，加载路径中的<span class="keyword">class</span>对于所有Webapp可见，但是对于Tomcat容器不可见；</span><br><span class="line">- WebappClassLoader：单个Tomcat实例中各个Web应用程序私有的类加载器，加载路径中的<span class="keyword">class</span>只对当前Webapp可见；(加载WEB-INF/<span class="keyword">lib</span>和WEB-INF/classes下的结构）</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20240405175956685.png" alt="image-20240405175956685"></p><p><strong>tomcat 违背了java 推荐的双亲委派模型了吗</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">违背了。双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应当由自己的父类加载器加载。</span><br><span class="line">但tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</span><br><span class="line"></span><br><span class="line">Web应用默认的类加载顺序是（打破了双亲委派规则）：</span><br><span class="line">①先从JVM的BootStrapClassLoader中加载。</span><br><span class="line">②加载Web应用下<span class="string">/WEB-INF/classes</span>中的类。</span><br><span class="line">③加载Web应用下<span class="string">/WEB-INF/lib/</span>*<span class="string">.jap</span>中的jar包中的类。</span><br><span class="line">④加载上面定义的System路径下面的类。</span><br><span class="line">⑤加载上面定义的Common路径下面的类。</span><br><span class="line"></span><br><span class="line">如果在配置文件中配置了` &lt;Loader delegate=<span class="string">&quot;true&quot;</span>/&gt;`，那么就是遵循双亲委派规则，加载顺序如下：</span><br><span class="line">①先从JVM的BootStrapClassLoader中加载。</span><br><span class="line">②加载上面定义的System（应用类加载器）路径下面的类。</span><br><span class="line">③加载上面定义的Common路径下面的类。</span><br><span class="line">④加载Web应用下<span class="string">/WEB-INF/classes</span>中的类。</span><br><span class="line">⑤加载Web应用下<span class="string">/WEB-INF/lib/</span>*<span class="string">.jap</span>中的jar包中的类。</span><br></pre></td></tr></table></figure><p><strong>JDK9中类加载结构的变化</strong></p><p><img src="../image/post/image-20240405180454786.png" alt="image-20240405180454786"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。</span><br><span class="line">现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.<span class="built_in">int</span>ernal.loader.BuiltinClassLoader。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Java <span class="number">9</span>中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回<span class="literal">null</span>，而不会得到BootClassLoader实例。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 类加载的委派关系也发生了变动。</span><br><span class="line">当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform <span class="keyword">class</span> <span class="symbol">loader</span>）。可以通过<span class="symbol">ClassLoader</span>的新方法<span class="symbol">getPlatformClassLoader</span>()来获取。</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20240405180730166.png" alt="image-20240405180730166"></p><h1>面试题</h1><p><strong>类加载的时机（百度）/哪些情况会触发类的加载（京东）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即类的主动使用</span><br></pre></td></tr></table></figure><p><strong>Class的forName(“Java.lang.String”)和Class的getClassLoader()的loadClass(“Java.lang.String”)有什么区别？  （百度）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即主动使用、被动使用</span><br></pre></td></tr></table></figure><p><strong>JVM类加载机制  （滴滴）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即类的加载过程</span><br></pre></td></tr></table></figure><p><strong>什么是类加载器，类加载器有哪些？（字节跳动）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即类加载器的种类</span><br></pre></td></tr></table></figure><p><strong>深入分析ClassLoader（蚂蚁金服）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即深入分析ClassLoader</span><br></pre></td></tr></table></figure><p><strong>手写一个类加载器Demo （百度）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承ClassLoader类，重写findclass方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassloader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line">  <span class="keyword">private</span> String classloaderName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyClassloader</span><span class="params">(String path,String classloaderName)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.path = path;</span><br><span class="line">    <span class="built_in">this</span>.classloaderName = classloaderName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用于寻找类文件</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class <span class="title function_">findClass</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] b =loadClassData(name);</span><br><span class="line">    <span class="keyword">return</span> defineClass(name,b,<span class="number">0</span>,b.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">    name = path + name + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(name));</span><br><span class="line">      out = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((i = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">      out.write(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建测试类，测试结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoderCheck</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">MyClassloader</span> <span class="variable">classloader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassloader</span>(<span class="string">&quot;D:/jvm/&quot;</span>, <span class="string">&quot;myclasscloderz&quot;</span>);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> classloader.loadClass(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    System.out.println(c.getClassLoader());</span><br><span class="line">    System.out.println(c.getClassLoader().getParent());</span><br><span class="line">    System.out.println(c.getClassLoader().getParent().getParent());</span><br><span class="line">    c.newInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>双亲委派机制及使用原因 （蚂蚁金服）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同什么是双亲委派机制/双亲委派机制的本质？</span><br></pre></td></tr></table></figure><p><strong>双亲委派机制可以打破吗？为什么 （京东）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同双亲委派机制的优缺点中的缺点</span><br></pre></td></tr></table></figure><p><strong>请解释tomcat的类加载机制？（阿里）</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同tomcat的类加载机制</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习-字节码篇</title>
      <link href="/posts/71ac037e.html"/>
      <url>/posts/71ac037e.html</url>
      
        <content type="html"><![CDATA[<h1>前言</h1><p>视频教程：<a href="https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6">https://www.bilibili.com/video/BV1Dz4y1A7FB?p=2&amp;vd_source=85ac5ee1b07df12a44b648a8751d30f6</a></p><h1>相关知识点</h1><p><strong>JVM的生命周期</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 启动</span><br><span class="line">Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定。</span><br><span class="line">- 退出</span><br><span class="line">某线程调用Runtime类或System类的<span class="keyword">exit</span>方法，或 Runtime类的halt方法，并且Java安全管理器也允许这次<span class="keyword">exit</span>或halt操作。</span><br><span class="line">程序正常执行结束</span><br><span class="line">程序在执行过程中遇到了异常或错误而异常终止</span><br><span class="line">由于操作系统出现错误而导致Java虚拟机进程终止</span><br></pre></td></tr></table></figure><p><strong>什么是JVM</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>虚拟机</span><br><span class="line"><span class="code">虚拟的物理机，指以软件的方式模拟具有完整硬件系统功能。</span></span><br><span class="line"><span class="bullet">- </span>JVM</span><br><span class="line"><span class="code">JVM是可运行字节码的虚拟机。JVM屏蔽了与具体平台相关的信息，只与“Class 文件”这种特定的二进制文件格式所关联。</span></span><br></pre></td></tr></table></figure><p><strong>JVM架构图/体系结构</strong></p><p><img src="../image/post/image-20240323120702047.png" alt="image-20240323120702047"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 架构</span><br><span class="line">最上层：javac编译器将编译好的字节码class文件，通过java类装载器执行机制，把对象或class文件存放在jvm划分内存区域。</span><br><span class="line">中间层：称为Runtime Data Area，主要是在Java代码运行时用于存放数据的，从左至右为方法区(永久代、元数据区)、堆(共享,GC回收对象区域)、栈、程序计数器、寄存器、本地方法栈(私有)。</span><br><span class="line">最下层：解释器、<span class="built_in">JIT</span>(just in time)编译器和 GC（Garbage Collection，垃圾回收器）</span><br><span class="line">- 相关知识</span><br><span class="line">类加载、内存结构和分配、垃圾回收、性能监控、性能优化</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20240323120416657.png" alt="image-20240323120416657"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HotSpot虚拟机体系结构（如上图，图要会画）</span><br></pre></td></tr></table></figure><p><strong>Class文件里面是什么</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码经过编译器编译之后便会生成一个字节码文件，是一种二进制的类文件，它的内容是<span class="variable">JVM</span>的指令，而不像<span class="built_in">C</span>、<span class="built_in">C</span><span class="operator">++</span>经由编译器直接生成机器码。</span><br></pre></td></tr></table></figure><p><strong>什么是编译器</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM的编译器：将源代码编译成字节码（前端编译器）</span><br></pre></td></tr></table></figure><p><strong>JAVA编译器的编译步骤</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">词法解析、语法解析、语义解析、生成字节码</span><br></pre></td></tr></table></figure><p><strong>哪些类型对应有Class对象</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）<span class="keyword">class</span>：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</span><br><span class="line">（<span class="symbol">2</span>）<span class="symbol">interface</span>：接口</span><br><span class="line">（<span class="symbol">3</span>）[]：数组</span><br><span class="line">（<span class="symbol">4</span>）<span class="symbol">enum</span>：枚举</span><br><span class="line">（<span class="symbol">5</span>）<span class="symbol">annotation</span>：注解@<span class="symbol">interface</span></span><br><span class="line">（<span class="symbol">6</span>）<span class="symbol">primitive</span> <span class="symbol">type</span>：基本数据类型</span><br><span class="line">（<span class="symbol">7</span>）<span class="symbol">void</span></span><br></pre></td></tr></table></figure><p><strong>JAVA半编译半解释型语言</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JAVA的执行引擎包括：解释器和JIT</span></span><br><span class="line"><span class="keyword"></span>解释器：将字节码文件逐行解释成机器码</span><br><span class="line"><span class="keyword">JIT：直接将热点代码编译成本地机器指令</span></span><br></pre></td></tr></table></figure><p><strong>Class文件结构</strong></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">魔数：每个 <span class="keyword">Class</span> 文件开头的<span class="number">4</span>个字节的无符号整数称为魔数。它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的<span class="keyword">Class</span>文件。魔数值固定为<span class="number">0</span>xCAFEBABE。不会改变。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span>文件版本：保证高版本的JVM可执行低版本的<span class="keyword">Class</span>文件</span><br><span class="line"></span><br><span class="line">常量池：存放所有常量。准确说存放编译时期生成的各种字面量和符号引用，在类加载后进入方法区的运行时常量池中。</span><br><span class="line"></span><br><span class="line">访问标识(或标志)：用于识别一些类或者接口层次的访问信息。包括：这个 <span class="keyword">Class</span> 是类还是接口；是否定义为 <span class="keyword">public</span> 类型；是否定义为 <span class="keyword">abstract</span> 类型；如果是类的话，是否被声明为 <span class="keyword">final</span> 等。</span><br><span class="line"></span><br><span class="line">类索引，父类索引，接口索引集合：指定类类别、父类类别、实现的接口，确定类的全限定名。</span><br><span class="line"></span><br><span class="line">字段表集合：描述接口或类中声明的变量。</span><br><span class="line"></span><br><span class="line">方法表集合：描述了每个方法的签名。</span><br><span class="line"></span><br><span class="line">属性表集合：<span class="keyword">class</span>文件所携带的辅助信息。</span><br></pre></td></tr></table></figure><p><strong>常量池表</strong></p><ul><li>常量池是一种表结构。主要存放两大类常量：字面量和符号引用。</li><li>主要包含class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。</li><li>第1个字节作为类型标记，用于确定该项的格式，这个字节称为tag byte （标记字节、标签字节）。</li></ul><p><img src="../image/post/image-20240323171147458.png" alt="image-20240323171147458"></p><ul><li>这14种表（或者常量项结构）的共同点是：表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li><li>在常量池列表中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li><li>这14种常量项结构还有一个特点是，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，其大小由length决定。为什么呢？因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过utf-8编码，就可以知道其长度。</li></ul><p><strong>符号引用、直接引用的区别</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载<span class="keyword">Class</span>文件的时候进行动态链接。也就是说，在最初生成的<span class="keyword">Class</span>文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。  </span><br><span class="line"></span><br><span class="line">符号引用和直接引用的区别与关联：</span><br><span class="line">符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。 </span><br><span class="line">直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</span><br></pre></td></tr></table></figure><p><strong>访问标识</strong></p><p><img src="../image/post/image-20240323172441691.png" alt="image-20240323172441691"></p><p><strong>类索引、父类索引、接口索引集合</strong></p><p><img src="../image/post/image-20240323172748310.png" alt="image-20240323172748310"></p><ul><li>this_class（类索引）</li><li>super_class （父类索引）</li><li>interfaces（接口索引）</li><li>interfaces_count (接口计数器)</li><li>interfaces [](接口索引集合)</li></ul><h1>面试题</h1><p><strong>println的结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.print();</span><br><span class="line">        x = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.x = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.print();</span><br><span class="line">        x = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.x = &quot;</span> + x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="comment">//Father f = new Father();</span></span><br><span class="line">        <span class="comment">//Son f = new Son();</span></span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>Son.x = 0<br>Son.x = 30<br>20</p></blockquote><p>分析：父类f指向子类Son的引用。顺序：先初始化父类，再初始化子类。</p><p>①即父类的普通代码块和普通变量：x = 30</p><p>②父类的构造方法。 ==父类的构造方法的this指向Son，调用子类的print方法，但子类的x没有赋值，默认是0，所以打印Son.x = 0。并将父类的x赋值为20==</p><p>③子类普通代码块和普通变量。子类x=30</p><p>④子类的构造方法。==子类x=30，调用子类的print方法，打印Son.x = 30。并将子类的x赋值为40==</p><p>⑤执行main中的f.x。==f类型是父类，所以取父类中的x，为20。打印20==</p><blockquote><p>相关知识点：子类初始化的顺序、多态</p><p>子类初始化的顺序：</p><blockquote><p>① 父类静态代码块和静态变量。</p><p>② ==子类静态代码块和静态变量。==</p><p>③ 父类普通代码块和普通变量。</p><p>④ 父类构造方法。</p><p>⑤ 子类普通代码块和普通变量。</p><p>⑥ 子类构造方法。</p></blockquote><p>多态：当出现 父类 指向 子类的对象时 （向上转型）</p><blockquote><p>①父类和子类<strong>出现重名</strong>的<strong>属性</strong>：向上转型的时候代表父类，所以当父类和子类出现同名的属性，对象使用的是父类的。（调用属性的时候看的是<strong>左边定义的类型</strong>)</p><p>②父类和子类<strong>出现重名</strong>的<strong>方法</strong>：看的是实际指向的子类对象在堆内存中的内容。（看<strong>右边实际创建的对象</strong>）</p><p>③可以调用父类特有的属性或方法，不能调用子类特有的属性或方法</p></blockquote></blockquote><p><strong>字节码指令都有哪些</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">加载与存储指令：xload&lt;n&gt;、<span class="keyword">xstore</span>&lt;n&gt;等</span><br><span class="line">算术指令：iadd、<span class="keyword">sub</span>、<span class="keyword">mul</span>、<span class="keyword">div</span>等</span><br><span class="line">类型转换指令：i2l、l2i、i2b、b2i等</span><br><span class="line">对象的创建与访问指令：new、getstatic、getfield等</span><br><span class="line">方法调用与返回指令：invokevirtual、invokeinterface、invokespecial、invokestatic 、invokedynamic、ireturn、lreturn、freturn、dreturn和areturn</span><br><span class="line">操作数栈管理指令：<span class="keyword">pop</span>，pop2</span><br><span class="line">控制转移指令：ifeq, iflt, ifle, ifne, ifgt, ifge</span><br><span class="line">异常处理指令：athrow</span><br><span class="line">同步控制指令：ACC_SYNCHRONIZED 、monitorenter 、monitorexit </span><br></pre></td></tr></table></figure><p>方法调用指令</p><ul><li>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</li><li>invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法。这些方法都是静态类型绑定的，不会在调用时进行动态派发。</li><li>invokestatic指令用于调用命名类中的类方法（static方法）。这是静态绑定的。</li><li>invokedynamic：调用动态绑定的方法，这个是JDK 1.7后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在 java 虚拟机内部，而 invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><p><strong>字节码指令相关面试</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a <span class="operator">=</span> <span class="number">1</span><span class="comment">;JVM如何取得a的值（圆通）</span></span><br><span class="line">Integer x <span class="operator">=</span> <span class="number">5</span><span class="comment">;int y = 5;比较 x == y 都经过哪些步骤？（百度）</span></span><br></pre></td></tr></table></figure><p><strong>Java虚拟机中，数据类型可以分为哪几类？  (阿里)</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>数据类型可以分为两种：基本类型和引用类型，基本类型的变量持有原始值，而引用类型的变量持有引用值。</span><br><span class="line"><span class="number">2.</span> Java语言中的所有基本类型同样也都是Java虚拟机中的基本类型。但是<span class="keyword">boolean</span>有点特别，虽然Java虚拟机也把<span class="keyword">boolean</span>看做基本类型，但是指令集对<span class="keyword">boolean</span>只有很有限的支持，当编译器把Java源代码编译为字节码时，它会用<span class="keyword">int</span>或者<span class="keyword">byte</span>来表示<span class="keyword">boolean</span>。在Java虚拟机中，<span class="keyword">false</span>是由整数零来表示的，所有非零整数都表示<span class="keyword">true</span>，涉及<span class="keyword">boolean</span>值的操作则会使用<span class="keyword">int</span>。另外，<span class="keyword">boolean</span>数组是当做<span class="keyword">byte</span>数组来访问的。</span><br><span class="line"><span class="number">3.</span> Java虚拟机还有一个只在内部使用的基本类型：returnAddress，Java程序员不能使用这个类型，这个基本类型被用来实现Java程序中的<span class="keyword">finally</span>子句。该类型是jsr, ret以及jsr_w指令需要使用到的，它的值是JVM指令的操作码的指针。returnAddress类型不是简单意义上的数值，不属于任何一种基本类型，并且它的值是不能被运行中的程序所修改的。</span><br><span class="line"><span class="number">4.</span> Java虚拟机的引用类型被统称为“引用（reference）”，有三种引用类型：类类型、接口类型、以及数组类型，它们的值都是对动态创建对象的引用。类类型的值是对类实例的引用；数组类型的值是对数组对象的引用，在Java虚拟机中，数组是个真正的对象；而接口类型的值，则是对实现了该接口的某个类实例的引用。还有一种特殊的引用值是<span class="keyword">null</span>，它表示该引用变量没有引用任何对象。</span><br></pre></td></tr></table></figure><p><img src="../image/post/image-20240323175013401.png" alt="image-20240323175013401"></p><p><strong>为什么不把基本类型放堆中呢？  (阿里)</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先是栈、堆的特点不同。（堆比栈要大，但是栈比堆的运算速度要快。）</span><br><span class="line">将复杂数据类型放在堆中的目的是为了不影响栈的效率，而是通过引用的方式去堆中查找。（八大基本类型的大小创建时候已经确立大小。三大引用类型创建时候无法确定大小）</span><br><span class="line">简单数据类型比较稳定，并且它只占据很小的内存，将它放在空间小、运算速度快的栈中，能够提高效率。</span><br></pre></td></tr></table></figure><p><strong>Java中的参数传递是传值呢？还是传引用？ (阿里)</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值传递</span><br></pre></td></tr></table></figure><p><strong>Java中有没有指针的概念？  (阿里)</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVMinG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
